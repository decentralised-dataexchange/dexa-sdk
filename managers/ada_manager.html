<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>dexa_sdk.managers.ada_manager API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>dexa_sdk.managers.ada_manager</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import base64
import asyncio
import uuid
import typing
import json
import aiohttp
from loguru import logger
from web3._utils.encoding import to_json
from marshmallow.exceptions import ValidationError
from aries_cloudagent.wallet.base import BaseWallet, DIDInfo
from aries_cloudagent.wallet.indy import IndyWallet
from aries_cloudagent.config.injection_context import InjectionContext
from aries_cloudagent.core.error import BaseError
from aries_cloudagent.core.dispatcher import DispatcherResponder
from aries_cloudagent.utils.task_queue import CompletedTask, PendingTask
from aries_cloudagent.messaging.decorators.transport_decorator import TransportDecorator
from aries_cloudagent.transport.pack_format import BaseWireFormat, PackWireFormat
from aries_cloudagent.connections.models.connection_record import ConnectionRecord
from aries_cloudagent.messaging.decorators.default import DecoratorSet
from aries_cloudagent.messaging.responder import BaseResponder
from aries_cloudagent.messaging.models.base_record import match_post_filter
from aries_cloudagent.messaging.agent_message import AgentMessage
from aries_cloudagent.cache.basic import BaseCache
from aries_cloudagent.protocols.basicmessage.v1_0.messages.basicmessage import BasicMessage
from aries_cloudagent.protocols.connections.v1_0.messages.connection_invitation import (
    ConnectionInvitation
)
from aries_cloudagent.protocols.connections.v1_0.manager import (
    ConnectionManagerError
)
from aries_cloudagent.protocols.issue_credential.v1_0.models.credential_exchange import (
    V10CredentialExchange
)
from aries_cloudagent.protocols.present_proof.v1_0.models.presentation_exchange import (
    V10PresentationExchange
)
from aries_cloudagent.transport.inbound.receipt import MessageReceipt
from aries_cloudagent.protocols.problem_report.v1_0.message import ProblemReport
from aries_cloudagent.protocols.present_proof.v1_0.messages.presentation_request import (
    PresentationRequest
)
from aries_cloudagent.protocols.present_proof.v1_0.message_types import (
    ATTACH_DECO_IDS,
    PRESENTATION_REQUEST
)
from aries_cloudagent.messaging.decorators.attach_decorator import AttachDecorator
from aries_cloudagent.indy.util import generate_pr_nonce
from mydata_did.v1_0.utils.util import bool_to_str, str_to_bool
from mydata_did.patched_protocols.present_proof.v1_0.manager import PresentationManager
from mydata_did.v1_0.messages.data_agreement_offer import (
    DataAgreementNegotiationOfferMessage
)
from mydata_did.v1_0.messages.data_agreement_accept import (
    DataAgreementNegotiationAcceptMessage
)
from mydata_did.v1_0.message_types import (
    DATA_AGREEMENT_NEGOTIATION_OFFER,
    DATA_AGREEMENT_NEGOTIATION_ACCEPT,
)
from mydata_did.v1_0.decorators.data_agreement_context_decorator import (
    DataAgreementContextDecorator,
)
from mydata_did.v1_0.models.data_agreement_qr_code_initiate_model import (
    DataAgreementQrCodeInitiateBody
)
from mydata_did.v1_0.messages.data_agreement_qr_code_initiate import (
    DataAgreementQrCodeInitiateMessage
)
from mydata_did.v1_0.messages.data_controller_details import (
    DataControllerDetailsMessage
)
from mydata_did.v1_0.messages.data_controller_details_response import (
    DataControllerDetailsResponseMessage
)
from mydata_did.v1_0.models.data_controller_model import (
    DataController
)
from mydata_did.v1_0.messages.existing_connections import ExistingConnectionsMessage
from mydata_did.v1_0.models.existing_connections_model import (
    ExistingConnectionsBody
)
from mydata_did.v1_0.messages.da_negotiation_receipt import (
    DataAgreementNegotiationReceiptMessage,
    DataAgreementNegotiationReceiptBody
)
from dexa_sdk.marketplace.records.marketplace_connection_record import MarketplaceConnectionRecord
from ..connections.records.existing_connections_record import (
    ExistingConnectionRecord
)
from ..agreements.da.v1_0.models.da_models import (
    DataAgreementModel,
    DA_DEFAULT_CONTEXT,
    DA_TYPE
)
from ..data_controller.records.controller_details_record import ControllerDetailsRecord
from ..agreements.da.v1_0.records.da_qrcode_record import DataAgreementQRCodeRecord
from ..agreements.da.v1_0.records.da_instance_record import DataAgreementInstanceRecord
from ..agreements.da.v1_0.records.da_template_record import DataAgreementTemplateRecord
from ..agreements.da.v1_0.records.personal_data_record import PersonalDataRecord
from ..agreements.da.v1_0.models.da_models import DataAgreementPersonalDataModel
from ..agreements.da.v1_0.models.da_instance_models import DataAgreementInstanceModel
from ..ledgers.indy.core import (
    create_cred_def_and_anchor_to_ledger,
    create_schema_def_and_anchor_to_ledger
)
from ..utils import (
    paginate,
    paginate_records,
    PaginationResult,
    drop_none_dict,
    bump_major_for_semver_string,
    fetch_org_details_from_intermediary,
    generate_firebase_dynamic_link
)
from ..did_mydata.core import DIDMyDataBuilder
from ..ledgers.ethereum.core import EthereumClient
from ..data_controller.records.connection_controller_details_record import (
    ConnectionControllerDetailsRecord
)


class V2ADAManagerError(BaseError):
    &#34;&#34;&#34;ADA manager error&#34;&#34;&#34;


class V2ADAManager:
    &#34;&#34;&#34;Manages ADA related functions (v2)
    &#34;&#34;&#34;

    def __init__(self, context: InjectionContext) -&gt; None:
        &#34;&#34;&#34;Initialise ADA manager

        Args:
            context (InjectionContext): _description_
        &#34;&#34;&#34;

        # Injection context
        self._context = context

        # Logger
        self._logger = logger

    @ property
    def context(self) -&gt; InjectionContext:
        &#34;&#34;&#34;Accessor for injection context

        Returns:
            InjectionContext: Injection context
        &#34;&#34;&#34;
        return self._context

    async def create_invitation(
        self,
        my_label: str = None,
        my_endpoint: str = None,
        their_role: str = None,
        auto_accept: bool = None,
        public: bool = False,
        multi_use: bool = False,
        alias: str = None,
    ) -&gt; typing.Tuple[ConnectionRecord, ConnectionInvitation]:
        &#34;&#34;&#34;Generate new connection invitation.&#34;&#34;&#34;

        if not my_label:
            my_label = self.context.settings.get(&#34;default_label&#34;)

        image_url = None

        # Fetch organisation details from intermediary.
        org_details = await fetch_org_details_from_intermediary(
            self.context
        )

        my_label = org_details[&#34;Name&#34;]
        image_url = org_details[&#34;LogoImageURL&#34;] + &#34;/web&#34;

        wallet: BaseWallet = await self.context.inject(BaseWallet)

        if public:
            if not self.context.settings.get(&#34;public_invites&#34;):
                raise ConnectionManagerError(
                    &#34;Public invitations are not enabled&#34;)

            public_did = await wallet.get_public_did()
            if not public_did:
                raise ConnectionManagerError(
                    &#34;Cannot create public invitation with no public DID&#34;
                )

            if multi_use:
                raise ConnectionManagerError(
                    &#34;Cannot use public and multi_use at the same time&#34;
                )

            # FIXME - allow ledger instance to format public DID with prefix?
            invitation = ConnectionInvitation(
                label=my_label, did=f&#34;did:sov:{public_did.did}&#34;, image_url=image_url
            )
            return None, invitation

        invitation_mode = ConnectionRecord.INVITATION_MODE_ONCE
        if multi_use:
            invitation_mode = ConnectionRecord.INVITATION_MODE_MULTI

        if not my_endpoint:
            my_endpoint = self.context.settings.get(&#34;default_endpoint&#34;)
        accept = (
            ConnectionRecord.ACCEPT_AUTO
            if (
                auto_accept
                or (
                    auto_accept is None
                    and self.context.settings.get(&#34;debug.auto_accept_requests&#34;)
                )
            )
            else ConnectionRecord.ACCEPT_MANUAL
        )

        # Create and store new invitation key
        connection_key = await wallet.create_signing_key()

        # Create connection record
        connection = ConnectionRecord(
            initiator=ConnectionRecord.INITIATOR_SELF,
            invitation_key=connection_key.verkey,
            their_role=their_role,
            state=ConnectionRecord.STATE_INVITATION,
            accept=accept,
            invitation_mode=invitation_mode,
            alias=alias,
        )

        await connection.save(self.context, reason=&#34;Created new invitation&#34;)

        # Create connection invitation message
        # Note: Need to split this into two stages to support inbound routing of invites
        # Would want to reuse create_did_document and convert the result
        invitation = ConnectionInvitation(
            label=my_label, recipient_keys=[
                connection_key.verkey], endpoint=my_endpoint, image_url=image_url
        )
        await connection.attach_invitation(self.context, invitation)

        return connection, invitation

    async def create_and_store_ledger_payloads_for_da_template(
            self,
            *,
            template_record: DataAgreementTemplateRecord,
            pd_records: typing.List[PersonalDataRecord] = None,
            schema_id: str = None
    ) -&gt; DataAgreementTemplateRecord:
        &#34;&#34;&#34;Create and store ledger payloads for a da template

        Args:
            template_record (DataAgreementTemplateRecord): Data agreement template record
            pd_records (typing.List[PersonalDataRecord]): Personal data records
            schema_id (str): Schema identifier if available

        Returns:
            DataAgreementTemplateRecord: Record with ledger payloads
        &#34;&#34;&#34;
        if template_record.method_of_use == DataAgreementTemplateRecord.METHOD_OF_USE_DATA_SOURCE:

            # Create schema if not existing
            if not schema_id:
                data_agreement = template_record.data_agreement
                # Schema name
                schema_name = data_agreement.get(&#34;purpose&#34;)
                # Schema version
                schema_version = data_agreement.get(&#34;version&#34;)
                # Schema attributes
                attributes = [
                    personal_data.attribute_name
                    for personal_data in pd_records
                ]
                # Creata schema and anchor to ledger
                (schema_id, schema_def) = await create_schema_def_and_anchor_to_ledger(
                    context=self.context,
                    schema_name=schema_name,
                    schema_version=schema_version,
                    attributes=attributes
                )

            # Create credential definition and anchor to ledger

            (cred_def_id, cred_def, novel) = await create_cred_def_and_anchor_to_ledger(
                context=self.context,
                schema_id=schema_id
            )

            template_record.cred_def_id = cred_def_id
            template_record.schema_id = schema_id
            await template_record.save(self.context)

        else:
            data_agreement = template_record.data_agreement

            # Usage purpose
            usage_purpose = data_agreement.get(&#34;purpose&#34;)

            # Usage purpose description
            usage_purpose_description = data_agreement.get(&#34;purposeDescription&#34;)

            # Data agreement template version
            da_template_version = data_agreement.get(&#34;version&#34;)

            # Create presentation request
            presentation_request = self.construct_presentation_request(
                usage_purpose=usage_purpose,
                usage_purpose_description=usage_purpose_description,
                da_template_version=da_template_version,
                personal_data=pd_records
            )

            template_record.presentation_request = presentation_request
            await template_record.save(self.context)

        return template_record

    def construct_presentation_request(
            self,
            *,
            usage_purpose: str,
            usage_purpose_description: str,
            da_template_version: str,
            personal_data: typing.List[PersonalDataRecord]
    ) -&gt; dict:
        &#34;&#34;&#34;
        Construct presentation request

        Args:
            usage_purpose: Usage purpose.
            usage_purpose_description: Usage purpose description.
            da_template_version: Data agreement template version.
            personal_data: List of personal data.

        Returns:
            :rtype: dict: Proof request

        &#34;&#34;&#34;

        presentation_request_dict: dict = {
            &#34;name&#34;: usage_purpose,
            &#34;comment&#34;: usage_purpose_description,
            &#34;version&#34;: da_template_version,
            &#34;requested_attributes&#34;: {},
            &#34;requested_predicates&#34;: {}
        }

        index = 1
        requested_attributes = {}

        for pd in personal_data:

            requested_attributes[&#34;additionalProp&#34; + str(index)] = {
                &#34;name&#34;: pd.attribute_name,
                &#34;restrictions&#34;: pd.restrictions if pd.restrictions else []
            }
            if pd.restrictions:
                restrictions = [
                    {
                        &#34;schema_id&#34;: restriction.get(&#34;schemaId&#34;),
                        &#34;cred_def_id&#34;: restriction.get(&#34;credDefId&#34;)
                    }
                    for restriction in pd.restrictions
                ]
                requested_attributes[&#34;additionalProp&#34; +
                                     str(index)].update({&#34;restrictions&#34;: restrictions})
            else:
                requested_attributes[&#34;additionalProp&#34; + str(index)].update({})
            index += 1

        presentation_request_dict[&#34;requested_attributes&#34;] = requested_attributes

        return presentation_request_dict

    async def create_and_store_da_template_in_wallet(
            self,
            data_agreement: dict,
            *,
            publish_flag: bool = True,
            schema_id: str = None
    ) -&gt; DataAgreementTemplateRecord:
        &#34;&#34;&#34;Create and store data agreement template in wallet

        Args:
            data_agreement (dict): Data agreement
            publish_flag (bool): Publish flag
            schema_id (str): Schema identifier
        &#34;&#34;&#34;

        # Temp hack
        template_version = &#34;1.0.0&#34;
        template_id = str(uuid.uuid4())
        data_agreement.update({&#34;@context&#34;: DA_DEFAULT_CONTEXT})
        data_agreement.update({&#34;@id&#34;: template_id})
        data_agreement.update({&#34;@type&#34;: DA_TYPE})
        data_agreement.update({&#34;version&#34;: template_version})

        try:
            # Validate the data agreement.
            data_agreement: DataAgreementModel = DataAgreementModel.deserialize(data_agreement)
        except ValidationError as err:
            raise V2ADAManagerError(
                f&#34;Failed to create data agreement; Reason: {err}&#34;
            )

        # Create personal data records
        pds = data_agreement.personal_data
        pd_records = []
        pd_models_with_id = []
        for pd in pds:
            pd_record: PersonalDataRecord = \
                await PersonalDataRecord.build_and_save_record_from_pd_model(
                    self.context,
                    template_id,
                    template_version,
                    pd
                )
            pd_records.append(pd_record)
            pd_models_with_id.append(pd_record.convert_record_to_pd_model())

        # Update the personal data with attribute identifiers to the agreement
        data_agreement.personal_data = pd_models_with_id

        # Create template record
        record = DataAgreementTemplateRecord(
            template_id=template_id,
            template_version=template_version,
            state=DataAgreementTemplateRecord.STATE_DEFINITION,
            method_of_use=data_agreement.method_of_use,
            data_agreement=data_agreement.serialize(),
            publish_flag=bool_to_str(publish_flag),
            schema_id=schema_id,
            existing_schema_flag=bool_to_str(True) if schema_id else bool_to_str(False),
            third_party_data_sharing=bool_to_str(
                data_agreement.data_policy.third_party_data_sharing)
        )

        await record.save(self.context)

        if publish_flag:
            # Create ledger payloads
            record = await self.create_and_store_ledger_payloads_for_da_template(
                template_record=record,
                pd_records=pd_records,
                schema_id=schema_id
            )

        return record

    async def query_da_templates_in_wallet(
            self,
            *,
            template_id: str = None,
            delete_flag: str = &#34;false&#34;,
            method_of_use: str = None,
            publish_flag: str = &#34;true&#34;,
            template_version: str = None,
            latest_version_flag: str = &#34;true&#34;,
            third_party_data_sharing: str = &#34;false&#34;,
            page: int = 1,
            page_size: int = 10,
    ) -&gt; PaginationResult:
        &#34;&#34;&#34;Query DA templates in wallet

        Args:
            template_id (str, optional): Template identifier. Defaults to None.
            delete_flag (str, optional): Delete flag. Defaults to false.
            method_of_use (str, optional): Method of use. Defaults to None.
            publish_flag (str, optional): Publish flag. Defaults to true.
            latest_version_flag (str, optional): Latest version flag. Defaults to true.
            template_version (str, optional): Template version. Defaults to None.
            third_party_data_sharing (str, optional): Third party data sharing.
                Defaults to false.
            page (int, optional): Page. Defaults to 1.

        Returns:
            PaginationResult: Pagination results.
        &#34;&#34;&#34;

        # Query by version is only possible if the template id is provided
        if template_version:
            assert template_id, &#34;Template identifier is required to query by version&#34;

        # Tag filter
        tag_filter = {
            &#34;delete_flag&#34;: delete_flag,
            &#34;publish_flag&#34;: publish_flag,
            &#34;method_of_use&#34;: method_of_use,
            &#34;template_id&#34;: template_id,
            &#34;template_version&#34;: template_version,
            &#34;latest_version_flag&#34;: latest_version_flag,
            &#34;third_party_data_sharing&#34;: third_party_data_sharing
        }

        tag_filter = drop_none_dict(tag_filter)

        records = await DataAgreementTemplateRecord.query(
            context=self.context,
            tag_filter=tag_filter
        )

        records = sorted(records, key=lambda k: k.created_at, reverse=True)

        paginate_result = paginate_records(records, page, page_size)

        return paginate_result

    async def publish_da_template_in_wallet(self,
                                            template_id: str) -&gt; DataAgreementTemplateRecord:
        &#34;&#34;&#34;Publish data agreement template.

        Args:
            template_id (str): Template identifier

        Returns:
            DataAgreementTemplateRecord: Template record.
        &#34;&#34;&#34;

        tag_filter = {
            &#34;delete_flag&#34;: bool_to_str(False),
            &#34;publish_flag&#34;: bool_to_str(False),
            &#34;latest_version_flag&#34;: bool_to_str(True),
            &#34;template_id&#34;: template_id
        }

        records = await DataAgreementTemplateRecord.query(
            context=self.context,
            tag_filter=tag_filter
        )

        assert records, &#34;Data agreement template not found.&#34;

        record: DataAgreementTemplateRecord = records[0]

        await record.publish_template(self.context)

        pd_records = await record.fetch_personal_data_records(self.context)

        # Create ledger payloads
        record = await self.create_and_store_ledger_payloads_for_da_template(
            template_record=record,
            pd_records=pd_records,
            schema_id=record.schema_id
        )

        return record

    async def update_and_store_da_template_in_wallet(
            self,
            template_id: str,
            data_agreement: dict,
            *,
            publish_flag: bool = True,
            schema_id: str = None
    ) -&gt; DataAgreementTemplateRecord:
        &#34;&#34;&#34;Update and store data agreement template in wallet.

        Args:
            template_id (str): Template identifier
            data_agreement (dict): Data agreement
            publish_flag (bool): Publish flag
            schema_id (str): Schema identifier

        Returns:
            DataAgreementTemplateRecord: Updated record.
        &#34;&#34;&#34;

        # Tag filter
        tag_filter = {
            &#34;delete_flag&#34;: bool_to_str(False),
            &#34;template_id&#34;: template_id,
            &#34;latest_version_flag&#34;: bool_to_str(True)
        }

        # Fetch data agreement record
        record: DataAgreementTemplateRecord = \
            await DataAgreementTemplateRecord.retrieve_by_tag_filter(self.context, tag_filter)

        # Validate the data agreement.
        previous_da: DataAgreementModel = DataAgreementModel.deserialize(record.data_agreement)

        assert previous_da.method_of_use == data_agreement.get(
            &#34;methodOfUse&#34;), &#34;Method of use cannot be updated.&#34;

        assert previous_da.data_policy.third_party_data_sharing \
            == data_agreement.get(&#34;dataPolicy&#34;).get(&#34;thirdPartyDataSharing&#34;), \
            &#34;Third party data sharing cannot be updated.&#34;

        # Copy the id, version from previous da to new da
        template_version = bump_major_for_semver_string(previous_da.version)
        template_id = previous_da.id
        data_agreement.update({&#34;@context&#34;: DA_DEFAULT_CONTEXT})
        data_agreement.update({&#34;@type&#34;: DA_TYPE})
        data_agreement.update({&#34;@id&#34;: template_id})
        data_agreement.update({&#34;version&#34;: template_version})

        updated_da: DataAgreementModel = DataAgreementModel.deserialize(data_agreement)

        # Create personal data records
        pds = updated_da.personal_data
        pd_records = []
        pd_models_with_id = []
        for pd in pds:
            pd_record: PersonalDataRecord = \
                await PersonalDataRecord.build_and_save_record_from_pd_model(
                    self.context,
                    template_id,
                    template_version,
                    pd
                )
            pd_records.append(pd_record)
            pd_models_with_id.append(pd_record.convert_record_to_pd_model())

        # Update the personal data with attribute identifiers to the agreement
        updated_da.personal_data = pd_models_with_id

        record.data_agreement = updated_da.serialize()
        record.publish_flag = bool_to_str(publish_flag)
        record.schema_id = schema_id
        record.existing_schema_flag = bool_to_str(True) if schema_id else bool_to_str(False)
        record.template_version = template_version

        await record.upgrade(self.context)

        if publish_flag:
            # Create ledger payloads
            record = await self.create_and_store_ledger_payloads_for_da_template(
                template_record=record,
                pd_records=pd_records,
                schema_id=schema_id
            )

        return record

    async def delete_da_template_in_wallet(self, template_id: str) -&gt; str:
        &#34;&#34;&#34;Deactivate DA template in wallet.

        This is not a normal delete operation of a specific version of template. Instead it
        marks the template with latest version flag as deleted i.e. Any version under this
        template is no longer active.

        Args:
            template_id (str): Template identifier
            template_version (str): Template version

        Returns:
            record_id: Record identifier for the deleted template.
        &#34;&#34;&#34;
        # Query for the data agreement by id
        data_agreement_records: DataAgreementTemplateRecord = \
            await DataAgreementTemplateRecord.non_deleted_template_by_id(
                self.context,
                template_id
            )

        assert data_agreement_records, &#34;Data agreement template not found.&#34;
        data_agreement_record = data_agreement_records[0]

        # Mark the data agreement as deleted and save.
        return await data_agreement_record.delete_template(self.context)

    async def query_pd_of_da_template_from_wallet(self,
                                                  template_id: str = None,
                                                  method_of_use: str = None,
                                                  third_party_data_sharing: str = None,
                                                  page: int = 1,
                                                  page_size: int = 10,
                                                  ) -&gt; PaginationResult:
        &#34;&#34;&#34;Query personal data for DA template.

        Args:
            template_id (str): Template identifier
            page (int, optional): Page number. Defaults to 1.
            page_size (int, optional): Page size. Defaults to 10.

        Returns:
            PaginationResult: Pagination results
        &#34;&#34;&#34;

        # Tag filter
        tag_filter = {
            &#34;delete_flag&#34;: bool_to_str(False),
            &#34;method_of_use&#34;: method_of_use,
            &#34;template_id&#34;: template_id,
            &#34;latest_version_flag&#34;: bool_to_str(True),
            &#34;third_party_data_sharing&#34;: third_party_data_sharing
        }

        tag_filter = drop_none_dict(tag_filter)

        records = await DataAgreementTemplateRecord.query(
            context=self.context,
            tag_filter=tag_filter
        )

        records = sorted(records, key=lambda k: k.created_at, reverse=True)

        # Fetch personal data records
        pd_records = []
        for record in records:
            pd_records.extend(await record.fetch_personal_data_records(self.context))

        paginate_result = paginate_records(pd_records, page, page_size)

        return paginate_result

    async def update_personal_data_description(self,
                                               attribute_id: str,
                                               desc: str) -&gt; PersonalDataRecord:
        &#34;&#34;&#34;Update personal data description

        Args:
            attribute_id (str): Attribute id
            desc (str): Description

        Returns:
            PersonalDataRecord: Personal data record
        &#34;&#34;&#34;

        # Fetch personal data record by id
        pd_record: PersonalDataRecord = await PersonalDataRecord.retrieve_by_id(
            self.context,
            attribute_id
        )

        # Fetch the associated data agreement record
        da_template_record: DataAgreementTemplateRecord = \
            await DataAgreementTemplateRecord.latest_template_by_id(
                self.context,
                pd_record.data_agreement_template_id
            )

        assert da_template_record, &#34;Matching data agreement template not found.&#34;
        assert da_template_record.template_version == \
            pd_record.data_agreement_template_version, \
            &#34;Matching data agreement template with same version not found.&#34;

        # Update the personal data record.
        pd_record.attribute_description = desc
        await pd_record.save(self.context)

        pd_model: DataAgreementPersonalDataModel = pd_record.convert_record_to_pd_model()

        # Update the data agreement record with new personal data.
        da: DataAgreementModel = DataAgreementModel.deserialize(da_template_record.data_agreement)
        # Iterate through the existing personal data in data agreements
        # And update the personal data matching the attribute id
        da_pds = []
        for da_pd in da.personal_data:
            if da_pd.attribute_id != pd_model.attribute_id:
                da_pds.append(da_pd)
        da_pds.append(pd_model)
        da.personal_data = da_pds

        da_template_record.data_agreement = da.serialize()
        await da_template_record.save(self.context)

        return pd_record

    async def delete_personal_data(self, attribute_id: str) -&gt; None:
        &#34;&#34;&#34;Delete personal data record.

        On deleting personal data record, the associated data agreement template is
        updated. If the personal data record deleted, is the last one in the template,
        proceed to delete the template record.

        Args:
            attribute_id (str): _description_
        &#34;&#34;&#34;

        # Fetch personal data record by id
        pd_record: PersonalDataRecord = await PersonalDataRecord.retrieve_by_id(
            self.context,
            attribute_id
        )

        # Fetch the associated data agreement record
        da_template_record: DataAgreementTemplateRecord = \
            await DataAgreementTemplateRecord.latest_template_by_id(
                self.context,
                pd_record.data_agreement_template_id
            )

        assert da_template_record, &#34;Matching data agreement template not found.&#34;
        assert da_template_record.template_version == \
            pd_record.data_agreement_template_version, \
            &#34;Matching data agreement template with same version not found.&#34;

        da: DataAgreementModel = DataAgreementModel.deserialize(da_template_record.data_agreement)

        # Iterate through the existing personal data in data agreements
        # And remove the deleted personal data.
        da_pds = []
        for da_pd in da.personal_data:
            if da_pd.attribute_id != pd_record.attribute_id:
                da_pd.attribute_id = None
                da_pds.append(da_pd)

        da.personal_data = da_pds

        if len(da_pds) == 0:
            await da_template_record.delete_template(self.context)
        else:
            # Update template record with new agreement.
            await self.update_and_store_da_template_in_wallet(
                pd_record.data_agreement_template_id,
                da.serialize(),
                publish_flag=str_to_bool(da_template_record.publish_flag)
            )

    async def build_data_agreement_offer_for_credential_exchange(
        self,
        template_id: str,
        connection_record: ConnectionRecord,
        cred_ex_record: V10CredentialExchange,
    ) -&gt; DataAgreementNegotiationOfferMessage:
        &#34;&#34;&#34;Build data agreement offer for credential exchange.

        Args:
            context (InjectionContext): Injection context to be used.
            template_id (str): Data agreement template identifier.
            connection_record (ConnectionRecord): Connection record.
            cred_ex_record (V10CredentialExchange): Credential exchange record.

        Returns:
            DataAgreementNegotiationOfferMessage: Offer message.
        &#34;&#34;&#34;

        # Build instance record
        (da_instance_record, da_instance_model) = \
            await DataAgreementInstanceRecord.build_instance_from_template(
            self.context,
            template_id,
            connection_record,
            cred_ex_record.credential_exchange_id
        )

        # Build negotiation offer agent message
        agent_message = DataAgreementNegotiationOfferMessage(body=da_instance_model)

        return agent_message

    async def build_data_agreement_offer_for_presentation_exchange(
        self,
        template_id: str,
        connection_record: ConnectionRecord,
        pres_ex_record: V10PresentationExchange,
    ) -&gt; DataAgreementNegotiationOfferMessage:
        &#34;&#34;&#34;Build data agreement offer for presentaton exchange.

        Args:
            context (InjectionContext): Injection context to be used.
            template_id (str): Data agreement template identifier.
            connection_record (ConnectionRecord): Connection record.
            pres_ex_record (V10PresentationExchange): Presentation exchange record.

        Returns:
            DataAgreementNegotiationOfferMessage: Offer message.
        &#34;&#34;&#34;

        # Build instance record
        (da_instance_record, da_instance_model) = \
            await DataAgreementInstanceRecord.build_instance_from_template(
            self.context,
            template_id,
            connection_record,
            pres_ex_record.presentation_exchange_id
        )

        # Build negotiation offer agent message
        agent_message = DataAgreementNegotiationOfferMessage(body=da_instance_model)

        return agent_message

    async def process_decorator_with_da_offer_message(
        self,
        decorator_set: DecoratorSet,
        data_ex_record: typing.Union[V10CredentialExchange, V10PresentationExchange],
        connection_record: ConnectionRecord
    ) -&gt; DataAgreementInstanceRecord:
        &#34;&#34;&#34;Process data agreement context decorator with DA offer message

        Args:
            decorator_set (DecoratorSet): Decorator set
            cred_ex_record (V10CredentialExchange): Credential exchange record
            connection_record (ConnectionRecord): Connection record

        Returns:
            DataAgreementInstanceRecord: Data agreement instance record.
        &#34;&#34;&#34;

        # Check if data agreement context decorator is present
        if &#34;data-agreement-context&#34; not in decorator_set.keys():
            self._logger.info(
                &#34;Data agreement context decorator is not present in the incoming message.&#34;)
            return None

        # Deserialize data agreement context decorator
        da_decorator_dict = decorator_set[&#34;data-agreement-context&#34;]
        da_decorator_model: DataAgreementContextDecorator = \
            DataAgreementContextDecorator.deserialize(da_decorator_dict)

        assert da_decorator_model.message_type == &#34;protocol&#34;, \
            &#34;DA context message type must be &#39;protocol&#39;.&#34;

        message_type = da_decorator_model.message.get(&#34;@type&#34;)
        assert DATA_AGREEMENT_NEGOTIATION_OFFER in message_type, \
            f&#34;DA context protocol message type must be &#39;{DATA_AGREEMENT_NEGOTIATION_OFFER}&#39;&#34;

        da_offer_message: DataAgreementNegotiationOfferMessage = \
            DataAgreementNegotiationOfferMessage.deserialize(da_decorator_model.message)

        # Build and save data agreement instance record.
        if data_ex_record.__class__.__name__ == V10CredentialExchange.__name__:
            return await DataAgreementInstanceRecord.build_instance_from_da_offer(
                self.context,
                da_offer_message,
                connection_record,
                data_ex_record.credential_exchange_id
            )
        else:
            return await DataAgreementInstanceRecord.build_instance_from_da_offer(
                self.context,
                da_offer_message,
                connection_record,
                data_ex_record.presentation_exchange_id
            )

    async def process_decorator_with_da_accept_message(
        self,
        decorator_set: DecoratorSet,
        data_ex_record: typing.Union[V10CredentialExchange, V10PresentationExchange],
        connection_record: ConnectionRecord
    ) -&gt; DataAgreementInstanceRecord:
        &#34;&#34;&#34;Process data agreement context decorator with DA accept message

        Args:
            decorator_set (DecoratorSet): Decorator set
            data_ex_record (typing.Union[V10CredentialExchange, V10PresentationExchange]):
                Data exchange record.
            connection_record (ConnectionRecord): Connection record

        Returns:
            DataAgreementInstanceRecord: Data agreement instance record.
        &#34;&#34;&#34;

        # Check if data agreement context decorator is present
        if &#34;data-agreement-context&#34; not in decorator_set.keys():
            self._logger.info(
                &#34;Data agreement context decorator is not present in the incoming message.&#34;)
            return None

        # Deserialize data agreement context decorator
        da_decorator_dict = decorator_set[&#34;data-agreement-context&#34;]
        da_decorator_model: DataAgreementContextDecorator = \
            DataAgreementContextDecorator.deserialize(da_decorator_dict)

        assert da_decorator_model.message_type == &#34;protocol&#34;, \
            &#34;DA context message type must be &#39;protocol&#39;.&#34;

        message_type = da_decorator_model.message.get(&#34;@type&#34;)
        assert DATA_AGREEMENT_NEGOTIATION_ACCEPT in message_type, \
            f&#34;DA context protocol message type must be &#39;{DATA_AGREEMENT_NEGOTIATION_ACCEPT}&#39;&#34;

        da_accept_message: DataAgreementNegotiationAcceptMessage = \
            DataAgreementNegotiationAcceptMessage.deserialize(da_decorator_model.message)

        # Build and save data agreement instance record.
        if data_ex_record.__class__.__name__ == V10CredentialExchange.__name__:
            # Build and save data agreement instance record.
            instance_record = await DataAgreementInstanceRecord.update_instance_from_da_accept(
                self.context,
                da_accept_message,
                data_ex_record.credential_exchange_id
            )
        else:
            # Build and save data agreement instance record.
            instance_record = await DataAgreementInstanceRecord.update_instance_from_da_accept(
                self.context,
                da_accept_message,
                data_ex_record.presentation_exchange_id
            )

        # Anchor da to blockchain.
        await self.anchor_da_instance_to_blockchain_async_task(instance_record.instance_id)

        return instance_record

    async def build_data_agreement_negotiation_accept_by_instance_id(
        self,
        instance_id: str,
        connection_record: ConnectionRecord
    ) -&gt; DataAgreementNegotiationAcceptMessage:
        # Counter sign da
        (da_instance_record, da_instance_model) = \
            await DataAgreementInstanceRecord.counter_sign_instance(
                self.context,
                instance_id,
                connection_record,
        )

        # Build negotiation accept agent message
        agent_message = DataAgreementNegotiationAcceptMessage(body=da_instance_model)

        return agent_message

    async def build_data_agreement_accept_for_data_ex_record(
        self,
        connection_record: ConnectionRecord,
        data_ex_record: typing.Union[V10CredentialExchange, V10PresentationExchange],
    ) -&gt; DataAgreementNegotiationAcceptMessage:
        &#34;&#34;&#34;Build data agreement accept message for credential exchange.

        Args:
            context (InjectionContext): Injection context to be used.
            template_id (str): Data agreement template identifier.
            connection_record (ConnectionRecord): Connection record.
            data_ex_record (typing.Union[V10CredentialExchange, V10PresentationExchange]):
                Data exchange record.

        Returns:
            DataAgreementNegotiationAcceptMessage: Accept message.
        &#34;&#34;&#34;
        if data_ex_record.__class__.__name__ == V10CredentialExchange.__name__:
            # Fetch data agreement instance matching credential exchange record.
            instance_record = await DataAgreementInstanceRecord.fetch_by_data_ex_id(
                self.context,
                data_ex_record.credential_exchange_id
            )
        else:
            # Fetch data agreement instance matching credential exchange record.
            instance_record = await DataAgreementInstanceRecord.fetch_by_data_ex_id(
                self.context,
                data_ex_record.presentation_exchange_id
            )

        # Build instance record
        (da_instance_record, da_instance_model) = \
            await DataAgreementInstanceRecord.counter_sign_instance(
            self.context,
            instance_record.instance_id,
            connection_record
        )

        # Build negotiation accept agent message
        agent_message = DataAgreementNegotiationAcceptMessage(body=da_instance_model)

        return agent_message

    async def query_data_agreement_instances(
        self,
        instance_id: str,
        template_id: str,
        template_version: str,
        method_of_use: str,
        third_party_data_sharing: str,
        data_ex_id: str,
        data_subject_did: str,
        page: int = 1,
        page_size: int = 10
    ) -&gt; PaginationResult:
        &#34;&#34;&#34;Query data agreement instances

        Args:
            instance_id (str): Instance identifier
            template_id (str): Template identifier
            template_version (str): Template version
            method_of_use (str): Method of use
            third_party_data_sharing (str): Third party data sharing
            data_ex_id (str): Data exchange id
            data_subject_did (str): Data subject did
            page (int, optional): Page. Defaults to 1.
            page_size (int, optional): Page size. Defaults to 10.

        Returns:
            PaginationResult: Pagination result
        &#34;&#34;&#34;
        # Query by version is only possible if the template id is provided
        if template_version:
            assert template_id, &#34;Template identifier is required to query by version&#34;

        # Tag filter
        tag_filter = {
            &#34;instance_id&#34;: instance_id,
            &#34;template_id&#34;: template_id,
            &#34;template_version&#34;: template_version,
            &#34;method_of_use&#34;: method_of_use,
            &#34;third_party_data_sharing&#34;: third_party_data_sharing,
            &#34;data_ex_id&#34;: data_ex_id,
            &#34;data_subject_did&#34;: data_subject_did
        }

        tag_filter = drop_none_dict(tag_filter)

        records = await DataAgreementInstanceRecord.query(
            context=self.context,
            tag_filter=tag_filter
        )

        records = sorted(records, key=lambda k: k.created_at, reverse=True)

        paginate_result = paginate_records(records, page, page_size)

        return paginate_result

    async def delete_da_instance_by_data_ex_id(
        self,
        cred_ex_id: str
    ) -&gt; None:
        &#34;&#34;&#34;Delete da instance by cred ex id.

        Args:
            cred_ex_id (str): Credential exchange identifier.
        &#34;&#34;&#34;

        # Data agreement instance
        instance = await DataAgreementInstanceRecord.fetch_by_data_ex_id(
            self.context,
            cred_ex_id
        )

        await instance.delete_record(self.context)

    async def anchor_da_instance_to_blockchain_async_task_callback(
        self, *args, **kwargs
    ):
        &#34;&#34;&#34;Anchor DA instance to blockchain async task callback function
        &#34;&#34;&#34;

        # Obtain the completed task.
        completed_task: CompletedTask = args[0]

        # Obtain the results from the task.
        (instance_id, mydata_did, tx_hash, tx_receipt) = completed_task.task.result()

        tag_filter = {
            &#34;instance_id&#34;: instance_id
        }

        # Fetch data agreement instance record.
        da_instance_records = await DataAgreementInstanceRecord.query(
            self.context,
            tag_filter,
        )

        assert da_instance_records, &#34;Data agreement instance not found.&#34;

        da_instance_record: DataAgreementInstanceRecord = da_instance_records[0]

        transaction_receipt = json.loads(to_json(tx_receipt))
        transaction_hash = transaction_receipt.get(&#34;transactionHash&#34;)

        # Update the data agreement with blockchain metadata.
        da_instance_record.blink = f&#34;blink:ethereum:rinkeby:{transaction_hash}&#34;
        da_instance_record.mydata_did = mydata_did
        da_instance_record.blockchain_receipt = transaction_receipt

        await da_instance_record.save(self.context)

        # Send receipt.
        message = DataAgreementNegotiationReceiptMessage(
            body=DataAgreementNegotiationReceiptBody(
                instance_id=da_instance_record.instance_id,
                blockchain_receipt=transaction_receipt,
                blink=f&#34;blink:ethereum:rinkeby:{transaction_hash}&#34;,
                mydata_did=mydata_did
            )
        )

        # Find the connection record.
        data_subject_did = da_instance_record.data_subject_did.replace(&#34;did:sov:&#34;, &#34;&#34;)
        connection_record: ConnectionRecord = await ConnectionRecord.retrieve_by_did(
            self.context,
            their_did=data_subject_did,
        )

        self.send_reply_message(
            message,
            connection_record.connection_id
        )

    async def anchor_da_instance_to_blockchain_async_task(
        self,
        instance_id: str
    ):
        &#34;&#34;&#34;Async task to anchor da instance to blockchain.

        Args:
            instance_id (str): Instance id
        &#34;&#34;&#34;
        pending_task = await self.add_task(
            self.context,
            self.anchor_da_instance_to_blockchain(instance_id),
            self.anchor_da_instance_to_blockchain_async_task_callback
        )
        self._logger.info(pending_task)

    async def anchor_da_instance_to_blockchain(
        self,
        instance_id: str
    ) -&gt; None:
        &#34;&#34;&#34;Anchor da instance to blockchain.

        Args:
            instance_id (str): Instance id
        &#34;&#34;&#34;

        eth_client: EthereumClient = await self.context.inject(EthereumClient)

        tag_filter = {
            &#34;instance_id&#34;: instance_id
        }

        # Fetch data agreement instance record.
        da_instance_records = await DataAgreementInstanceRecord.query(
            self.context,
            tag_filter,
        )

        assert da_instance_records, &#34;Data agreement instance not found.&#34;

        da_instance_record: DataAgreementInstanceRecord = da_instance_records[0]
        da_model: DataAgreementInstanceModel = \
            DataAgreementInstanceModel.deserialize(da_instance_record.data_agreement)

        did_mydata_builder = DIDMyDataBuilder(
            artefact=da_model
        )

        (tx_hash, tx_receipt) = await eth_client.emit_da_did(did_mydata_builder.mydata_did)

        return (da_instance_record.instance_id, did_mydata_builder.mydata_did, tx_hash, tx_receipt)

    async def create_data_agreement_qr_code(
        self,
        template_id: str,
        multi_use_flag: bool
    ) -&gt; dict:
        &#34;&#34;&#34;Create data agreement qr code

        Args:
            template_id (str): Template identifier
            multi_use_flag (bool): Multi use flag

        Returns:
            dict: Qr code.
        &#34;&#34;&#34;

        qr_record = DataAgreementQRCodeRecord(
            template_id=template_id,
            multi_use_flag=bool_to_str(multi_use_flag)
        )
        await qr_record.save(self.context)

        (connection, invitation) = await self.create_invitation(
            auto_accept=True,
            public=False,
            multi_use=multi_use_flag,
            alias=f&#34;DA_{template_id}_QR_{qr_record._id}&#34;
        )

        qr_record.connection_id = connection.connection_id
        await qr_record.save(self.context)

        res = {
            &#34;qr_id&#34;: qr_record._id,
            &#34;invitation&#34;: invitation.serialize()
        }

        res_base64 = base64.b64encode(json.dumps(res).encode()).decode()
        payload = self.context.settings.get(&#34;default_endpoint&#34;) + &#34;?qt=2&amp;qp=&#34; + res_base64

        firebase_dynamic_link = await generate_firebase_dynamic_link(self.context, payload)
        qr_record.dynamic_link = firebase_dynamic_link
        await qr_record.save(self.context)

        res.update({&#34;dynamic_link&#34;: firebase_dynamic_link})

        return res

    async def create_connection_qr_code(
        self,
        connection_id: str
    ) -&gt; dict:
        &#34;&#34;&#34;Create connection QR code.

        Args:
            connection_id (str): Connection identifier.

        Returns:
            dict: Dict with dynamic link.
        &#34;&#34;&#34;

        # Connection record.
        connection_record: ConnectionRecord = await ConnectionRecord.retrieve_by_id(
            self.context,
            connection_id
        )

        # Connection invitation
        connection_invitation: ConnectionInvitation = await connection_record.retrieve_invitation(
            self.context
        )

        # Generate firebase dynamic link.
        payload = connection_invitation.to_url()
        firebase_dynamic_link = await generate_firebase_dynamic_link(self.context, payload)

        res = {&#34;dynamic_link&#34;: firebase_dynamic_link}

        return res

    async def query_data_agreement_qr_codes(
        self,
        template_id: str,
    ) -&gt; PaginationResult:
        &#34;&#34;&#34;Query data agreement qr codes

        Returns:
            PaginationResult: List of qr code records.
        &#34;&#34;&#34;

        records = await DataAgreementQRCodeRecord.query(self.context, {&#34;template_id&#34;: template_id})
        pagination_result = paginate_records(records, page=1, page_size=1000000)
        return pagination_result

    async def send_reply_message(self, message: AgentMessage, connection_id: str = None) -&gt; None:
        &#34;&#34;&#34;Send reply message to remote agent.

        Args:
            message (AgentMessage): Agent message.
            connection_id (str): Connection identifier
        &#34;&#34;&#34;
        # Responder instance
        responder: DispatcherResponder = await self.context.inject(BaseResponder, required=False)

        if responder:
            await responder.send_reply(message, connection_id=connection_id)

    async def send_problem_report_message(self, explain: str, connection_id: str) -&gt; None:
        &#34;&#34;&#34;Send problem report message as reply.

        Args:
            explain (str): Explaination.
            connection_id (str): Connection id.
        &#34;&#34;&#34;

        # Responder instance
        responder: DispatcherResponder = await self.context.inject(BaseResponder, required=False)

        problem_report = ProblemReport(explain_ltxt=explain)

        if responder:
            await responder.send_reply(problem_report, connection_id=connection_id)

    async def delete_data_agreement_qr_code(
        self,
        template_id: str,
        qr_id: str
    ) -&gt; None:
        &#34;&#34;&#34;Delete data agreement qr code.&#34;&#34;&#34;
        record = await DataAgreementQRCodeRecord.retrieve_by_id(self.context, qr_id)
        assert record.template_id == template_id, &#34;Data agreement not found.&#34;
        await record.delete_record(self.context)

    async def process_data_agreement_qr_code_initiate_message(
        self,
        message: DataAgreementQrCodeInitiateMessage,
        receipt: MessageReceipt
    ):
        &#34;&#34;&#34;Process data QR code initiate message.

        Args:
            message (DataAgreementQrCodeInitiateMessage): Data agreement QR code initiate message.
            receipt (MessageReceipt): Message receipt.
        &#34;&#34;&#34;
        qr_id = message.body.qr_id
        connection_id = self.context.connection_record.connection_id

        connection_record = await ConnectionRecord.retrieve_by_id(self.context, connection_id)

        # Fetch the qr code record.
        record: DataAgreementQRCodeRecord = \
            await DataAgreementQRCodeRecord.retrieve_by_id(
                self.context,
                qr_id
            )

        if record._multi_use_flag:
            record._scanned_flag = True
            await record.save(self.context)
        else:
            if record._scanned_flag:
                explain = &#34;Qr code cannot be scanned twice&#34;
                await self.send_problem_report_message(explain, connection_id)
                raise Exception(explain)

        # Fetch data agreement template record.
        template_record: DataAgreementTemplateRecord = \
            await DataAgreementTemplateRecord.latest_template_by_id(
                self.context,
                record.template_id
            )

        # Construct presentation request
        preset_presentation_request = template_record.presentation_request
        comment = preset_presentation_request.pop(&#34;comment&#34;)
        if not preset_presentation_request.get(&#34;nonce&#34;):
            preset_presentation_request[&#34;nonce&#34;] = await generate_pr_nonce()

        presentation_request = PresentationRequest(
            comment=comment,
            request_presentations_attach=[
                AttachDecorator.from_indy_dict(
                    indy_dict=preset_presentation_request,
                    ident=ATTACH_DECO_IDS[PRESENTATION_REQUEST],
                )
            ],
        )

        # Construct presentation exchange record
        presentation_manager = PresentationManager(self.context)
        (pres_ex_record) = await presentation_manager.create_exchange_for_request(
            connection_id=self.context.connection_record.connection_id,
            presentation_request_message=presentation_request,
        )

        # Update qr code with record id.
        record.data_ex_id = pres_ex_record.presentation_exchange_id
        await record.save(self.context)

        offer_message = await self.build_data_agreement_offer_for_presentation_exchange(
            template_record.template_id,
            connection_record,
            pres_ex_record
        )

        # Add data agreement context decorator
        presentation_request._decorators[&#34;data-agreement-context&#34;] = DataAgreementContextDecorator(
            message_type=&#34;protocol&#34;,
            message=offer_message.serialize()
        )

        pres_ex_record.presentation_request_dict = presentation_request.serialize()
        pres_ex_record.template_id = template_record.template_id
        await pres_ex_record.save(self.context)

        await self.send_reply_message(presentation_request, connection_id)

    async def send_qr_code_initiate_message(
        self,
        qr_id,
        connection_id
    ):
        &#34;&#34;&#34;Send data agreement qr code initiate message.

        Args:
            qr_id (_type_): QR id
            connection_id (_type_): connection id
        &#34;&#34;&#34;

        message = DataAgreementQrCodeInitiateMessage(
            body=DataAgreementQrCodeInitiateBody(
                qr_id=qr_id
            )
        )

        await self.send_reply_message(message, connection_id)

    async def send_data_controller_details_message(
        self,
        connection_id: str
    ):
        &#34;&#34;&#34;Send data controller details message

        Args:
            connection_id (str): Connection ID
        &#34;&#34;&#34;

        message = DataControllerDetailsMessage()
        await self.send_reply_message(message, connection_id)

    async def process_data_controller_details_message(
        self,
        message: DataControllerDetailsMessage,
        receipt: MessageReceipt
    ):
        &#34;&#34;&#34;Process data controller details message.

        Args:
            message (DataControllerDetailsMessage): Data controller details message.
            receipt (MessageReceipt): Message receipt.
        &#34;&#34;&#34;

        # Query controller records.
        records = await ControllerDetailsRecord.query(self.context, {})

        connection_id = self.context.connection_record.connection_id

        if not records:
            wallet: BaseWallet = await self.context.inject(BaseWallet)
            controller_did = await wallet.get_public_did()

            cache: BaseCache = await self.context.inject(BaseCache, required=False)
            cache_key = f&#34;did:sov:{controller_did.did}&#34;

            assert cache, &#34;Cache not available.&#34;

            controller_details = None
            async with cache.acquire(cache_key) as entry:
                if entry.result:
                    cached = entry.result
                    controller_details = DataController.deserialize(cached)
                else:
                    org_details = await fetch_org_details_from_intermediary(self.context)

                    # Organisation did
                    organisation_did = f&#34;did:sov:{controller_did.did}&#34;

                    controller_details = DataController(
                        organisation_did=organisation_did,
                        organisation_name=org_details[&#34;Name&#34;],
                        cover_image_url=org_details[&#34;CoverImageURL&#34;] + &#34;/web&#34;,
                        logo_image_url=org_details[&#34;LogoImageURL&#34;] + &#34;/web&#34;,
                        location=org_details[&#34;Location&#34;],
                        organisation_type=org_details[&#34;Type&#34;][&#34;Type&#34;],
                        description=org_details[&#34;Description&#34;],
                        policy_url=org_details[&#34;PolicyURL&#34;],
                        eula_url=org_details[&#34;EulaURL&#34;]
                    )
                    cache_val = controller_details.serialize()
                    await entry.set_result(cache_val, 3600)

                response_message = DataControllerDetailsResponseMessage(
                    body=controller_details
                )

                await self.send_reply_message(response_message, connection_id)
        else:
            # If found update record.
            record: ControllerDetailsRecord = records[0]

            controller_details = DataController(
                organisation_did=record.organisation_did,
                organisation_name=record.organisation_name,
                cover_image_url=record.cover_image_url,
                logo_image_url=record.logo_image_url,
                location=record.location,
                organisation_type=record.organisation_type,
                description=record.description,
                policy_url=record.policy_url,
                eula_url=record.eula_url
            )

            response_message = DataControllerDetailsResponseMessage(
                body=controller_details
            )

            await self.send_reply_message(response_message, connection_id)

    async def update_controller_details(
        self,
        organisation_name: str = None,
        cover_image_url: str = None,
        logo_image_url: str = None,
        location: str = None,
        organisation_type: str = None,
        description: str = None,
        policy_url: str = None,
        eula_url: str = None
    ) -&gt; ControllerDetailsRecord:
        &#34;&#34;&#34;Update controller details

        Args:
            organisation_name (str, optional): Organisation name. Defaults to None.
            cover_image_url (str, optional): Cover image URL. Defaults to None.
            logo_image_url (str, optional): Logo image URL. Defaults to None.
            location (str, optional): Location. Defaults to None.
            organisation_type (str, optional): Organisation type. Defaults to None.
            description (str, optional): Description. Defaults to None.
            policy_url (str, optional): Policy URL. Defaults to None.
            eula_url (str, optional): EULA URL. Defaults to None.

        Returns:
            ControllerDetailsRecord: Controller details record.
        &#34;&#34;&#34;

        # Query controller records.
        records = await ControllerDetailsRecord.query(self.context, {})
        if not records:

            wallet: BaseWallet = await self.context.inject(BaseWallet)

            controller_did = await wallet.get_public_did()

            organisation_did = f&#34;did:sov:{controller_did.did}&#34;

            # If not found, create new record.
            record = ControllerDetailsRecord(
                organisation_did=organisation_did,
                organisation_name=organisation_name,
                cover_image_url=cover_image_url,
                logo_image_url=logo_image_url,
                location=location,
                organisation_type=organisation_type,
                description=description,
                policy_url=policy_url,
                eula_url=eula_url
            )

            await record.save(self.context)
        else:
            # If found update record.
            record: ControllerDetailsRecord = records[0]
            record.organisation_name = organisation_name
            record.cover_image_url = cover_image_url
            record.logo_image_url = logo_image_url
            record.location = location
            record.organisation_type = organisation_type
            record.description = description
            record.policy_url = policy_url
            record.eula_url = eula_url

            await record.save(self.context)

        return record

    async def process_existing_connections_message(
        self,
        message: ExistingConnectionsMessage,
        message_receipt: MessageReceipt
    ):
        &#34;&#34;&#34;Process existing connections message.

        Args:
            message (ExistingConnectionsMessage): Existing connections message.
            message_receipt (MessageReceipt): Message receipt.
        &#34;&#34;&#34;

        # Invitation key.
        invitation_key = message_receipt.recipient_verkey

        # Fetch current connection record using invitation key
        connection_record = await ConnectionRecord.retrieve_by_invitation_key(
            self.context,
            invitation_key
        )

        # Fetch existing connections record for the current connection.
        tag_filter = {
            &#34;connection_id&#34;: connection_record.connection_id
        }
        existing_connection_records = await ExistingConnectionRecord.query(
            self.context,
            tag_filter
        )

        if existing_connection_records:
            # Existing connection record.
            existing_connection_record: ExistingConnectionRecord = existing_connection_records[0]

            # Delete the record.
            await existing_connection_record.delete_record(self.context)

        # Fetch associated connection record.
        old_connection_record = await ConnectionRecord.retrieve_by_did(
            self.context,
            their_did=None,
            my_did=message.body.theirdid
        )

        # Create a new existing connection record.
        existing_connection_record = ExistingConnectionRecord(
            existing_connection_id=old_connection_record.connection_id,
            my_did=old_connection_record.my_did,
            connection_status=&#34;available&#34;,
            connection_id=connection_record.connection_id
        )

        await existing_connection_record.save(self.context)

        # updating the current connection invitation status to inactive
        connection_record.state = ConnectionRecord.STATE_INACTIVE
        await connection_record.save(context=self.context)

    async def get_existing_connection_record_for_new_connection_id(
        self,
        connection_id: str
    ) -&gt; ExistingConnectionRecord:
        &#34;&#34;&#34;Get existing connection record for new connection id.

        Args:
            connection_id (str): Connection id.

        Returns:
            ExistingConnectionRecord: Existing connection record.
        &#34;&#34;&#34;

        # Tag filter.
        tag_filter = {
            &#34;connection_id&#34;: connection_id
        }

        # Fetch existing connection records.
        existing_connection_records = await ExistingConnectionRecord.query(
            self.context,
            tag_filter
        )

        res = None
        if existing_connection_records:
            res = existing_connection_records[0]

        return res

    async def send_message_with_connection_invitation_and_return_route_all(
        self,
        message: AgentMessage,
        connection_id: str,
    ) -&gt; typing.Tuple[str, str, dict]:
        &#34;&#34;&#34;Send message with connection invitation and return route all.

        Args:
            message (AgentMessage): Agent message.
            connection_id (str): Connection id.

        Returns:
            typing.Tuple[str, str, dict]: sender_verkey, recipient_verkey, message_dict
        &#34;&#34;&#34;
        # Fetch connection record.
        connection_record: ConnectionRecord = \
            await ConnectionRecord.retrieve_by_id(self.context, connection_id)

        # Get invitation key.
        invitation_key = connection_record.invitation_key
        # Service enpoint
        invitation = await connection_record.retrieve_invitation(self.context)
        service_endpoint = invitation.endpoint

        # Fetch wallet from context
        wallet: IndyWallet = await self.context.inject(BaseWallet)

        # Set transport return route all
        message._decorators[&#34;transport&#34;] = TransportDecorator(
            return_route=&#34;all&#34;
        )

        # Create a local did
        did: DIDInfo = await wallet.create_local_did()

        sender_key = did.verkey
        packed_message = await wallet.pack_message(
            message.to_json(),
            [invitation_key],
            sender_key
        )

        headers = {
            &#34;Content-Type&#34;: &#34;application/ssi-agent-wire&#34;
        }

        async with aiohttp.ClientSession(headers=headers) as session:
            async with session.post(service_endpoint, data=packed_message) as response:
                if response.status == 200:
                    message_body = await response.read()

                    # Unpack message
                    unpacked = await wallet.unpack_message(message_body)
                    (message_json, sender_verkey, recipient_verkey) = unpacked

                    # Convert message to dict.
                    message_dict = json.loads(message_json)

                    return (sender_verkey, recipient_verkey, message_dict)

    async def send_message_with_connection_invitation(
        self,
        message: AgentMessage,
        connection_id: str,
    ) -&gt; None:
        &#34;&#34;&#34;Send message with connection invitation.

        Args:
            message (AgentMessage): Agent message.
            connection_id (str): Connection id.
        &#34;&#34;&#34;
        # Fetch connection record.
        connection_record: ConnectionRecord = \
            await ConnectionRecord.retrieve_by_id(self.context, connection_id)

        # Get invitation key.
        invitation_key = connection_record.invitation_key
        # Service enpoint
        invitation = await connection_record.retrieve_invitation(self.context)
        service_endpoint = invitation.endpoint

        # Fetch wallet from context
        wallet: IndyWallet = await self.context.inject(BaseWallet)

        # Create a local did
        did: DIDInfo = await wallet.create_local_did()

        sender_key = did.verkey
        packed_message = await wallet.pack_message(
            message.to_json(),
            [invitation_key],
            sender_key
        )

        headers = {
            &#34;Content-Type&#34;: &#34;application/ssi-agent-wire&#34;
        }

        async with aiohttp.ClientSession(headers=headers) as session:
            async with session.post(service_endpoint, data=packed_message) as response:
                if response.status == 200:
                    self._logger.info(&#34;Posted existing connection message...&#34;)

    async def send_existing_connections_message(
        self,
        theirdid: str,
        connection_id: str
    ):
        &#34;&#34;&#34;Send existing connections notification message.

        Args:
            theirdid (str): Their DID of remote agent in old connection.
            connection_id (str): Connection identifier.
        &#34;&#34;&#34;

        # Construct existing connection message.
        message = ExistingConnectionsMessage(
            body=ExistingConnectionsBody(
                theirdid=theirdid
            )
        )

        # Send the message to remote agent.
        await self.send_message_with_connection_invitation(
            message,
            connection_id
        )

    async def query_connections_and_categorise_results(
        self,
        tag_filter: dict = None,
        post_filter_positive: dict = None,
        page: int = 1,
        page_size: int = 10,
        org_flag: bool = False,
        marketplace_flag: bool = False,
    ) -&gt; PaginationResult:

        # Query the connection records.
        records = await ConnectionRecord.query(
            self.context,
            tag_filter,
            post_filter_positive
        )

        # Sort the connection records.
        records = sorted(
            records,
            key=lambda k: k.created_at,
            reverse=True
        )

        res = []
        for record in records:
            tag_filter = {&#34;connection_id&#34;: record.connection_id}

            # Fetch controller details attached to the connection.
            controller_details: typing.List[ConnectionControllerDetailsRecord] = \
                await ConnectionControllerDetailsRecord.query(
                self.context,
                tag_filter
            )

            # Fetch marketplace connection record.
            marketplace_connections: typing.List[MarketplaceConnectionRecord] = \
                await MarketplaceConnectionRecord.query(
                self.context,
                tag_filter
            )

            connection = record.serialize()

            # Update controller details to the connection dict.
            if controller_details:
                connection.update({
                    &#34;org_flag&#34;: True,
                    &#34;controller_details&#34;: controller_details[0].controller_details
                })
            else:
                connection.update({
                    &#34;controller_details&#34;: {},
                    &#34;org_flag&#34;: False
                })

            if marketplace_connections:
                connection.update({
                    &#34;marketplace_flag&#34;: True
                })
            else:
                connection.update({&#34;marketplace_flag&#34;: False})

            # Apply category filter on connections.
            categorise_filter = {
                &#34;org_flag&#34;: org_flag,
                &#34;marketplace_flag&#34;: marketplace_flag
            }

            categorise_filter = drop_none_dict(categorise_filter)

            if match_post_filter(connection, categorise_filter, True):
                res.append(connection)

        pagination_result = paginate(res, page if page else 1, page_size if page_size else 10)

        return pagination_result

    async def add_task(self,
                       context: InjectionContext,
                       coro: typing.Coroutine,
                       task_complete: typing.Callable = None,
                       ident: str = None) -&gt; PendingTask:
        &#34;&#34;&#34;
        Add a new task to the queue, delaying execution if busy.

        Args:
            context: Injection context to be used.
            coro: The coroutine to run
            task_complete: A callback to run on completion
            ident: A string identifier for the task

        Returns: a future resolving to the asyncio task instance once queued
        &#34;&#34;&#34;
        loop = asyncio.get_event_loop()
        pack_format: PackWireFormat = await context.inject(BaseWireFormat, required=False)
        return pack_format.task_queue.put(coro, lambda x: loop.create_task(task_complete(x)), ident)

    async def process_da_negotiation_receipt_message(
        self,
        message: DataAgreementNegotiationReceiptMessage,
        message_receipt: MessageReceipt
    ):
        &#34;&#34;&#34;Process DA negotiation receipt message.

        Args:
            message (DataAgreementNegotiationReceiptMessage): DA negotiation receipt message.
            message_receipt (MessageReceipt): Message receipt.
        &#34;&#34;&#34;

        instance_id = message.body.instance_id
        blockchain_receipt = message.body.blockchain_receipt
        blink = message.body.blink
        mydata_did = message.body.mydata_did

        # Fetch the DDA instance record.
        tag_filter = {
            &#34;instance_id&#34;: instance_id
        }
        instance_record: DataAgreementInstanceRecord = \
            await DataAgreementInstanceRecord.retrieve_by_tag_filter(
                self.context,
                tag_filter
            )

        # Update instance record.
        instance_record.blockchain_receipt = blockchain_receipt
        instance_record.blink = blink
        instance_record.mydata_did = mydata_did

        await instance_record.save(self.context)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="dexa_sdk.managers.ada_manager.V2ADAManager"><code class="flex name class">
<span>class <span class="ident">V2ADAManager</span></span>
<span>(</span><span>context: aries_cloudagent.config.injection_context.InjectionContext)</span>
</code></dt>
<dd>
<div class="desc"><p>Manages ADA related functions (v2)</p>
<p>Initialise ADA manager</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>context</code></strong> :&ensp;<code>InjectionContext</code></dt>
<dd><em>description</em></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class V2ADAManager:
    &#34;&#34;&#34;Manages ADA related functions (v2)
    &#34;&#34;&#34;

    def __init__(self, context: InjectionContext) -&gt; None:
        &#34;&#34;&#34;Initialise ADA manager

        Args:
            context (InjectionContext): _description_
        &#34;&#34;&#34;

        # Injection context
        self._context = context

        # Logger
        self._logger = logger

    @ property
    def context(self) -&gt; InjectionContext:
        &#34;&#34;&#34;Accessor for injection context

        Returns:
            InjectionContext: Injection context
        &#34;&#34;&#34;
        return self._context

    async def create_invitation(
        self,
        my_label: str = None,
        my_endpoint: str = None,
        their_role: str = None,
        auto_accept: bool = None,
        public: bool = False,
        multi_use: bool = False,
        alias: str = None,
    ) -&gt; typing.Tuple[ConnectionRecord, ConnectionInvitation]:
        &#34;&#34;&#34;Generate new connection invitation.&#34;&#34;&#34;

        if not my_label:
            my_label = self.context.settings.get(&#34;default_label&#34;)

        image_url = None

        # Fetch organisation details from intermediary.
        org_details = await fetch_org_details_from_intermediary(
            self.context
        )

        my_label = org_details[&#34;Name&#34;]
        image_url = org_details[&#34;LogoImageURL&#34;] + &#34;/web&#34;

        wallet: BaseWallet = await self.context.inject(BaseWallet)

        if public:
            if not self.context.settings.get(&#34;public_invites&#34;):
                raise ConnectionManagerError(
                    &#34;Public invitations are not enabled&#34;)

            public_did = await wallet.get_public_did()
            if not public_did:
                raise ConnectionManagerError(
                    &#34;Cannot create public invitation with no public DID&#34;
                )

            if multi_use:
                raise ConnectionManagerError(
                    &#34;Cannot use public and multi_use at the same time&#34;
                )

            # FIXME - allow ledger instance to format public DID with prefix?
            invitation = ConnectionInvitation(
                label=my_label, did=f&#34;did:sov:{public_did.did}&#34;, image_url=image_url
            )
            return None, invitation

        invitation_mode = ConnectionRecord.INVITATION_MODE_ONCE
        if multi_use:
            invitation_mode = ConnectionRecord.INVITATION_MODE_MULTI

        if not my_endpoint:
            my_endpoint = self.context.settings.get(&#34;default_endpoint&#34;)
        accept = (
            ConnectionRecord.ACCEPT_AUTO
            if (
                auto_accept
                or (
                    auto_accept is None
                    and self.context.settings.get(&#34;debug.auto_accept_requests&#34;)
                )
            )
            else ConnectionRecord.ACCEPT_MANUAL
        )

        # Create and store new invitation key
        connection_key = await wallet.create_signing_key()

        # Create connection record
        connection = ConnectionRecord(
            initiator=ConnectionRecord.INITIATOR_SELF,
            invitation_key=connection_key.verkey,
            their_role=their_role,
            state=ConnectionRecord.STATE_INVITATION,
            accept=accept,
            invitation_mode=invitation_mode,
            alias=alias,
        )

        await connection.save(self.context, reason=&#34;Created new invitation&#34;)

        # Create connection invitation message
        # Note: Need to split this into two stages to support inbound routing of invites
        # Would want to reuse create_did_document and convert the result
        invitation = ConnectionInvitation(
            label=my_label, recipient_keys=[
                connection_key.verkey], endpoint=my_endpoint, image_url=image_url
        )
        await connection.attach_invitation(self.context, invitation)

        return connection, invitation

    async def create_and_store_ledger_payloads_for_da_template(
            self,
            *,
            template_record: DataAgreementTemplateRecord,
            pd_records: typing.List[PersonalDataRecord] = None,
            schema_id: str = None
    ) -&gt; DataAgreementTemplateRecord:
        &#34;&#34;&#34;Create and store ledger payloads for a da template

        Args:
            template_record (DataAgreementTemplateRecord): Data agreement template record
            pd_records (typing.List[PersonalDataRecord]): Personal data records
            schema_id (str): Schema identifier if available

        Returns:
            DataAgreementTemplateRecord: Record with ledger payloads
        &#34;&#34;&#34;
        if template_record.method_of_use == DataAgreementTemplateRecord.METHOD_OF_USE_DATA_SOURCE:

            # Create schema if not existing
            if not schema_id:
                data_agreement = template_record.data_agreement
                # Schema name
                schema_name = data_agreement.get(&#34;purpose&#34;)
                # Schema version
                schema_version = data_agreement.get(&#34;version&#34;)
                # Schema attributes
                attributes = [
                    personal_data.attribute_name
                    for personal_data in pd_records
                ]
                # Creata schema and anchor to ledger
                (schema_id, schema_def) = await create_schema_def_and_anchor_to_ledger(
                    context=self.context,
                    schema_name=schema_name,
                    schema_version=schema_version,
                    attributes=attributes
                )

            # Create credential definition and anchor to ledger

            (cred_def_id, cred_def, novel) = await create_cred_def_and_anchor_to_ledger(
                context=self.context,
                schema_id=schema_id
            )

            template_record.cred_def_id = cred_def_id
            template_record.schema_id = schema_id
            await template_record.save(self.context)

        else:
            data_agreement = template_record.data_agreement

            # Usage purpose
            usage_purpose = data_agreement.get(&#34;purpose&#34;)

            # Usage purpose description
            usage_purpose_description = data_agreement.get(&#34;purposeDescription&#34;)

            # Data agreement template version
            da_template_version = data_agreement.get(&#34;version&#34;)

            # Create presentation request
            presentation_request = self.construct_presentation_request(
                usage_purpose=usage_purpose,
                usage_purpose_description=usage_purpose_description,
                da_template_version=da_template_version,
                personal_data=pd_records
            )

            template_record.presentation_request = presentation_request
            await template_record.save(self.context)

        return template_record

    def construct_presentation_request(
            self,
            *,
            usage_purpose: str,
            usage_purpose_description: str,
            da_template_version: str,
            personal_data: typing.List[PersonalDataRecord]
    ) -&gt; dict:
        &#34;&#34;&#34;
        Construct presentation request

        Args:
            usage_purpose: Usage purpose.
            usage_purpose_description: Usage purpose description.
            da_template_version: Data agreement template version.
            personal_data: List of personal data.

        Returns:
            :rtype: dict: Proof request

        &#34;&#34;&#34;

        presentation_request_dict: dict = {
            &#34;name&#34;: usage_purpose,
            &#34;comment&#34;: usage_purpose_description,
            &#34;version&#34;: da_template_version,
            &#34;requested_attributes&#34;: {},
            &#34;requested_predicates&#34;: {}
        }

        index = 1
        requested_attributes = {}

        for pd in personal_data:

            requested_attributes[&#34;additionalProp&#34; + str(index)] = {
                &#34;name&#34;: pd.attribute_name,
                &#34;restrictions&#34;: pd.restrictions if pd.restrictions else []
            }
            if pd.restrictions:
                restrictions = [
                    {
                        &#34;schema_id&#34;: restriction.get(&#34;schemaId&#34;),
                        &#34;cred_def_id&#34;: restriction.get(&#34;credDefId&#34;)
                    }
                    for restriction in pd.restrictions
                ]
                requested_attributes[&#34;additionalProp&#34; +
                                     str(index)].update({&#34;restrictions&#34;: restrictions})
            else:
                requested_attributes[&#34;additionalProp&#34; + str(index)].update({})
            index += 1

        presentation_request_dict[&#34;requested_attributes&#34;] = requested_attributes

        return presentation_request_dict

    async def create_and_store_da_template_in_wallet(
            self,
            data_agreement: dict,
            *,
            publish_flag: bool = True,
            schema_id: str = None
    ) -&gt; DataAgreementTemplateRecord:
        &#34;&#34;&#34;Create and store data agreement template in wallet

        Args:
            data_agreement (dict): Data agreement
            publish_flag (bool): Publish flag
            schema_id (str): Schema identifier
        &#34;&#34;&#34;

        # Temp hack
        template_version = &#34;1.0.0&#34;
        template_id = str(uuid.uuid4())
        data_agreement.update({&#34;@context&#34;: DA_DEFAULT_CONTEXT})
        data_agreement.update({&#34;@id&#34;: template_id})
        data_agreement.update({&#34;@type&#34;: DA_TYPE})
        data_agreement.update({&#34;version&#34;: template_version})

        try:
            # Validate the data agreement.
            data_agreement: DataAgreementModel = DataAgreementModel.deserialize(data_agreement)
        except ValidationError as err:
            raise V2ADAManagerError(
                f&#34;Failed to create data agreement; Reason: {err}&#34;
            )

        # Create personal data records
        pds = data_agreement.personal_data
        pd_records = []
        pd_models_with_id = []
        for pd in pds:
            pd_record: PersonalDataRecord = \
                await PersonalDataRecord.build_and_save_record_from_pd_model(
                    self.context,
                    template_id,
                    template_version,
                    pd
                )
            pd_records.append(pd_record)
            pd_models_with_id.append(pd_record.convert_record_to_pd_model())

        # Update the personal data with attribute identifiers to the agreement
        data_agreement.personal_data = pd_models_with_id

        # Create template record
        record = DataAgreementTemplateRecord(
            template_id=template_id,
            template_version=template_version,
            state=DataAgreementTemplateRecord.STATE_DEFINITION,
            method_of_use=data_agreement.method_of_use,
            data_agreement=data_agreement.serialize(),
            publish_flag=bool_to_str(publish_flag),
            schema_id=schema_id,
            existing_schema_flag=bool_to_str(True) if schema_id else bool_to_str(False),
            third_party_data_sharing=bool_to_str(
                data_agreement.data_policy.third_party_data_sharing)
        )

        await record.save(self.context)

        if publish_flag:
            # Create ledger payloads
            record = await self.create_and_store_ledger_payloads_for_da_template(
                template_record=record,
                pd_records=pd_records,
                schema_id=schema_id
            )

        return record

    async def query_da_templates_in_wallet(
            self,
            *,
            template_id: str = None,
            delete_flag: str = &#34;false&#34;,
            method_of_use: str = None,
            publish_flag: str = &#34;true&#34;,
            template_version: str = None,
            latest_version_flag: str = &#34;true&#34;,
            third_party_data_sharing: str = &#34;false&#34;,
            page: int = 1,
            page_size: int = 10,
    ) -&gt; PaginationResult:
        &#34;&#34;&#34;Query DA templates in wallet

        Args:
            template_id (str, optional): Template identifier. Defaults to None.
            delete_flag (str, optional): Delete flag. Defaults to false.
            method_of_use (str, optional): Method of use. Defaults to None.
            publish_flag (str, optional): Publish flag. Defaults to true.
            latest_version_flag (str, optional): Latest version flag. Defaults to true.
            template_version (str, optional): Template version. Defaults to None.
            third_party_data_sharing (str, optional): Third party data sharing.
                Defaults to false.
            page (int, optional): Page. Defaults to 1.

        Returns:
            PaginationResult: Pagination results.
        &#34;&#34;&#34;

        # Query by version is only possible if the template id is provided
        if template_version:
            assert template_id, &#34;Template identifier is required to query by version&#34;

        # Tag filter
        tag_filter = {
            &#34;delete_flag&#34;: delete_flag,
            &#34;publish_flag&#34;: publish_flag,
            &#34;method_of_use&#34;: method_of_use,
            &#34;template_id&#34;: template_id,
            &#34;template_version&#34;: template_version,
            &#34;latest_version_flag&#34;: latest_version_flag,
            &#34;third_party_data_sharing&#34;: third_party_data_sharing
        }

        tag_filter = drop_none_dict(tag_filter)

        records = await DataAgreementTemplateRecord.query(
            context=self.context,
            tag_filter=tag_filter
        )

        records = sorted(records, key=lambda k: k.created_at, reverse=True)

        paginate_result = paginate_records(records, page, page_size)

        return paginate_result

    async def publish_da_template_in_wallet(self,
                                            template_id: str) -&gt; DataAgreementTemplateRecord:
        &#34;&#34;&#34;Publish data agreement template.

        Args:
            template_id (str): Template identifier

        Returns:
            DataAgreementTemplateRecord: Template record.
        &#34;&#34;&#34;

        tag_filter = {
            &#34;delete_flag&#34;: bool_to_str(False),
            &#34;publish_flag&#34;: bool_to_str(False),
            &#34;latest_version_flag&#34;: bool_to_str(True),
            &#34;template_id&#34;: template_id
        }

        records = await DataAgreementTemplateRecord.query(
            context=self.context,
            tag_filter=tag_filter
        )

        assert records, &#34;Data agreement template not found.&#34;

        record: DataAgreementTemplateRecord = records[0]

        await record.publish_template(self.context)

        pd_records = await record.fetch_personal_data_records(self.context)

        # Create ledger payloads
        record = await self.create_and_store_ledger_payloads_for_da_template(
            template_record=record,
            pd_records=pd_records,
            schema_id=record.schema_id
        )

        return record

    async def update_and_store_da_template_in_wallet(
            self,
            template_id: str,
            data_agreement: dict,
            *,
            publish_flag: bool = True,
            schema_id: str = None
    ) -&gt; DataAgreementTemplateRecord:
        &#34;&#34;&#34;Update and store data agreement template in wallet.

        Args:
            template_id (str): Template identifier
            data_agreement (dict): Data agreement
            publish_flag (bool): Publish flag
            schema_id (str): Schema identifier

        Returns:
            DataAgreementTemplateRecord: Updated record.
        &#34;&#34;&#34;

        # Tag filter
        tag_filter = {
            &#34;delete_flag&#34;: bool_to_str(False),
            &#34;template_id&#34;: template_id,
            &#34;latest_version_flag&#34;: bool_to_str(True)
        }

        # Fetch data agreement record
        record: DataAgreementTemplateRecord = \
            await DataAgreementTemplateRecord.retrieve_by_tag_filter(self.context, tag_filter)

        # Validate the data agreement.
        previous_da: DataAgreementModel = DataAgreementModel.deserialize(record.data_agreement)

        assert previous_da.method_of_use == data_agreement.get(
            &#34;methodOfUse&#34;), &#34;Method of use cannot be updated.&#34;

        assert previous_da.data_policy.third_party_data_sharing \
            == data_agreement.get(&#34;dataPolicy&#34;).get(&#34;thirdPartyDataSharing&#34;), \
            &#34;Third party data sharing cannot be updated.&#34;

        # Copy the id, version from previous da to new da
        template_version = bump_major_for_semver_string(previous_da.version)
        template_id = previous_da.id
        data_agreement.update({&#34;@context&#34;: DA_DEFAULT_CONTEXT})
        data_agreement.update({&#34;@type&#34;: DA_TYPE})
        data_agreement.update({&#34;@id&#34;: template_id})
        data_agreement.update({&#34;version&#34;: template_version})

        updated_da: DataAgreementModel = DataAgreementModel.deserialize(data_agreement)

        # Create personal data records
        pds = updated_da.personal_data
        pd_records = []
        pd_models_with_id = []
        for pd in pds:
            pd_record: PersonalDataRecord = \
                await PersonalDataRecord.build_and_save_record_from_pd_model(
                    self.context,
                    template_id,
                    template_version,
                    pd
                )
            pd_records.append(pd_record)
            pd_models_with_id.append(pd_record.convert_record_to_pd_model())

        # Update the personal data with attribute identifiers to the agreement
        updated_da.personal_data = pd_models_with_id

        record.data_agreement = updated_da.serialize()
        record.publish_flag = bool_to_str(publish_flag)
        record.schema_id = schema_id
        record.existing_schema_flag = bool_to_str(True) if schema_id else bool_to_str(False)
        record.template_version = template_version

        await record.upgrade(self.context)

        if publish_flag:
            # Create ledger payloads
            record = await self.create_and_store_ledger_payloads_for_da_template(
                template_record=record,
                pd_records=pd_records,
                schema_id=schema_id
            )

        return record

    async def delete_da_template_in_wallet(self, template_id: str) -&gt; str:
        &#34;&#34;&#34;Deactivate DA template in wallet.

        This is not a normal delete operation of a specific version of template. Instead it
        marks the template with latest version flag as deleted i.e. Any version under this
        template is no longer active.

        Args:
            template_id (str): Template identifier
            template_version (str): Template version

        Returns:
            record_id: Record identifier for the deleted template.
        &#34;&#34;&#34;
        # Query for the data agreement by id
        data_agreement_records: DataAgreementTemplateRecord = \
            await DataAgreementTemplateRecord.non_deleted_template_by_id(
                self.context,
                template_id
            )

        assert data_agreement_records, &#34;Data agreement template not found.&#34;
        data_agreement_record = data_agreement_records[0]

        # Mark the data agreement as deleted and save.
        return await data_agreement_record.delete_template(self.context)

    async def query_pd_of_da_template_from_wallet(self,
                                                  template_id: str = None,
                                                  method_of_use: str = None,
                                                  third_party_data_sharing: str = None,
                                                  page: int = 1,
                                                  page_size: int = 10,
                                                  ) -&gt; PaginationResult:
        &#34;&#34;&#34;Query personal data for DA template.

        Args:
            template_id (str): Template identifier
            page (int, optional): Page number. Defaults to 1.
            page_size (int, optional): Page size. Defaults to 10.

        Returns:
            PaginationResult: Pagination results
        &#34;&#34;&#34;

        # Tag filter
        tag_filter = {
            &#34;delete_flag&#34;: bool_to_str(False),
            &#34;method_of_use&#34;: method_of_use,
            &#34;template_id&#34;: template_id,
            &#34;latest_version_flag&#34;: bool_to_str(True),
            &#34;third_party_data_sharing&#34;: third_party_data_sharing
        }

        tag_filter = drop_none_dict(tag_filter)

        records = await DataAgreementTemplateRecord.query(
            context=self.context,
            tag_filter=tag_filter
        )

        records = sorted(records, key=lambda k: k.created_at, reverse=True)

        # Fetch personal data records
        pd_records = []
        for record in records:
            pd_records.extend(await record.fetch_personal_data_records(self.context))

        paginate_result = paginate_records(pd_records, page, page_size)

        return paginate_result

    async def update_personal_data_description(self,
                                               attribute_id: str,
                                               desc: str) -&gt; PersonalDataRecord:
        &#34;&#34;&#34;Update personal data description

        Args:
            attribute_id (str): Attribute id
            desc (str): Description

        Returns:
            PersonalDataRecord: Personal data record
        &#34;&#34;&#34;

        # Fetch personal data record by id
        pd_record: PersonalDataRecord = await PersonalDataRecord.retrieve_by_id(
            self.context,
            attribute_id
        )

        # Fetch the associated data agreement record
        da_template_record: DataAgreementTemplateRecord = \
            await DataAgreementTemplateRecord.latest_template_by_id(
                self.context,
                pd_record.data_agreement_template_id
            )

        assert da_template_record, &#34;Matching data agreement template not found.&#34;
        assert da_template_record.template_version == \
            pd_record.data_agreement_template_version, \
            &#34;Matching data agreement template with same version not found.&#34;

        # Update the personal data record.
        pd_record.attribute_description = desc
        await pd_record.save(self.context)

        pd_model: DataAgreementPersonalDataModel = pd_record.convert_record_to_pd_model()

        # Update the data agreement record with new personal data.
        da: DataAgreementModel = DataAgreementModel.deserialize(da_template_record.data_agreement)
        # Iterate through the existing personal data in data agreements
        # And update the personal data matching the attribute id
        da_pds = []
        for da_pd in da.personal_data:
            if da_pd.attribute_id != pd_model.attribute_id:
                da_pds.append(da_pd)
        da_pds.append(pd_model)
        da.personal_data = da_pds

        da_template_record.data_agreement = da.serialize()
        await da_template_record.save(self.context)

        return pd_record

    async def delete_personal_data(self, attribute_id: str) -&gt; None:
        &#34;&#34;&#34;Delete personal data record.

        On deleting personal data record, the associated data agreement template is
        updated. If the personal data record deleted, is the last one in the template,
        proceed to delete the template record.

        Args:
            attribute_id (str): _description_
        &#34;&#34;&#34;

        # Fetch personal data record by id
        pd_record: PersonalDataRecord = await PersonalDataRecord.retrieve_by_id(
            self.context,
            attribute_id
        )

        # Fetch the associated data agreement record
        da_template_record: DataAgreementTemplateRecord = \
            await DataAgreementTemplateRecord.latest_template_by_id(
                self.context,
                pd_record.data_agreement_template_id
            )

        assert da_template_record, &#34;Matching data agreement template not found.&#34;
        assert da_template_record.template_version == \
            pd_record.data_agreement_template_version, \
            &#34;Matching data agreement template with same version not found.&#34;

        da: DataAgreementModel = DataAgreementModel.deserialize(da_template_record.data_agreement)

        # Iterate through the existing personal data in data agreements
        # And remove the deleted personal data.
        da_pds = []
        for da_pd in da.personal_data:
            if da_pd.attribute_id != pd_record.attribute_id:
                da_pd.attribute_id = None
                da_pds.append(da_pd)

        da.personal_data = da_pds

        if len(da_pds) == 0:
            await da_template_record.delete_template(self.context)
        else:
            # Update template record with new agreement.
            await self.update_and_store_da_template_in_wallet(
                pd_record.data_agreement_template_id,
                da.serialize(),
                publish_flag=str_to_bool(da_template_record.publish_flag)
            )

    async def build_data_agreement_offer_for_credential_exchange(
        self,
        template_id: str,
        connection_record: ConnectionRecord,
        cred_ex_record: V10CredentialExchange,
    ) -&gt; DataAgreementNegotiationOfferMessage:
        &#34;&#34;&#34;Build data agreement offer for credential exchange.

        Args:
            context (InjectionContext): Injection context to be used.
            template_id (str): Data agreement template identifier.
            connection_record (ConnectionRecord): Connection record.
            cred_ex_record (V10CredentialExchange): Credential exchange record.

        Returns:
            DataAgreementNegotiationOfferMessage: Offer message.
        &#34;&#34;&#34;

        # Build instance record
        (da_instance_record, da_instance_model) = \
            await DataAgreementInstanceRecord.build_instance_from_template(
            self.context,
            template_id,
            connection_record,
            cred_ex_record.credential_exchange_id
        )

        # Build negotiation offer agent message
        agent_message = DataAgreementNegotiationOfferMessage(body=da_instance_model)

        return agent_message

    async def build_data_agreement_offer_for_presentation_exchange(
        self,
        template_id: str,
        connection_record: ConnectionRecord,
        pres_ex_record: V10PresentationExchange,
    ) -&gt; DataAgreementNegotiationOfferMessage:
        &#34;&#34;&#34;Build data agreement offer for presentaton exchange.

        Args:
            context (InjectionContext): Injection context to be used.
            template_id (str): Data agreement template identifier.
            connection_record (ConnectionRecord): Connection record.
            pres_ex_record (V10PresentationExchange): Presentation exchange record.

        Returns:
            DataAgreementNegotiationOfferMessage: Offer message.
        &#34;&#34;&#34;

        # Build instance record
        (da_instance_record, da_instance_model) = \
            await DataAgreementInstanceRecord.build_instance_from_template(
            self.context,
            template_id,
            connection_record,
            pres_ex_record.presentation_exchange_id
        )

        # Build negotiation offer agent message
        agent_message = DataAgreementNegotiationOfferMessage(body=da_instance_model)

        return agent_message

    async def process_decorator_with_da_offer_message(
        self,
        decorator_set: DecoratorSet,
        data_ex_record: typing.Union[V10CredentialExchange, V10PresentationExchange],
        connection_record: ConnectionRecord
    ) -&gt; DataAgreementInstanceRecord:
        &#34;&#34;&#34;Process data agreement context decorator with DA offer message

        Args:
            decorator_set (DecoratorSet): Decorator set
            cred_ex_record (V10CredentialExchange): Credential exchange record
            connection_record (ConnectionRecord): Connection record

        Returns:
            DataAgreementInstanceRecord: Data agreement instance record.
        &#34;&#34;&#34;

        # Check if data agreement context decorator is present
        if &#34;data-agreement-context&#34; not in decorator_set.keys():
            self._logger.info(
                &#34;Data agreement context decorator is not present in the incoming message.&#34;)
            return None

        # Deserialize data agreement context decorator
        da_decorator_dict = decorator_set[&#34;data-agreement-context&#34;]
        da_decorator_model: DataAgreementContextDecorator = \
            DataAgreementContextDecorator.deserialize(da_decorator_dict)

        assert da_decorator_model.message_type == &#34;protocol&#34;, \
            &#34;DA context message type must be &#39;protocol&#39;.&#34;

        message_type = da_decorator_model.message.get(&#34;@type&#34;)
        assert DATA_AGREEMENT_NEGOTIATION_OFFER in message_type, \
            f&#34;DA context protocol message type must be &#39;{DATA_AGREEMENT_NEGOTIATION_OFFER}&#39;&#34;

        da_offer_message: DataAgreementNegotiationOfferMessage = \
            DataAgreementNegotiationOfferMessage.deserialize(da_decorator_model.message)

        # Build and save data agreement instance record.
        if data_ex_record.__class__.__name__ == V10CredentialExchange.__name__:
            return await DataAgreementInstanceRecord.build_instance_from_da_offer(
                self.context,
                da_offer_message,
                connection_record,
                data_ex_record.credential_exchange_id
            )
        else:
            return await DataAgreementInstanceRecord.build_instance_from_da_offer(
                self.context,
                da_offer_message,
                connection_record,
                data_ex_record.presentation_exchange_id
            )

    async def process_decorator_with_da_accept_message(
        self,
        decorator_set: DecoratorSet,
        data_ex_record: typing.Union[V10CredentialExchange, V10PresentationExchange],
        connection_record: ConnectionRecord
    ) -&gt; DataAgreementInstanceRecord:
        &#34;&#34;&#34;Process data agreement context decorator with DA accept message

        Args:
            decorator_set (DecoratorSet): Decorator set
            data_ex_record (typing.Union[V10CredentialExchange, V10PresentationExchange]):
                Data exchange record.
            connection_record (ConnectionRecord): Connection record

        Returns:
            DataAgreementInstanceRecord: Data agreement instance record.
        &#34;&#34;&#34;

        # Check if data agreement context decorator is present
        if &#34;data-agreement-context&#34; not in decorator_set.keys():
            self._logger.info(
                &#34;Data agreement context decorator is not present in the incoming message.&#34;)
            return None

        # Deserialize data agreement context decorator
        da_decorator_dict = decorator_set[&#34;data-agreement-context&#34;]
        da_decorator_model: DataAgreementContextDecorator = \
            DataAgreementContextDecorator.deserialize(da_decorator_dict)

        assert da_decorator_model.message_type == &#34;protocol&#34;, \
            &#34;DA context message type must be &#39;protocol&#39;.&#34;

        message_type = da_decorator_model.message.get(&#34;@type&#34;)
        assert DATA_AGREEMENT_NEGOTIATION_ACCEPT in message_type, \
            f&#34;DA context protocol message type must be &#39;{DATA_AGREEMENT_NEGOTIATION_ACCEPT}&#39;&#34;

        da_accept_message: DataAgreementNegotiationAcceptMessage = \
            DataAgreementNegotiationAcceptMessage.deserialize(da_decorator_model.message)

        # Build and save data agreement instance record.
        if data_ex_record.__class__.__name__ == V10CredentialExchange.__name__:
            # Build and save data agreement instance record.
            instance_record = await DataAgreementInstanceRecord.update_instance_from_da_accept(
                self.context,
                da_accept_message,
                data_ex_record.credential_exchange_id
            )
        else:
            # Build and save data agreement instance record.
            instance_record = await DataAgreementInstanceRecord.update_instance_from_da_accept(
                self.context,
                da_accept_message,
                data_ex_record.presentation_exchange_id
            )

        # Anchor da to blockchain.
        await self.anchor_da_instance_to_blockchain_async_task(instance_record.instance_id)

        return instance_record

    async def build_data_agreement_negotiation_accept_by_instance_id(
        self,
        instance_id: str,
        connection_record: ConnectionRecord
    ) -&gt; DataAgreementNegotiationAcceptMessage:
        # Counter sign da
        (da_instance_record, da_instance_model) = \
            await DataAgreementInstanceRecord.counter_sign_instance(
                self.context,
                instance_id,
                connection_record,
        )

        # Build negotiation accept agent message
        agent_message = DataAgreementNegotiationAcceptMessage(body=da_instance_model)

        return agent_message

    async def build_data_agreement_accept_for_data_ex_record(
        self,
        connection_record: ConnectionRecord,
        data_ex_record: typing.Union[V10CredentialExchange, V10PresentationExchange],
    ) -&gt; DataAgreementNegotiationAcceptMessage:
        &#34;&#34;&#34;Build data agreement accept message for credential exchange.

        Args:
            context (InjectionContext): Injection context to be used.
            template_id (str): Data agreement template identifier.
            connection_record (ConnectionRecord): Connection record.
            data_ex_record (typing.Union[V10CredentialExchange, V10PresentationExchange]):
                Data exchange record.

        Returns:
            DataAgreementNegotiationAcceptMessage: Accept message.
        &#34;&#34;&#34;
        if data_ex_record.__class__.__name__ == V10CredentialExchange.__name__:
            # Fetch data agreement instance matching credential exchange record.
            instance_record = await DataAgreementInstanceRecord.fetch_by_data_ex_id(
                self.context,
                data_ex_record.credential_exchange_id
            )
        else:
            # Fetch data agreement instance matching credential exchange record.
            instance_record = await DataAgreementInstanceRecord.fetch_by_data_ex_id(
                self.context,
                data_ex_record.presentation_exchange_id
            )

        # Build instance record
        (da_instance_record, da_instance_model) = \
            await DataAgreementInstanceRecord.counter_sign_instance(
            self.context,
            instance_record.instance_id,
            connection_record
        )

        # Build negotiation accept agent message
        agent_message = DataAgreementNegotiationAcceptMessage(body=da_instance_model)

        return agent_message

    async def query_data_agreement_instances(
        self,
        instance_id: str,
        template_id: str,
        template_version: str,
        method_of_use: str,
        third_party_data_sharing: str,
        data_ex_id: str,
        data_subject_did: str,
        page: int = 1,
        page_size: int = 10
    ) -&gt; PaginationResult:
        &#34;&#34;&#34;Query data agreement instances

        Args:
            instance_id (str): Instance identifier
            template_id (str): Template identifier
            template_version (str): Template version
            method_of_use (str): Method of use
            third_party_data_sharing (str): Third party data sharing
            data_ex_id (str): Data exchange id
            data_subject_did (str): Data subject did
            page (int, optional): Page. Defaults to 1.
            page_size (int, optional): Page size. Defaults to 10.

        Returns:
            PaginationResult: Pagination result
        &#34;&#34;&#34;
        # Query by version is only possible if the template id is provided
        if template_version:
            assert template_id, &#34;Template identifier is required to query by version&#34;

        # Tag filter
        tag_filter = {
            &#34;instance_id&#34;: instance_id,
            &#34;template_id&#34;: template_id,
            &#34;template_version&#34;: template_version,
            &#34;method_of_use&#34;: method_of_use,
            &#34;third_party_data_sharing&#34;: third_party_data_sharing,
            &#34;data_ex_id&#34;: data_ex_id,
            &#34;data_subject_did&#34;: data_subject_did
        }

        tag_filter = drop_none_dict(tag_filter)

        records = await DataAgreementInstanceRecord.query(
            context=self.context,
            tag_filter=tag_filter
        )

        records = sorted(records, key=lambda k: k.created_at, reverse=True)

        paginate_result = paginate_records(records, page, page_size)

        return paginate_result

    async def delete_da_instance_by_data_ex_id(
        self,
        cred_ex_id: str
    ) -&gt; None:
        &#34;&#34;&#34;Delete da instance by cred ex id.

        Args:
            cred_ex_id (str): Credential exchange identifier.
        &#34;&#34;&#34;

        # Data agreement instance
        instance = await DataAgreementInstanceRecord.fetch_by_data_ex_id(
            self.context,
            cred_ex_id
        )

        await instance.delete_record(self.context)

    async def anchor_da_instance_to_blockchain_async_task_callback(
        self, *args, **kwargs
    ):
        &#34;&#34;&#34;Anchor DA instance to blockchain async task callback function
        &#34;&#34;&#34;

        # Obtain the completed task.
        completed_task: CompletedTask = args[0]

        # Obtain the results from the task.
        (instance_id, mydata_did, tx_hash, tx_receipt) = completed_task.task.result()

        tag_filter = {
            &#34;instance_id&#34;: instance_id
        }

        # Fetch data agreement instance record.
        da_instance_records = await DataAgreementInstanceRecord.query(
            self.context,
            tag_filter,
        )

        assert da_instance_records, &#34;Data agreement instance not found.&#34;

        da_instance_record: DataAgreementInstanceRecord = da_instance_records[0]

        transaction_receipt = json.loads(to_json(tx_receipt))
        transaction_hash = transaction_receipt.get(&#34;transactionHash&#34;)

        # Update the data agreement with blockchain metadata.
        da_instance_record.blink = f&#34;blink:ethereum:rinkeby:{transaction_hash}&#34;
        da_instance_record.mydata_did = mydata_did
        da_instance_record.blockchain_receipt = transaction_receipt

        await da_instance_record.save(self.context)

        # Send receipt.
        message = DataAgreementNegotiationReceiptMessage(
            body=DataAgreementNegotiationReceiptBody(
                instance_id=da_instance_record.instance_id,
                blockchain_receipt=transaction_receipt,
                blink=f&#34;blink:ethereum:rinkeby:{transaction_hash}&#34;,
                mydata_did=mydata_did
            )
        )

        # Find the connection record.
        data_subject_did = da_instance_record.data_subject_did.replace(&#34;did:sov:&#34;, &#34;&#34;)
        connection_record: ConnectionRecord = await ConnectionRecord.retrieve_by_did(
            self.context,
            their_did=data_subject_did,
        )

        self.send_reply_message(
            message,
            connection_record.connection_id
        )

    async def anchor_da_instance_to_blockchain_async_task(
        self,
        instance_id: str
    ):
        &#34;&#34;&#34;Async task to anchor da instance to blockchain.

        Args:
            instance_id (str): Instance id
        &#34;&#34;&#34;
        pending_task = await self.add_task(
            self.context,
            self.anchor_da_instance_to_blockchain(instance_id),
            self.anchor_da_instance_to_blockchain_async_task_callback
        )
        self._logger.info(pending_task)

    async def anchor_da_instance_to_blockchain(
        self,
        instance_id: str
    ) -&gt; None:
        &#34;&#34;&#34;Anchor da instance to blockchain.

        Args:
            instance_id (str): Instance id
        &#34;&#34;&#34;

        eth_client: EthereumClient = await self.context.inject(EthereumClient)

        tag_filter = {
            &#34;instance_id&#34;: instance_id
        }

        # Fetch data agreement instance record.
        da_instance_records = await DataAgreementInstanceRecord.query(
            self.context,
            tag_filter,
        )

        assert da_instance_records, &#34;Data agreement instance not found.&#34;

        da_instance_record: DataAgreementInstanceRecord = da_instance_records[0]
        da_model: DataAgreementInstanceModel = \
            DataAgreementInstanceModel.deserialize(da_instance_record.data_agreement)

        did_mydata_builder = DIDMyDataBuilder(
            artefact=da_model
        )

        (tx_hash, tx_receipt) = await eth_client.emit_da_did(did_mydata_builder.mydata_did)

        return (da_instance_record.instance_id, did_mydata_builder.mydata_did, tx_hash, tx_receipt)

    async def create_data_agreement_qr_code(
        self,
        template_id: str,
        multi_use_flag: bool
    ) -&gt; dict:
        &#34;&#34;&#34;Create data agreement qr code

        Args:
            template_id (str): Template identifier
            multi_use_flag (bool): Multi use flag

        Returns:
            dict: Qr code.
        &#34;&#34;&#34;

        qr_record = DataAgreementQRCodeRecord(
            template_id=template_id,
            multi_use_flag=bool_to_str(multi_use_flag)
        )
        await qr_record.save(self.context)

        (connection, invitation) = await self.create_invitation(
            auto_accept=True,
            public=False,
            multi_use=multi_use_flag,
            alias=f&#34;DA_{template_id}_QR_{qr_record._id}&#34;
        )

        qr_record.connection_id = connection.connection_id
        await qr_record.save(self.context)

        res = {
            &#34;qr_id&#34;: qr_record._id,
            &#34;invitation&#34;: invitation.serialize()
        }

        res_base64 = base64.b64encode(json.dumps(res).encode()).decode()
        payload = self.context.settings.get(&#34;default_endpoint&#34;) + &#34;?qt=2&amp;qp=&#34; + res_base64

        firebase_dynamic_link = await generate_firebase_dynamic_link(self.context, payload)
        qr_record.dynamic_link = firebase_dynamic_link
        await qr_record.save(self.context)

        res.update({&#34;dynamic_link&#34;: firebase_dynamic_link})

        return res

    async def create_connection_qr_code(
        self,
        connection_id: str
    ) -&gt; dict:
        &#34;&#34;&#34;Create connection QR code.

        Args:
            connection_id (str): Connection identifier.

        Returns:
            dict: Dict with dynamic link.
        &#34;&#34;&#34;

        # Connection record.
        connection_record: ConnectionRecord = await ConnectionRecord.retrieve_by_id(
            self.context,
            connection_id
        )

        # Connection invitation
        connection_invitation: ConnectionInvitation = await connection_record.retrieve_invitation(
            self.context
        )

        # Generate firebase dynamic link.
        payload = connection_invitation.to_url()
        firebase_dynamic_link = await generate_firebase_dynamic_link(self.context, payload)

        res = {&#34;dynamic_link&#34;: firebase_dynamic_link}

        return res

    async def query_data_agreement_qr_codes(
        self,
        template_id: str,
    ) -&gt; PaginationResult:
        &#34;&#34;&#34;Query data agreement qr codes

        Returns:
            PaginationResult: List of qr code records.
        &#34;&#34;&#34;

        records = await DataAgreementQRCodeRecord.query(self.context, {&#34;template_id&#34;: template_id})
        pagination_result = paginate_records(records, page=1, page_size=1000000)
        return pagination_result

    async def send_reply_message(self, message: AgentMessage, connection_id: str = None) -&gt; None:
        &#34;&#34;&#34;Send reply message to remote agent.

        Args:
            message (AgentMessage): Agent message.
            connection_id (str): Connection identifier
        &#34;&#34;&#34;
        # Responder instance
        responder: DispatcherResponder = await self.context.inject(BaseResponder, required=False)

        if responder:
            await responder.send_reply(message, connection_id=connection_id)

    async def send_problem_report_message(self, explain: str, connection_id: str) -&gt; None:
        &#34;&#34;&#34;Send problem report message as reply.

        Args:
            explain (str): Explaination.
            connection_id (str): Connection id.
        &#34;&#34;&#34;

        # Responder instance
        responder: DispatcherResponder = await self.context.inject(BaseResponder, required=False)

        problem_report = ProblemReport(explain_ltxt=explain)

        if responder:
            await responder.send_reply(problem_report, connection_id=connection_id)

    async def delete_data_agreement_qr_code(
        self,
        template_id: str,
        qr_id: str
    ) -&gt; None:
        &#34;&#34;&#34;Delete data agreement qr code.&#34;&#34;&#34;
        record = await DataAgreementQRCodeRecord.retrieve_by_id(self.context, qr_id)
        assert record.template_id == template_id, &#34;Data agreement not found.&#34;
        await record.delete_record(self.context)

    async def process_data_agreement_qr_code_initiate_message(
        self,
        message: DataAgreementQrCodeInitiateMessage,
        receipt: MessageReceipt
    ):
        &#34;&#34;&#34;Process data QR code initiate message.

        Args:
            message (DataAgreementQrCodeInitiateMessage): Data agreement QR code initiate message.
            receipt (MessageReceipt): Message receipt.
        &#34;&#34;&#34;
        qr_id = message.body.qr_id
        connection_id = self.context.connection_record.connection_id

        connection_record = await ConnectionRecord.retrieve_by_id(self.context, connection_id)

        # Fetch the qr code record.
        record: DataAgreementQRCodeRecord = \
            await DataAgreementQRCodeRecord.retrieve_by_id(
                self.context,
                qr_id
            )

        if record._multi_use_flag:
            record._scanned_flag = True
            await record.save(self.context)
        else:
            if record._scanned_flag:
                explain = &#34;Qr code cannot be scanned twice&#34;
                await self.send_problem_report_message(explain, connection_id)
                raise Exception(explain)

        # Fetch data agreement template record.
        template_record: DataAgreementTemplateRecord = \
            await DataAgreementTemplateRecord.latest_template_by_id(
                self.context,
                record.template_id
            )

        # Construct presentation request
        preset_presentation_request = template_record.presentation_request
        comment = preset_presentation_request.pop(&#34;comment&#34;)
        if not preset_presentation_request.get(&#34;nonce&#34;):
            preset_presentation_request[&#34;nonce&#34;] = await generate_pr_nonce()

        presentation_request = PresentationRequest(
            comment=comment,
            request_presentations_attach=[
                AttachDecorator.from_indy_dict(
                    indy_dict=preset_presentation_request,
                    ident=ATTACH_DECO_IDS[PRESENTATION_REQUEST],
                )
            ],
        )

        # Construct presentation exchange record
        presentation_manager = PresentationManager(self.context)
        (pres_ex_record) = await presentation_manager.create_exchange_for_request(
            connection_id=self.context.connection_record.connection_id,
            presentation_request_message=presentation_request,
        )

        # Update qr code with record id.
        record.data_ex_id = pres_ex_record.presentation_exchange_id
        await record.save(self.context)

        offer_message = await self.build_data_agreement_offer_for_presentation_exchange(
            template_record.template_id,
            connection_record,
            pres_ex_record
        )

        # Add data agreement context decorator
        presentation_request._decorators[&#34;data-agreement-context&#34;] = DataAgreementContextDecorator(
            message_type=&#34;protocol&#34;,
            message=offer_message.serialize()
        )

        pres_ex_record.presentation_request_dict = presentation_request.serialize()
        pres_ex_record.template_id = template_record.template_id
        await pres_ex_record.save(self.context)

        await self.send_reply_message(presentation_request, connection_id)

    async def send_qr_code_initiate_message(
        self,
        qr_id,
        connection_id
    ):
        &#34;&#34;&#34;Send data agreement qr code initiate message.

        Args:
            qr_id (_type_): QR id
            connection_id (_type_): connection id
        &#34;&#34;&#34;

        message = DataAgreementQrCodeInitiateMessage(
            body=DataAgreementQrCodeInitiateBody(
                qr_id=qr_id
            )
        )

        await self.send_reply_message(message, connection_id)

    async def send_data_controller_details_message(
        self,
        connection_id: str
    ):
        &#34;&#34;&#34;Send data controller details message

        Args:
            connection_id (str): Connection ID
        &#34;&#34;&#34;

        message = DataControllerDetailsMessage()
        await self.send_reply_message(message, connection_id)

    async def process_data_controller_details_message(
        self,
        message: DataControllerDetailsMessage,
        receipt: MessageReceipt
    ):
        &#34;&#34;&#34;Process data controller details message.

        Args:
            message (DataControllerDetailsMessage): Data controller details message.
            receipt (MessageReceipt): Message receipt.
        &#34;&#34;&#34;

        # Query controller records.
        records = await ControllerDetailsRecord.query(self.context, {})

        connection_id = self.context.connection_record.connection_id

        if not records:
            wallet: BaseWallet = await self.context.inject(BaseWallet)
            controller_did = await wallet.get_public_did()

            cache: BaseCache = await self.context.inject(BaseCache, required=False)
            cache_key = f&#34;did:sov:{controller_did.did}&#34;

            assert cache, &#34;Cache not available.&#34;

            controller_details = None
            async with cache.acquire(cache_key) as entry:
                if entry.result:
                    cached = entry.result
                    controller_details = DataController.deserialize(cached)
                else:
                    org_details = await fetch_org_details_from_intermediary(self.context)

                    # Organisation did
                    organisation_did = f&#34;did:sov:{controller_did.did}&#34;

                    controller_details = DataController(
                        organisation_did=organisation_did,
                        organisation_name=org_details[&#34;Name&#34;],
                        cover_image_url=org_details[&#34;CoverImageURL&#34;] + &#34;/web&#34;,
                        logo_image_url=org_details[&#34;LogoImageURL&#34;] + &#34;/web&#34;,
                        location=org_details[&#34;Location&#34;],
                        organisation_type=org_details[&#34;Type&#34;][&#34;Type&#34;],
                        description=org_details[&#34;Description&#34;],
                        policy_url=org_details[&#34;PolicyURL&#34;],
                        eula_url=org_details[&#34;EulaURL&#34;]
                    )
                    cache_val = controller_details.serialize()
                    await entry.set_result(cache_val, 3600)

                response_message = DataControllerDetailsResponseMessage(
                    body=controller_details
                )

                await self.send_reply_message(response_message, connection_id)
        else:
            # If found update record.
            record: ControllerDetailsRecord = records[0]

            controller_details = DataController(
                organisation_did=record.organisation_did,
                organisation_name=record.organisation_name,
                cover_image_url=record.cover_image_url,
                logo_image_url=record.logo_image_url,
                location=record.location,
                organisation_type=record.organisation_type,
                description=record.description,
                policy_url=record.policy_url,
                eula_url=record.eula_url
            )

            response_message = DataControllerDetailsResponseMessage(
                body=controller_details
            )

            await self.send_reply_message(response_message, connection_id)

    async def update_controller_details(
        self,
        organisation_name: str = None,
        cover_image_url: str = None,
        logo_image_url: str = None,
        location: str = None,
        organisation_type: str = None,
        description: str = None,
        policy_url: str = None,
        eula_url: str = None
    ) -&gt; ControllerDetailsRecord:
        &#34;&#34;&#34;Update controller details

        Args:
            organisation_name (str, optional): Organisation name. Defaults to None.
            cover_image_url (str, optional): Cover image URL. Defaults to None.
            logo_image_url (str, optional): Logo image URL. Defaults to None.
            location (str, optional): Location. Defaults to None.
            organisation_type (str, optional): Organisation type. Defaults to None.
            description (str, optional): Description. Defaults to None.
            policy_url (str, optional): Policy URL. Defaults to None.
            eula_url (str, optional): EULA URL. Defaults to None.

        Returns:
            ControllerDetailsRecord: Controller details record.
        &#34;&#34;&#34;

        # Query controller records.
        records = await ControllerDetailsRecord.query(self.context, {})
        if not records:

            wallet: BaseWallet = await self.context.inject(BaseWallet)

            controller_did = await wallet.get_public_did()

            organisation_did = f&#34;did:sov:{controller_did.did}&#34;

            # If not found, create new record.
            record = ControllerDetailsRecord(
                organisation_did=organisation_did,
                organisation_name=organisation_name,
                cover_image_url=cover_image_url,
                logo_image_url=logo_image_url,
                location=location,
                organisation_type=organisation_type,
                description=description,
                policy_url=policy_url,
                eula_url=eula_url
            )

            await record.save(self.context)
        else:
            # If found update record.
            record: ControllerDetailsRecord = records[0]
            record.organisation_name = organisation_name
            record.cover_image_url = cover_image_url
            record.logo_image_url = logo_image_url
            record.location = location
            record.organisation_type = organisation_type
            record.description = description
            record.policy_url = policy_url
            record.eula_url = eula_url

            await record.save(self.context)

        return record

    async def process_existing_connections_message(
        self,
        message: ExistingConnectionsMessage,
        message_receipt: MessageReceipt
    ):
        &#34;&#34;&#34;Process existing connections message.

        Args:
            message (ExistingConnectionsMessage): Existing connections message.
            message_receipt (MessageReceipt): Message receipt.
        &#34;&#34;&#34;

        # Invitation key.
        invitation_key = message_receipt.recipient_verkey

        # Fetch current connection record using invitation key
        connection_record = await ConnectionRecord.retrieve_by_invitation_key(
            self.context,
            invitation_key
        )

        # Fetch existing connections record for the current connection.
        tag_filter = {
            &#34;connection_id&#34;: connection_record.connection_id
        }
        existing_connection_records = await ExistingConnectionRecord.query(
            self.context,
            tag_filter
        )

        if existing_connection_records:
            # Existing connection record.
            existing_connection_record: ExistingConnectionRecord = existing_connection_records[0]

            # Delete the record.
            await existing_connection_record.delete_record(self.context)

        # Fetch associated connection record.
        old_connection_record = await ConnectionRecord.retrieve_by_did(
            self.context,
            their_did=None,
            my_did=message.body.theirdid
        )

        # Create a new existing connection record.
        existing_connection_record = ExistingConnectionRecord(
            existing_connection_id=old_connection_record.connection_id,
            my_did=old_connection_record.my_did,
            connection_status=&#34;available&#34;,
            connection_id=connection_record.connection_id
        )

        await existing_connection_record.save(self.context)

        # updating the current connection invitation status to inactive
        connection_record.state = ConnectionRecord.STATE_INACTIVE
        await connection_record.save(context=self.context)

    async def get_existing_connection_record_for_new_connection_id(
        self,
        connection_id: str
    ) -&gt; ExistingConnectionRecord:
        &#34;&#34;&#34;Get existing connection record for new connection id.

        Args:
            connection_id (str): Connection id.

        Returns:
            ExistingConnectionRecord: Existing connection record.
        &#34;&#34;&#34;

        # Tag filter.
        tag_filter = {
            &#34;connection_id&#34;: connection_id
        }

        # Fetch existing connection records.
        existing_connection_records = await ExistingConnectionRecord.query(
            self.context,
            tag_filter
        )

        res = None
        if existing_connection_records:
            res = existing_connection_records[0]

        return res

    async def send_message_with_connection_invitation_and_return_route_all(
        self,
        message: AgentMessage,
        connection_id: str,
    ) -&gt; typing.Tuple[str, str, dict]:
        &#34;&#34;&#34;Send message with connection invitation and return route all.

        Args:
            message (AgentMessage): Agent message.
            connection_id (str): Connection id.

        Returns:
            typing.Tuple[str, str, dict]: sender_verkey, recipient_verkey, message_dict
        &#34;&#34;&#34;
        # Fetch connection record.
        connection_record: ConnectionRecord = \
            await ConnectionRecord.retrieve_by_id(self.context, connection_id)

        # Get invitation key.
        invitation_key = connection_record.invitation_key
        # Service enpoint
        invitation = await connection_record.retrieve_invitation(self.context)
        service_endpoint = invitation.endpoint

        # Fetch wallet from context
        wallet: IndyWallet = await self.context.inject(BaseWallet)

        # Set transport return route all
        message._decorators[&#34;transport&#34;] = TransportDecorator(
            return_route=&#34;all&#34;
        )

        # Create a local did
        did: DIDInfo = await wallet.create_local_did()

        sender_key = did.verkey
        packed_message = await wallet.pack_message(
            message.to_json(),
            [invitation_key],
            sender_key
        )

        headers = {
            &#34;Content-Type&#34;: &#34;application/ssi-agent-wire&#34;
        }

        async with aiohttp.ClientSession(headers=headers) as session:
            async with session.post(service_endpoint, data=packed_message) as response:
                if response.status == 200:
                    message_body = await response.read()

                    # Unpack message
                    unpacked = await wallet.unpack_message(message_body)
                    (message_json, sender_verkey, recipient_verkey) = unpacked

                    # Convert message to dict.
                    message_dict = json.loads(message_json)

                    return (sender_verkey, recipient_verkey, message_dict)

    async def send_message_with_connection_invitation(
        self,
        message: AgentMessage,
        connection_id: str,
    ) -&gt; None:
        &#34;&#34;&#34;Send message with connection invitation.

        Args:
            message (AgentMessage): Agent message.
            connection_id (str): Connection id.
        &#34;&#34;&#34;
        # Fetch connection record.
        connection_record: ConnectionRecord = \
            await ConnectionRecord.retrieve_by_id(self.context, connection_id)

        # Get invitation key.
        invitation_key = connection_record.invitation_key
        # Service enpoint
        invitation = await connection_record.retrieve_invitation(self.context)
        service_endpoint = invitation.endpoint

        # Fetch wallet from context
        wallet: IndyWallet = await self.context.inject(BaseWallet)

        # Create a local did
        did: DIDInfo = await wallet.create_local_did()

        sender_key = did.verkey
        packed_message = await wallet.pack_message(
            message.to_json(),
            [invitation_key],
            sender_key
        )

        headers = {
            &#34;Content-Type&#34;: &#34;application/ssi-agent-wire&#34;
        }

        async with aiohttp.ClientSession(headers=headers) as session:
            async with session.post(service_endpoint, data=packed_message) as response:
                if response.status == 200:
                    self._logger.info(&#34;Posted existing connection message...&#34;)

    async def send_existing_connections_message(
        self,
        theirdid: str,
        connection_id: str
    ):
        &#34;&#34;&#34;Send existing connections notification message.

        Args:
            theirdid (str): Their DID of remote agent in old connection.
            connection_id (str): Connection identifier.
        &#34;&#34;&#34;

        # Construct existing connection message.
        message = ExistingConnectionsMessage(
            body=ExistingConnectionsBody(
                theirdid=theirdid
            )
        )

        # Send the message to remote agent.
        await self.send_message_with_connection_invitation(
            message,
            connection_id
        )

    async def query_connections_and_categorise_results(
        self,
        tag_filter: dict = None,
        post_filter_positive: dict = None,
        page: int = 1,
        page_size: int = 10,
        org_flag: bool = False,
        marketplace_flag: bool = False,
    ) -&gt; PaginationResult:

        # Query the connection records.
        records = await ConnectionRecord.query(
            self.context,
            tag_filter,
            post_filter_positive
        )

        # Sort the connection records.
        records = sorted(
            records,
            key=lambda k: k.created_at,
            reverse=True
        )

        res = []
        for record in records:
            tag_filter = {&#34;connection_id&#34;: record.connection_id}

            # Fetch controller details attached to the connection.
            controller_details: typing.List[ConnectionControllerDetailsRecord] = \
                await ConnectionControllerDetailsRecord.query(
                self.context,
                tag_filter
            )

            # Fetch marketplace connection record.
            marketplace_connections: typing.List[MarketplaceConnectionRecord] = \
                await MarketplaceConnectionRecord.query(
                self.context,
                tag_filter
            )

            connection = record.serialize()

            # Update controller details to the connection dict.
            if controller_details:
                connection.update({
                    &#34;org_flag&#34;: True,
                    &#34;controller_details&#34;: controller_details[0].controller_details
                })
            else:
                connection.update({
                    &#34;controller_details&#34;: {},
                    &#34;org_flag&#34;: False
                })

            if marketplace_connections:
                connection.update({
                    &#34;marketplace_flag&#34;: True
                })
            else:
                connection.update({&#34;marketplace_flag&#34;: False})

            # Apply category filter on connections.
            categorise_filter = {
                &#34;org_flag&#34;: org_flag,
                &#34;marketplace_flag&#34;: marketplace_flag
            }

            categorise_filter = drop_none_dict(categorise_filter)

            if match_post_filter(connection, categorise_filter, True):
                res.append(connection)

        pagination_result = paginate(res, page if page else 1, page_size if page_size else 10)

        return pagination_result

    async def add_task(self,
                       context: InjectionContext,
                       coro: typing.Coroutine,
                       task_complete: typing.Callable = None,
                       ident: str = None) -&gt; PendingTask:
        &#34;&#34;&#34;
        Add a new task to the queue, delaying execution if busy.

        Args:
            context: Injection context to be used.
            coro: The coroutine to run
            task_complete: A callback to run on completion
            ident: A string identifier for the task

        Returns: a future resolving to the asyncio task instance once queued
        &#34;&#34;&#34;
        loop = asyncio.get_event_loop()
        pack_format: PackWireFormat = await context.inject(BaseWireFormat, required=False)
        return pack_format.task_queue.put(coro, lambda x: loop.create_task(task_complete(x)), ident)

    async def process_da_negotiation_receipt_message(
        self,
        message: DataAgreementNegotiationReceiptMessage,
        message_receipt: MessageReceipt
    ):
        &#34;&#34;&#34;Process DA negotiation receipt message.

        Args:
            message (DataAgreementNegotiationReceiptMessage): DA negotiation receipt message.
            message_receipt (MessageReceipt): Message receipt.
        &#34;&#34;&#34;

        instance_id = message.body.instance_id
        blockchain_receipt = message.body.blockchain_receipt
        blink = message.body.blink
        mydata_did = message.body.mydata_did

        # Fetch the DDA instance record.
        tag_filter = {
            &#34;instance_id&#34;: instance_id
        }
        instance_record: DataAgreementInstanceRecord = \
            await DataAgreementInstanceRecord.retrieve_by_tag_filter(
                self.context,
                tag_filter
            )

        # Update instance record.
        instance_record.blockchain_receipt = blockchain_receipt
        instance_record.blink = blink
        instance_record.mydata_did = mydata_did

        await instance_record.save(self.context)</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="dexa_sdk.managers.ada_manager.V2ADAManager.context"><code class="name">var <span class="ident">context</span> : aries_cloudagent.config.injection_context.InjectionContext</code></dt>
<dd>
<div class="desc"><p>Accessor for injection context</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>InjectionContext</code></dt>
<dd>Injection context</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@ property
def context(self) -&gt; InjectionContext:
    &#34;&#34;&#34;Accessor for injection context

    Returns:
        InjectionContext: Injection context
    &#34;&#34;&#34;
    return self._context</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="dexa_sdk.managers.ada_manager.V2ADAManager.add_task"><code class="name flex">
<span>async def <span class="ident">add_task</span></span>(<span>self, context: aries_cloudagent.config.injection_context.InjectionContext, coro: Coroutine[+T_co, -T_contra, +V_co], task_complete: Callable = None, ident: str = None) ‑> aries_cloudagent.utils.task_queue.PendingTask</span>
</code></dt>
<dd>
<div class="desc"><p>Add a new task to the queue, delaying execution if busy.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>context</code></strong></dt>
<dd>Injection context to be used.</dd>
<dt><strong><code>coro</code></strong></dt>
<dd>The coroutine to run</dd>
<dt><strong><code>task_complete</code></strong></dt>
<dd>A callback to run on completion</dd>
<dt><strong><code>ident</code></strong></dt>
<dd>A string identifier for the task</dd>
</dl>
<p>Returns: a future resolving to the asyncio task instance once queued</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def add_task(self,
                   context: InjectionContext,
                   coro: typing.Coroutine,
                   task_complete: typing.Callable = None,
                   ident: str = None) -&gt; PendingTask:
    &#34;&#34;&#34;
    Add a new task to the queue, delaying execution if busy.

    Args:
        context: Injection context to be used.
        coro: The coroutine to run
        task_complete: A callback to run on completion
        ident: A string identifier for the task

    Returns: a future resolving to the asyncio task instance once queued
    &#34;&#34;&#34;
    loop = asyncio.get_event_loop()
    pack_format: PackWireFormat = await context.inject(BaseWireFormat, required=False)
    return pack_format.task_queue.put(coro, lambda x: loop.create_task(task_complete(x)), ident)</code></pre>
</details>
</dd>
<dt id="dexa_sdk.managers.ada_manager.V2ADAManager.anchor_da_instance_to_blockchain"><code class="name flex">
<span>async def <span class="ident">anchor_da_instance_to_blockchain</span></span>(<span>self, instance_id: str) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Anchor da instance to blockchain.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>instance_id</code></strong> :&ensp;<code>str</code></dt>
<dd>Instance id</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def anchor_da_instance_to_blockchain(
    self,
    instance_id: str
) -&gt; None:
    &#34;&#34;&#34;Anchor da instance to blockchain.

    Args:
        instance_id (str): Instance id
    &#34;&#34;&#34;

    eth_client: EthereumClient = await self.context.inject(EthereumClient)

    tag_filter = {
        &#34;instance_id&#34;: instance_id
    }

    # Fetch data agreement instance record.
    da_instance_records = await DataAgreementInstanceRecord.query(
        self.context,
        tag_filter,
    )

    assert da_instance_records, &#34;Data agreement instance not found.&#34;

    da_instance_record: DataAgreementInstanceRecord = da_instance_records[0]
    da_model: DataAgreementInstanceModel = \
        DataAgreementInstanceModel.deserialize(da_instance_record.data_agreement)

    did_mydata_builder = DIDMyDataBuilder(
        artefact=da_model
    )

    (tx_hash, tx_receipt) = await eth_client.emit_da_did(did_mydata_builder.mydata_did)

    return (da_instance_record.instance_id, did_mydata_builder.mydata_did, tx_hash, tx_receipt)</code></pre>
</details>
</dd>
<dt id="dexa_sdk.managers.ada_manager.V2ADAManager.anchor_da_instance_to_blockchain_async_task"><code class="name flex">
<span>async def <span class="ident">anchor_da_instance_to_blockchain_async_task</span></span>(<span>self, instance_id: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Async task to anchor da instance to blockchain.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>instance_id</code></strong> :&ensp;<code>str</code></dt>
<dd>Instance id</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def anchor_da_instance_to_blockchain_async_task(
    self,
    instance_id: str
):
    &#34;&#34;&#34;Async task to anchor da instance to blockchain.

    Args:
        instance_id (str): Instance id
    &#34;&#34;&#34;
    pending_task = await self.add_task(
        self.context,
        self.anchor_da_instance_to_blockchain(instance_id),
        self.anchor_da_instance_to_blockchain_async_task_callback
    )
    self._logger.info(pending_task)</code></pre>
</details>
</dd>
<dt id="dexa_sdk.managers.ada_manager.V2ADAManager.anchor_da_instance_to_blockchain_async_task_callback"><code class="name flex">
<span>async def <span class="ident">anchor_da_instance_to_blockchain_async_task_callback</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Anchor DA instance to blockchain async task callback function</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def anchor_da_instance_to_blockchain_async_task_callback(
    self, *args, **kwargs
):
    &#34;&#34;&#34;Anchor DA instance to blockchain async task callback function
    &#34;&#34;&#34;

    # Obtain the completed task.
    completed_task: CompletedTask = args[0]

    # Obtain the results from the task.
    (instance_id, mydata_did, tx_hash, tx_receipt) = completed_task.task.result()

    tag_filter = {
        &#34;instance_id&#34;: instance_id
    }

    # Fetch data agreement instance record.
    da_instance_records = await DataAgreementInstanceRecord.query(
        self.context,
        tag_filter,
    )

    assert da_instance_records, &#34;Data agreement instance not found.&#34;

    da_instance_record: DataAgreementInstanceRecord = da_instance_records[0]

    transaction_receipt = json.loads(to_json(tx_receipt))
    transaction_hash = transaction_receipt.get(&#34;transactionHash&#34;)

    # Update the data agreement with blockchain metadata.
    da_instance_record.blink = f&#34;blink:ethereum:rinkeby:{transaction_hash}&#34;
    da_instance_record.mydata_did = mydata_did
    da_instance_record.blockchain_receipt = transaction_receipt

    await da_instance_record.save(self.context)

    # Send receipt.
    message = DataAgreementNegotiationReceiptMessage(
        body=DataAgreementNegotiationReceiptBody(
            instance_id=da_instance_record.instance_id,
            blockchain_receipt=transaction_receipt,
            blink=f&#34;blink:ethereum:rinkeby:{transaction_hash}&#34;,
            mydata_did=mydata_did
        )
    )

    # Find the connection record.
    data_subject_did = da_instance_record.data_subject_did.replace(&#34;did:sov:&#34;, &#34;&#34;)
    connection_record: ConnectionRecord = await ConnectionRecord.retrieve_by_did(
        self.context,
        their_did=data_subject_did,
    )

    self.send_reply_message(
        message,
        connection_record.connection_id
    )</code></pre>
</details>
</dd>
<dt id="dexa_sdk.managers.ada_manager.V2ADAManager.build_data_agreement_accept_for_data_ex_record"><code class="name flex">
<span>async def <span class="ident">build_data_agreement_accept_for_data_ex_record</span></span>(<span>self, connection_record: aries_cloudagent.connections.models.connection_record.ConnectionRecord, data_ex_record: Union[aries_cloudagent.protocols.issue_credential.v1_0.models.credential_exchange.V10CredentialExchange, aries_cloudagent.protocols.present_proof.v1_0.models.presentation_exchange.V10PresentationExchange]) ‑> mydata_did.v1_0.messages.data_agreement_accept.DataAgreementNegotiationAcceptMessage</span>
</code></dt>
<dd>
<div class="desc"><p>Build data agreement accept message for credential exchange.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>context</code></strong> :&ensp;<code>InjectionContext</code></dt>
<dd>Injection context to be used.</dd>
<dt><strong><code>template_id</code></strong> :&ensp;<code>str</code></dt>
<dd>Data agreement template identifier.</dd>
<dt><strong><code>connection_record</code></strong> :&ensp;<code>ConnectionRecord</code></dt>
<dd>Connection record.</dd>
</dl>
<p>data_ex_record (typing.Union[V10CredentialExchange, V10PresentationExchange]):
Data exchange record.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>DataAgreementNegotiationAcceptMessage</code></dt>
<dd>Accept message.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def build_data_agreement_accept_for_data_ex_record(
    self,
    connection_record: ConnectionRecord,
    data_ex_record: typing.Union[V10CredentialExchange, V10PresentationExchange],
) -&gt; DataAgreementNegotiationAcceptMessage:
    &#34;&#34;&#34;Build data agreement accept message for credential exchange.

    Args:
        context (InjectionContext): Injection context to be used.
        template_id (str): Data agreement template identifier.
        connection_record (ConnectionRecord): Connection record.
        data_ex_record (typing.Union[V10CredentialExchange, V10PresentationExchange]):
            Data exchange record.

    Returns:
        DataAgreementNegotiationAcceptMessage: Accept message.
    &#34;&#34;&#34;
    if data_ex_record.__class__.__name__ == V10CredentialExchange.__name__:
        # Fetch data agreement instance matching credential exchange record.
        instance_record = await DataAgreementInstanceRecord.fetch_by_data_ex_id(
            self.context,
            data_ex_record.credential_exchange_id
        )
    else:
        # Fetch data agreement instance matching credential exchange record.
        instance_record = await DataAgreementInstanceRecord.fetch_by_data_ex_id(
            self.context,
            data_ex_record.presentation_exchange_id
        )

    # Build instance record
    (da_instance_record, da_instance_model) = \
        await DataAgreementInstanceRecord.counter_sign_instance(
        self.context,
        instance_record.instance_id,
        connection_record
    )

    # Build negotiation accept agent message
    agent_message = DataAgreementNegotiationAcceptMessage(body=da_instance_model)

    return agent_message</code></pre>
</details>
</dd>
<dt id="dexa_sdk.managers.ada_manager.V2ADAManager.build_data_agreement_negotiation_accept_by_instance_id"><code class="name flex">
<span>async def <span class="ident">build_data_agreement_negotiation_accept_by_instance_id</span></span>(<span>self, instance_id: str, connection_record: aries_cloudagent.connections.models.connection_record.ConnectionRecord) ‑> mydata_did.v1_0.messages.data_agreement_accept.DataAgreementNegotiationAcceptMessage</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def build_data_agreement_negotiation_accept_by_instance_id(
    self,
    instance_id: str,
    connection_record: ConnectionRecord
) -&gt; DataAgreementNegotiationAcceptMessage:
    # Counter sign da
    (da_instance_record, da_instance_model) = \
        await DataAgreementInstanceRecord.counter_sign_instance(
            self.context,
            instance_id,
            connection_record,
    )

    # Build negotiation accept agent message
    agent_message = DataAgreementNegotiationAcceptMessage(body=da_instance_model)

    return agent_message</code></pre>
</details>
</dd>
<dt id="dexa_sdk.managers.ada_manager.V2ADAManager.build_data_agreement_offer_for_credential_exchange"><code class="name flex">
<span>async def <span class="ident">build_data_agreement_offer_for_credential_exchange</span></span>(<span>self, template_id: str, connection_record: aries_cloudagent.connections.models.connection_record.ConnectionRecord, cred_ex_record: aries_cloudagent.protocols.issue_credential.v1_0.models.credential_exchange.V10CredentialExchange) ‑> mydata_did.v1_0.messages.data_agreement_offer.DataAgreementNegotiationOfferMessage</span>
</code></dt>
<dd>
<div class="desc"><p>Build data agreement offer for credential exchange.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>context</code></strong> :&ensp;<code>InjectionContext</code></dt>
<dd>Injection context to be used.</dd>
<dt><strong><code>template_id</code></strong> :&ensp;<code>str</code></dt>
<dd>Data agreement template identifier.</dd>
<dt><strong><code>connection_record</code></strong> :&ensp;<code>ConnectionRecord</code></dt>
<dd>Connection record.</dd>
<dt><strong><code>cred_ex_record</code></strong> :&ensp;<code>V10CredentialExchange</code></dt>
<dd>Credential exchange record.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>DataAgreementNegotiationOfferMessage</code></dt>
<dd>Offer message.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def build_data_agreement_offer_for_credential_exchange(
    self,
    template_id: str,
    connection_record: ConnectionRecord,
    cred_ex_record: V10CredentialExchange,
) -&gt; DataAgreementNegotiationOfferMessage:
    &#34;&#34;&#34;Build data agreement offer for credential exchange.

    Args:
        context (InjectionContext): Injection context to be used.
        template_id (str): Data agreement template identifier.
        connection_record (ConnectionRecord): Connection record.
        cred_ex_record (V10CredentialExchange): Credential exchange record.

    Returns:
        DataAgreementNegotiationOfferMessage: Offer message.
    &#34;&#34;&#34;

    # Build instance record
    (da_instance_record, da_instance_model) = \
        await DataAgreementInstanceRecord.build_instance_from_template(
        self.context,
        template_id,
        connection_record,
        cred_ex_record.credential_exchange_id
    )

    # Build negotiation offer agent message
    agent_message = DataAgreementNegotiationOfferMessage(body=da_instance_model)

    return agent_message</code></pre>
</details>
</dd>
<dt id="dexa_sdk.managers.ada_manager.V2ADAManager.build_data_agreement_offer_for_presentation_exchange"><code class="name flex">
<span>async def <span class="ident">build_data_agreement_offer_for_presentation_exchange</span></span>(<span>self, template_id: str, connection_record: aries_cloudagent.connections.models.connection_record.ConnectionRecord, pres_ex_record: aries_cloudagent.protocols.present_proof.v1_0.models.presentation_exchange.V10PresentationExchange) ‑> mydata_did.v1_0.messages.data_agreement_offer.DataAgreementNegotiationOfferMessage</span>
</code></dt>
<dd>
<div class="desc"><p>Build data agreement offer for presentaton exchange.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>context</code></strong> :&ensp;<code>InjectionContext</code></dt>
<dd>Injection context to be used.</dd>
<dt><strong><code>template_id</code></strong> :&ensp;<code>str</code></dt>
<dd>Data agreement template identifier.</dd>
<dt><strong><code>connection_record</code></strong> :&ensp;<code>ConnectionRecord</code></dt>
<dd>Connection record.</dd>
<dt><strong><code>pres_ex_record</code></strong> :&ensp;<code>V10PresentationExchange</code></dt>
<dd>Presentation exchange record.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>DataAgreementNegotiationOfferMessage</code></dt>
<dd>Offer message.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def build_data_agreement_offer_for_presentation_exchange(
    self,
    template_id: str,
    connection_record: ConnectionRecord,
    pres_ex_record: V10PresentationExchange,
) -&gt; DataAgreementNegotiationOfferMessage:
    &#34;&#34;&#34;Build data agreement offer for presentaton exchange.

    Args:
        context (InjectionContext): Injection context to be used.
        template_id (str): Data agreement template identifier.
        connection_record (ConnectionRecord): Connection record.
        pres_ex_record (V10PresentationExchange): Presentation exchange record.

    Returns:
        DataAgreementNegotiationOfferMessage: Offer message.
    &#34;&#34;&#34;

    # Build instance record
    (da_instance_record, da_instance_model) = \
        await DataAgreementInstanceRecord.build_instance_from_template(
        self.context,
        template_id,
        connection_record,
        pres_ex_record.presentation_exchange_id
    )

    # Build negotiation offer agent message
    agent_message = DataAgreementNegotiationOfferMessage(body=da_instance_model)

    return agent_message</code></pre>
</details>
</dd>
<dt id="dexa_sdk.managers.ada_manager.V2ADAManager.construct_presentation_request"><code class="name flex">
<span>def <span class="ident">construct_presentation_request</span></span>(<span>self, *, usage_purpose: str, usage_purpose_description: str, da_template_version: str, personal_data: List[<a title="dexa_sdk.agreements.da.v1_0.records.personal_data_record.PersonalDataRecord" href="../agreements/da/v1_0/records/personal_data_record.html#dexa_sdk.agreements.da.v1_0.records.personal_data_record.PersonalDataRecord">PersonalDataRecord</a>]) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Construct presentation request</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>usage_purpose</code></strong></dt>
<dd>Usage purpose.</dd>
<dt><strong><code>usage_purpose_description</code></strong></dt>
<dd>Usage purpose description.</dd>
<dt><strong><code>da_template_version</code></strong></dt>
<dd>Data agreement template version.</dd>
<dt><strong><code>personal_data</code></strong></dt>
<dd>List of personal data.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>:rtype: dict: Proof request</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def construct_presentation_request(
        self,
        *,
        usage_purpose: str,
        usage_purpose_description: str,
        da_template_version: str,
        personal_data: typing.List[PersonalDataRecord]
) -&gt; dict:
    &#34;&#34;&#34;
    Construct presentation request

    Args:
        usage_purpose: Usage purpose.
        usage_purpose_description: Usage purpose description.
        da_template_version: Data agreement template version.
        personal_data: List of personal data.

    Returns:
        :rtype: dict: Proof request

    &#34;&#34;&#34;

    presentation_request_dict: dict = {
        &#34;name&#34;: usage_purpose,
        &#34;comment&#34;: usage_purpose_description,
        &#34;version&#34;: da_template_version,
        &#34;requested_attributes&#34;: {},
        &#34;requested_predicates&#34;: {}
    }

    index = 1
    requested_attributes = {}

    for pd in personal_data:

        requested_attributes[&#34;additionalProp&#34; + str(index)] = {
            &#34;name&#34;: pd.attribute_name,
            &#34;restrictions&#34;: pd.restrictions if pd.restrictions else []
        }
        if pd.restrictions:
            restrictions = [
                {
                    &#34;schema_id&#34;: restriction.get(&#34;schemaId&#34;),
                    &#34;cred_def_id&#34;: restriction.get(&#34;credDefId&#34;)
                }
                for restriction in pd.restrictions
            ]
            requested_attributes[&#34;additionalProp&#34; +
                                 str(index)].update({&#34;restrictions&#34;: restrictions})
        else:
            requested_attributes[&#34;additionalProp&#34; + str(index)].update({})
        index += 1

    presentation_request_dict[&#34;requested_attributes&#34;] = requested_attributes

    return presentation_request_dict</code></pre>
</details>
</dd>
<dt id="dexa_sdk.managers.ada_manager.V2ADAManager.create_and_store_da_template_in_wallet"><code class="name flex">
<span>async def <span class="ident">create_and_store_da_template_in_wallet</span></span>(<span>self, data_agreement: dict, *, publish_flag: bool = True, schema_id: str = None) ‑> <a title="dexa_sdk.agreements.da.v1_0.records.da_template_record.DataAgreementTemplateRecord" href="../agreements/da/v1_0/records/da_template_record.html#dexa_sdk.agreements.da.v1_0.records.da_template_record.DataAgreementTemplateRecord">DataAgreementTemplateRecord</a></span>
</code></dt>
<dd>
<div class="desc"><p>Create and store data agreement template in wallet</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data_agreement</code></strong> :&ensp;<code>dict</code></dt>
<dd>Data agreement</dd>
<dt><strong><code>publish_flag</code></strong> :&ensp;<code>bool</code></dt>
<dd>Publish flag</dd>
<dt><strong><code>schema_id</code></strong> :&ensp;<code>str</code></dt>
<dd>Schema identifier</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def create_and_store_da_template_in_wallet(
        self,
        data_agreement: dict,
        *,
        publish_flag: bool = True,
        schema_id: str = None
) -&gt; DataAgreementTemplateRecord:
    &#34;&#34;&#34;Create and store data agreement template in wallet

    Args:
        data_agreement (dict): Data agreement
        publish_flag (bool): Publish flag
        schema_id (str): Schema identifier
    &#34;&#34;&#34;

    # Temp hack
    template_version = &#34;1.0.0&#34;
    template_id = str(uuid.uuid4())
    data_agreement.update({&#34;@context&#34;: DA_DEFAULT_CONTEXT})
    data_agreement.update({&#34;@id&#34;: template_id})
    data_agreement.update({&#34;@type&#34;: DA_TYPE})
    data_agreement.update({&#34;version&#34;: template_version})

    try:
        # Validate the data agreement.
        data_agreement: DataAgreementModel = DataAgreementModel.deserialize(data_agreement)
    except ValidationError as err:
        raise V2ADAManagerError(
            f&#34;Failed to create data agreement; Reason: {err}&#34;
        )

    # Create personal data records
    pds = data_agreement.personal_data
    pd_records = []
    pd_models_with_id = []
    for pd in pds:
        pd_record: PersonalDataRecord = \
            await PersonalDataRecord.build_and_save_record_from_pd_model(
                self.context,
                template_id,
                template_version,
                pd
            )
        pd_records.append(pd_record)
        pd_models_with_id.append(pd_record.convert_record_to_pd_model())

    # Update the personal data with attribute identifiers to the agreement
    data_agreement.personal_data = pd_models_with_id

    # Create template record
    record = DataAgreementTemplateRecord(
        template_id=template_id,
        template_version=template_version,
        state=DataAgreementTemplateRecord.STATE_DEFINITION,
        method_of_use=data_agreement.method_of_use,
        data_agreement=data_agreement.serialize(),
        publish_flag=bool_to_str(publish_flag),
        schema_id=schema_id,
        existing_schema_flag=bool_to_str(True) if schema_id else bool_to_str(False),
        third_party_data_sharing=bool_to_str(
            data_agreement.data_policy.third_party_data_sharing)
    )

    await record.save(self.context)

    if publish_flag:
        # Create ledger payloads
        record = await self.create_and_store_ledger_payloads_for_da_template(
            template_record=record,
            pd_records=pd_records,
            schema_id=schema_id
        )

    return record</code></pre>
</details>
</dd>
<dt id="dexa_sdk.managers.ada_manager.V2ADAManager.create_and_store_ledger_payloads_for_da_template"><code class="name flex">
<span>async def <span class="ident">create_and_store_ledger_payloads_for_da_template</span></span>(<span>self, *, template_record: <a title="dexa_sdk.agreements.da.v1_0.records.da_template_record.DataAgreementTemplateRecord" href="../agreements/da/v1_0/records/da_template_record.html#dexa_sdk.agreements.da.v1_0.records.da_template_record.DataAgreementTemplateRecord">DataAgreementTemplateRecord</a>, pd_records: List[<a title="dexa_sdk.agreements.da.v1_0.records.personal_data_record.PersonalDataRecord" href="../agreements/da/v1_0/records/personal_data_record.html#dexa_sdk.agreements.da.v1_0.records.personal_data_record.PersonalDataRecord">PersonalDataRecord</a>] = None, schema_id: str = None) ‑> <a title="dexa_sdk.agreements.da.v1_0.records.da_template_record.DataAgreementTemplateRecord" href="../agreements/da/v1_0/records/da_template_record.html#dexa_sdk.agreements.da.v1_0.records.da_template_record.DataAgreementTemplateRecord">DataAgreementTemplateRecord</a></span>
</code></dt>
<dd>
<div class="desc"><p>Create and store ledger payloads for a da template</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>template_record</code></strong> :&ensp;<code>DataAgreementTemplateRecord</code></dt>
<dd>Data agreement template record</dd>
<dt><strong><code>pd_records</code></strong> :&ensp;<code>typing.List[PersonalDataRecord]</code></dt>
<dd>Personal data records</dd>
<dt><strong><code>schema_id</code></strong> :&ensp;<code>str</code></dt>
<dd>Schema identifier if available</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>DataAgreementTemplateRecord</code></dt>
<dd>Record with ledger payloads</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def create_and_store_ledger_payloads_for_da_template(
        self,
        *,
        template_record: DataAgreementTemplateRecord,
        pd_records: typing.List[PersonalDataRecord] = None,
        schema_id: str = None
) -&gt; DataAgreementTemplateRecord:
    &#34;&#34;&#34;Create and store ledger payloads for a da template

    Args:
        template_record (DataAgreementTemplateRecord): Data agreement template record
        pd_records (typing.List[PersonalDataRecord]): Personal data records
        schema_id (str): Schema identifier if available

    Returns:
        DataAgreementTemplateRecord: Record with ledger payloads
    &#34;&#34;&#34;
    if template_record.method_of_use == DataAgreementTemplateRecord.METHOD_OF_USE_DATA_SOURCE:

        # Create schema if not existing
        if not schema_id:
            data_agreement = template_record.data_agreement
            # Schema name
            schema_name = data_agreement.get(&#34;purpose&#34;)
            # Schema version
            schema_version = data_agreement.get(&#34;version&#34;)
            # Schema attributes
            attributes = [
                personal_data.attribute_name
                for personal_data in pd_records
            ]
            # Creata schema and anchor to ledger
            (schema_id, schema_def) = await create_schema_def_and_anchor_to_ledger(
                context=self.context,
                schema_name=schema_name,
                schema_version=schema_version,
                attributes=attributes
            )

        # Create credential definition and anchor to ledger

        (cred_def_id, cred_def, novel) = await create_cred_def_and_anchor_to_ledger(
            context=self.context,
            schema_id=schema_id
        )

        template_record.cred_def_id = cred_def_id
        template_record.schema_id = schema_id
        await template_record.save(self.context)

    else:
        data_agreement = template_record.data_agreement

        # Usage purpose
        usage_purpose = data_agreement.get(&#34;purpose&#34;)

        # Usage purpose description
        usage_purpose_description = data_agreement.get(&#34;purposeDescription&#34;)

        # Data agreement template version
        da_template_version = data_agreement.get(&#34;version&#34;)

        # Create presentation request
        presentation_request = self.construct_presentation_request(
            usage_purpose=usage_purpose,
            usage_purpose_description=usage_purpose_description,
            da_template_version=da_template_version,
            personal_data=pd_records
        )

        template_record.presentation_request = presentation_request
        await template_record.save(self.context)

    return template_record</code></pre>
</details>
</dd>
<dt id="dexa_sdk.managers.ada_manager.V2ADAManager.create_connection_qr_code"><code class="name flex">
<span>async def <span class="ident">create_connection_qr_code</span></span>(<span>self, connection_id: str) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Create connection QR code.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>connection_id</code></strong> :&ensp;<code>str</code></dt>
<dd>Connection identifier.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>Dict with dynamic link.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def create_connection_qr_code(
    self,
    connection_id: str
) -&gt; dict:
    &#34;&#34;&#34;Create connection QR code.

    Args:
        connection_id (str): Connection identifier.

    Returns:
        dict: Dict with dynamic link.
    &#34;&#34;&#34;

    # Connection record.
    connection_record: ConnectionRecord = await ConnectionRecord.retrieve_by_id(
        self.context,
        connection_id
    )

    # Connection invitation
    connection_invitation: ConnectionInvitation = await connection_record.retrieve_invitation(
        self.context
    )

    # Generate firebase dynamic link.
    payload = connection_invitation.to_url()
    firebase_dynamic_link = await generate_firebase_dynamic_link(self.context, payload)

    res = {&#34;dynamic_link&#34;: firebase_dynamic_link}

    return res</code></pre>
</details>
</dd>
<dt id="dexa_sdk.managers.ada_manager.V2ADAManager.create_data_agreement_qr_code"><code class="name flex">
<span>async def <span class="ident">create_data_agreement_qr_code</span></span>(<span>self, template_id: str, multi_use_flag: bool) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Create data agreement qr code</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>template_id</code></strong> :&ensp;<code>str</code></dt>
<dd>Template identifier</dd>
<dt><strong><code>multi_use_flag</code></strong> :&ensp;<code>bool</code></dt>
<dd>Multi use flag</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>Qr code.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def create_data_agreement_qr_code(
    self,
    template_id: str,
    multi_use_flag: bool
) -&gt; dict:
    &#34;&#34;&#34;Create data agreement qr code

    Args:
        template_id (str): Template identifier
        multi_use_flag (bool): Multi use flag

    Returns:
        dict: Qr code.
    &#34;&#34;&#34;

    qr_record = DataAgreementQRCodeRecord(
        template_id=template_id,
        multi_use_flag=bool_to_str(multi_use_flag)
    )
    await qr_record.save(self.context)

    (connection, invitation) = await self.create_invitation(
        auto_accept=True,
        public=False,
        multi_use=multi_use_flag,
        alias=f&#34;DA_{template_id}_QR_{qr_record._id}&#34;
    )

    qr_record.connection_id = connection.connection_id
    await qr_record.save(self.context)

    res = {
        &#34;qr_id&#34;: qr_record._id,
        &#34;invitation&#34;: invitation.serialize()
    }

    res_base64 = base64.b64encode(json.dumps(res).encode()).decode()
    payload = self.context.settings.get(&#34;default_endpoint&#34;) + &#34;?qt=2&amp;qp=&#34; + res_base64

    firebase_dynamic_link = await generate_firebase_dynamic_link(self.context, payload)
    qr_record.dynamic_link = firebase_dynamic_link
    await qr_record.save(self.context)

    res.update({&#34;dynamic_link&#34;: firebase_dynamic_link})

    return res</code></pre>
</details>
</dd>
<dt id="dexa_sdk.managers.ada_manager.V2ADAManager.create_invitation"><code class="name flex">
<span>async def <span class="ident">create_invitation</span></span>(<span>self, my_label: str = None, my_endpoint: str = None, their_role: str = None, auto_accept: bool = None, public: bool = False, multi_use: bool = False, alias: str = None) ‑> Tuple[aries_cloudagent.connections.models.connection_record.ConnectionRecord, aries_cloudagent.protocols.connections.v1_0.messages.connection_invitation.ConnectionInvitation]</span>
</code></dt>
<dd>
<div class="desc"><p>Generate new connection invitation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def create_invitation(
    self,
    my_label: str = None,
    my_endpoint: str = None,
    their_role: str = None,
    auto_accept: bool = None,
    public: bool = False,
    multi_use: bool = False,
    alias: str = None,
) -&gt; typing.Tuple[ConnectionRecord, ConnectionInvitation]:
    &#34;&#34;&#34;Generate new connection invitation.&#34;&#34;&#34;

    if not my_label:
        my_label = self.context.settings.get(&#34;default_label&#34;)

    image_url = None

    # Fetch organisation details from intermediary.
    org_details = await fetch_org_details_from_intermediary(
        self.context
    )

    my_label = org_details[&#34;Name&#34;]
    image_url = org_details[&#34;LogoImageURL&#34;] + &#34;/web&#34;

    wallet: BaseWallet = await self.context.inject(BaseWallet)

    if public:
        if not self.context.settings.get(&#34;public_invites&#34;):
            raise ConnectionManagerError(
                &#34;Public invitations are not enabled&#34;)

        public_did = await wallet.get_public_did()
        if not public_did:
            raise ConnectionManagerError(
                &#34;Cannot create public invitation with no public DID&#34;
            )

        if multi_use:
            raise ConnectionManagerError(
                &#34;Cannot use public and multi_use at the same time&#34;
            )

        # FIXME - allow ledger instance to format public DID with prefix?
        invitation = ConnectionInvitation(
            label=my_label, did=f&#34;did:sov:{public_did.did}&#34;, image_url=image_url
        )
        return None, invitation

    invitation_mode = ConnectionRecord.INVITATION_MODE_ONCE
    if multi_use:
        invitation_mode = ConnectionRecord.INVITATION_MODE_MULTI

    if not my_endpoint:
        my_endpoint = self.context.settings.get(&#34;default_endpoint&#34;)
    accept = (
        ConnectionRecord.ACCEPT_AUTO
        if (
            auto_accept
            or (
                auto_accept is None
                and self.context.settings.get(&#34;debug.auto_accept_requests&#34;)
            )
        )
        else ConnectionRecord.ACCEPT_MANUAL
    )

    # Create and store new invitation key
    connection_key = await wallet.create_signing_key()

    # Create connection record
    connection = ConnectionRecord(
        initiator=ConnectionRecord.INITIATOR_SELF,
        invitation_key=connection_key.verkey,
        their_role=their_role,
        state=ConnectionRecord.STATE_INVITATION,
        accept=accept,
        invitation_mode=invitation_mode,
        alias=alias,
    )

    await connection.save(self.context, reason=&#34;Created new invitation&#34;)

    # Create connection invitation message
    # Note: Need to split this into two stages to support inbound routing of invites
    # Would want to reuse create_did_document and convert the result
    invitation = ConnectionInvitation(
        label=my_label, recipient_keys=[
            connection_key.verkey], endpoint=my_endpoint, image_url=image_url
    )
    await connection.attach_invitation(self.context, invitation)

    return connection, invitation</code></pre>
</details>
</dd>
<dt id="dexa_sdk.managers.ada_manager.V2ADAManager.delete_da_instance_by_data_ex_id"><code class="name flex">
<span>async def <span class="ident">delete_da_instance_by_data_ex_id</span></span>(<span>self, cred_ex_id: str) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Delete da instance by cred ex id.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>cred_ex_id</code></strong> :&ensp;<code>str</code></dt>
<dd>Credential exchange identifier.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def delete_da_instance_by_data_ex_id(
    self,
    cred_ex_id: str
) -&gt; None:
    &#34;&#34;&#34;Delete da instance by cred ex id.

    Args:
        cred_ex_id (str): Credential exchange identifier.
    &#34;&#34;&#34;

    # Data agreement instance
    instance = await DataAgreementInstanceRecord.fetch_by_data_ex_id(
        self.context,
        cred_ex_id
    )

    await instance.delete_record(self.context)</code></pre>
</details>
</dd>
<dt id="dexa_sdk.managers.ada_manager.V2ADAManager.delete_da_template_in_wallet"><code class="name flex">
<span>async def <span class="ident">delete_da_template_in_wallet</span></span>(<span>self, template_id: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Deactivate DA template in wallet.</p>
<p>This is not a normal delete operation of a specific version of template. Instead it
marks the template with latest version flag as deleted i.e. Any version under this
template is no longer active.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>template_id</code></strong> :&ensp;<code>str</code></dt>
<dd>Template identifier</dd>
<dt><strong><code>template_version</code></strong> :&ensp;<code>str</code></dt>
<dd>Template version</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>record_id</code></dt>
<dd>Record identifier for the deleted template.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def delete_da_template_in_wallet(self, template_id: str) -&gt; str:
    &#34;&#34;&#34;Deactivate DA template in wallet.

    This is not a normal delete operation of a specific version of template. Instead it
    marks the template with latest version flag as deleted i.e. Any version under this
    template is no longer active.

    Args:
        template_id (str): Template identifier
        template_version (str): Template version

    Returns:
        record_id: Record identifier for the deleted template.
    &#34;&#34;&#34;
    # Query for the data agreement by id
    data_agreement_records: DataAgreementTemplateRecord = \
        await DataAgreementTemplateRecord.non_deleted_template_by_id(
            self.context,
            template_id
        )

    assert data_agreement_records, &#34;Data agreement template not found.&#34;
    data_agreement_record = data_agreement_records[0]

    # Mark the data agreement as deleted and save.
    return await data_agreement_record.delete_template(self.context)</code></pre>
</details>
</dd>
<dt id="dexa_sdk.managers.ada_manager.V2ADAManager.delete_data_agreement_qr_code"><code class="name flex">
<span>async def <span class="ident">delete_data_agreement_qr_code</span></span>(<span>self, template_id: str, qr_id: str) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Delete data agreement qr code.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def delete_data_agreement_qr_code(
    self,
    template_id: str,
    qr_id: str
) -&gt; None:
    &#34;&#34;&#34;Delete data agreement qr code.&#34;&#34;&#34;
    record = await DataAgreementQRCodeRecord.retrieve_by_id(self.context, qr_id)
    assert record.template_id == template_id, &#34;Data agreement not found.&#34;
    await record.delete_record(self.context)</code></pre>
</details>
</dd>
<dt id="dexa_sdk.managers.ada_manager.V2ADAManager.delete_personal_data"><code class="name flex">
<span>async def <span class="ident">delete_personal_data</span></span>(<span>self, attribute_id: str) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Delete personal data record.</p>
<p>On deleting personal data record, the associated data agreement template is
updated. If the personal data record deleted, is the last one in the template,
proceed to delete the template record.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>attribute_id</code></strong> :&ensp;<code>str</code></dt>
<dd><em>description</em></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def delete_personal_data(self, attribute_id: str) -&gt; None:
    &#34;&#34;&#34;Delete personal data record.

    On deleting personal data record, the associated data agreement template is
    updated. If the personal data record deleted, is the last one in the template,
    proceed to delete the template record.

    Args:
        attribute_id (str): _description_
    &#34;&#34;&#34;

    # Fetch personal data record by id
    pd_record: PersonalDataRecord = await PersonalDataRecord.retrieve_by_id(
        self.context,
        attribute_id
    )

    # Fetch the associated data agreement record
    da_template_record: DataAgreementTemplateRecord = \
        await DataAgreementTemplateRecord.latest_template_by_id(
            self.context,
            pd_record.data_agreement_template_id
        )

    assert da_template_record, &#34;Matching data agreement template not found.&#34;
    assert da_template_record.template_version == \
        pd_record.data_agreement_template_version, \
        &#34;Matching data agreement template with same version not found.&#34;

    da: DataAgreementModel = DataAgreementModel.deserialize(da_template_record.data_agreement)

    # Iterate through the existing personal data in data agreements
    # And remove the deleted personal data.
    da_pds = []
    for da_pd in da.personal_data:
        if da_pd.attribute_id != pd_record.attribute_id:
            da_pd.attribute_id = None
            da_pds.append(da_pd)

    da.personal_data = da_pds

    if len(da_pds) == 0:
        await da_template_record.delete_template(self.context)
    else:
        # Update template record with new agreement.
        await self.update_and_store_da_template_in_wallet(
            pd_record.data_agreement_template_id,
            da.serialize(),
            publish_flag=str_to_bool(da_template_record.publish_flag)
        )</code></pre>
</details>
</dd>
<dt id="dexa_sdk.managers.ada_manager.V2ADAManager.get_existing_connection_record_for_new_connection_id"><code class="name flex">
<span>async def <span class="ident">get_existing_connection_record_for_new_connection_id</span></span>(<span>self, connection_id: str) ‑> <a title="dexa_sdk.connections.records.existing_connections_record.ExistingConnectionRecord" href="../connections/records/existing_connections_record.html#dexa_sdk.connections.records.existing_connections_record.ExistingConnectionRecord">ExistingConnectionRecord</a></span>
</code></dt>
<dd>
<div class="desc"><p>Get existing connection record for new connection id.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>connection_id</code></strong> :&ensp;<code>str</code></dt>
<dd>Connection id.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ExistingConnectionRecord</code></dt>
<dd>Existing connection record.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_existing_connection_record_for_new_connection_id(
    self,
    connection_id: str
) -&gt; ExistingConnectionRecord:
    &#34;&#34;&#34;Get existing connection record for new connection id.

    Args:
        connection_id (str): Connection id.

    Returns:
        ExistingConnectionRecord: Existing connection record.
    &#34;&#34;&#34;

    # Tag filter.
    tag_filter = {
        &#34;connection_id&#34;: connection_id
    }

    # Fetch existing connection records.
    existing_connection_records = await ExistingConnectionRecord.query(
        self.context,
        tag_filter
    )

    res = None
    if existing_connection_records:
        res = existing_connection_records[0]

    return res</code></pre>
</details>
</dd>
<dt id="dexa_sdk.managers.ada_manager.V2ADAManager.process_da_negotiation_receipt_message"><code class="name flex">
<span>async def <span class="ident">process_da_negotiation_receipt_message</span></span>(<span>self, message: mydata_did.v1_0.messages.da_negotiation_receipt.DataAgreementNegotiationReceiptMessage, message_receipt: aries_cloudagent.transport.inbound.receipt.MessageReceipt)</span>
</code></dt>
<dd>
<div class="desc"><p>Process DA negotiation receipt message.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>message</code></strong> :&ensp;<code>DataAgreementNegotiationReceiptMessage</code></dt>
<dd>DA negotiation receipt message.</dd>
<dt><strong><code>message_receipt</code></strong> :&ensp;<code>MessageReceipt</code></dt>
<dd>Message receipt.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def process_da_negotiation_receipt_message(
    self,
    message: DataAgreementNegotiationReceiptMessage,
    message_receipt: MessageReceipt
):
    &#34;&#34;&#34;Process DA negotiation receipt message.

    Args:
        message (DataAgreementNegotiationReceiptMessage): DA negotiation receipt message.
        message_receipt (MessageReceipt): Message receipt.
    &#34;&#34;&#34;

    instance_id = message.body.instance_id
    blockchain_receipt = message.body.blockchain_receipt
    blink = message.body.blink
    mydata_did = message.body.mydata_did

    # Fetch the DDA instance record.
    tag_filter = {
        &#34;instance_id&#34;: instance_id
    }
    instance_record: DataAgreementInstanceRecord = \
        await DataAgreementInstanceRecord.retrieve_by_tag_filter(
            self.context,
            tag_filter
        )

    # Update instance record.
    instance_record.blockchain_receipt = blockchain_receipt
    instance_record.blink = blink
    instance_record.mydata_did = mydata_did

    await instance_record.save(self.context)</code></pre>
</details>
</dd>
<dt id="dexa_sdk.managers.ada_manager.V2ADAManager.process_data_agreement_qr_code_initiate_message"><code class="name flex">
<span>async def <span class="ident">process_data_agreement_qr_code_initiate_message</span></span>(<span>self, message: mydata_did.v1_0.messages.data_agreement_qr_code_initiate.DataAgreementQrCodeInitiateMessage, receipt: aries_cloudagent.transport.inbound.receipt.MessageReceipt)</span>
</code></dt>
<dd>
<div class="desc"><p>Process data QR code initiate message.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>message</code></strong> :&ensp;<code>DataAgreementQrCodeInitiateMessage</code></dt>
<dd>Data agreement QR code initiate message.</dd>
<dt><strong><code>receipt</code></strong> :&ensp;<code>MessageReceipt</code></dt>
<dd>Message receipt.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def process_data_agreement_qr_code_initiate_message(
    self,
    message: DataAgreementQrCodeInitiateMessage,
    receipt: MessageReceipt
):
    &#34;&#34;&#34;Process data QR code initiate message.

    Args:
        message (DataAgreementQrCodeInitiateMessage): Data agreement QR code initiate message.
        receipt (MessageReceipt): Message receipt.
    &#34;&#34;&#34;
    qr_id = message.body.qr_id
    connection_id = self.context.connection_record.connection_id

    connection_record = await ConnectionRecord.retrieve_by_id(self.context, connection_id)

    # Fetch the qr code record.
    record: DataAgreementQRCodeRecord = \
        await DataAgreementQRCodeRecord.retrieve_by_id(
            self.context,
            qr_id
        )

    if record._multi_use_flag:
        record._scanned_flag = True
        await record.save(self.context)
    else:
        if record._scanned_flag:
            explain = &#34;Qr code cannot be scanned twice&#34;
            await self.send_problem_report_message(explain, connection_id)
            raise Exception(explain)

    # Fetch data agreement template record.
    template_record: DataAgreementTemplateRecord = \
        await DataAgreementTemplateRecord.latest_template_by_id(
            self.context,
            record.template_id
        )

    # Construct presentation request
    preset_presentation_request = template_record.presentation_request
    comment = preset_presentation_request.pop(&#34;comment&#34;)
    if not preset_presentation_request.get(&#34;nonce&#34;):
        preset_presentation_request[&#34;nonce&#34;] = await generate_pr_nonce()

    presentation_request = PresentationRequest(
        comment=comment,
        request_presentations_attach=[
            AttachDecorator.from_indy_dict(
                indy_dict=preset_presentation_request,
                ident=ATTACH_DECO_IDS[PRESENTATION_REQUEST],
            )
        ],
    )

    # Construct presentation exchange record
    presentation_manager = PresentationManager(self.context)
    (pres_ex_record) = await presentation_manager.create_exchange_for_request(
        connection_id=self.context.connection_record.connection_id,
        presentation_request_message=presentation_request,
    )

    # Update qr code with record id.
    record.data_ex_id = pres_ex_record.presentation_exchange_id
    await record.save(self.context)

    offer_message = await self.build_data_agreement_offer_for_presentation_exchange(
        template_record.template_id,
        connection_record,
        pres_ex_record
    )

    # Add data agreement context decorator
    presentation_request._decorators[&#34;data-agreement-context&#34;] = DataAgreementContextDecorator(
        message_type=&#34;protocol&#34;,
        message=offer_message.serialize()
    )

    pres_ex_record.presentation_request_dict = presentation_request.serialize()
    pres_ex_record.template_id = template_record.template_id
    await pres_ex_record.save(self.context)

    await self.send_reply_message(presentation_request, connection_id)</code></pre>
</details>
</dd>
<dt id="dexa_sdk.managers.ada_manager.V2ADAManager.process_data_controller_details_message"><code class="name flex">
<span>async def <span class="ident">process_data_controller_details_message</span></span>(<span>self, message: mydata_did.v1_0.messages.data_controller_details.DataControllerDetailsMessage, receipt: aries_cloudagent.transport.inbound.receipt.MessageReceipt)</span>
</code></dt>
<dd>
<div class="desc"><p>Process data controller details message.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>message</code></strong> :&ensp;<code>DataControllerDetailsMessage</code></dt>
<dd>Data controller details message.</dd>
<dt><strong><code>receipt</code></strong> :&ensp;<code>MessageReceipt</code></dt>
<dd>Message receipt.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def process_data_controller_details_message(
    self,
    message: DataControllerDetailsMessage,
    receipt: MessageReceipt
):
    &#34;&#34;&#34;Process data controller details message.

    Args:
        message (DataControllerDetailsMessage): Data controller details message.
        receipt (MessageReceipt): Message receipt.
    &#34;&#34;&#34;

    # Query controller records.
    records = await ControllerDetailsRecord.query(self.context, {})

    connection_id = self.context.connection_record.connection_id

    if not records:
        wallet: BaseWallet = await self.context.inject(BaseWallet)
        controller_did = await wallet.get_public_did()

        cache: BaseCache = await self.context.inject(BaseCache, required=False)
        cache_key = f&#34;did:sov:{controller_did.did}&#34;

        assert cache, &#34;Cache not available.&#34;

        controller_details = None
        async with cache.acquire(cache_key) as entry:
            if entry.result:
                cached = entry.result
                controller_details = DataController.deserialize(cached)
            else:
                org_details = await fetch_org_details_from_intermediary(self.context)

                # Organisation did
                organisation_did = f&#34;did:sov:{controller_did.did}&#34;

                controller_details = DataController(
                    organisation_did=organisation_did,
                    organisation_name=org_details[&#34;Name&#34;],
                    cover_image_url=org_details[&#34;CoverImageURL&#34;] + &#34;/web&#34;,
                    logo_image_url=org_details[&#34;LogoImageURL&#34;] + &#34;/web&#34;,
                    location=org_details[&#34;Location&#34;],
                    organisation_type=org_details[&#34;Type&#34;][&#34;Type&#34;],
                    description=org_details[&#34;Description&#34;],
                    policy_url=org_details[&#34;PolicyURL&#34;],
                    eula_url=org_details[&#34;EulaURL&#34;]
                )
                cache_val = controller_details.serialize()
                await entry.set_result(cache_val, 3600)

            response_message = DataControllerDetailsResponseMessage(
                body=controller_details
            )

            await self.send_reply_message(response_message, connection_id)
    else:
        # If found update record.
        record: ControllerDetailsRecord = records[0]

        controller_details = DataController(
            organisation_did=record.organisation_did,
            organisation_name=record.organisation_name,
            cover_image_url=record.cover_image_url,
            logo_image_url=record.logo_image_url,
            location=record.location,
            organisation_type=record.organisation_type,
            description=record.description,
            policy_url=record.policy_url,
            eula_url=record.eula_url
        )

        response_message = DataControllerDetailsResponseMessage(
            body=controller_details
        )

        await self.send_reply_message(response_message, connection_id)</code></pre>
</details>
</dd>
<dt id="dexa_sdk.managers.ada_manager.V2ADAManager.process_decorator_with_da_accept_message"><code class="name flex">
<span>async def <span class="ident">process_decorator_with_da_accept_message</span></span>(<span>self, decorator_set: aries_cloudagent.messaging.decorators.default.DecoratorSet, data_ex_record: Union[aries_cloudagent.protocols.issue_credential.v1_0.models.credential_exchange.V10CredentialExchange, aries_cloudagent.protocols.present_proof.v1_0.models.presentation_exchange.V10PresentationExchange], connection_record: aries_cloudagent.connections.models.connection_record.ConnectionRecord) ‑> <a title="dexa_sdk.agreements.da.v1_0.records.da_instance_record.DataAgreementInstanceRecord" href="../agreements/da/v1_0/records/da_instance_record.html#dexa_sdk.agreements.da.v1_0.records.da_instance_record.DataAgreementInstanceRecord">DataAgreementInstanceRecord</a></span>
</code></dt>
<dd>
<div class="desc"><p>Process data agreement context decorator with DA accept message</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>decorator_set</code></strong> :&ensp;<code>DecoratorSet</code></dt>
<dd>Decorator set</dd>
<dt>data_ex_record (typing.Union[V10CredentialExchange, V10PresentationExchange]):</dt>
<dt>Data exchange record.</dt>
<dt><strong><code>connection_record</code></strong> :&ensp;<code>ConnectionRecord</code></dt>
<dd>Connection record</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>DataAgreementInstanceRecord</code></dt>
<dd>Data agreement instance record.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def process_decorator_with_da_accept_message(
    self,
    decorator_set: DecoratorSet,
    data_ex_record: typing.Union[V10CredentialExchange, V10PresentationExchange],
    connection_record: ConnectionRecord
) -&gt; DataAgreementInstanceRecord:
    &#34;&#34;&#34;Process data agreement context decorator with DA accept message

    Args:
        decorator_set (DecoratorSet): Decorator set
        data_ex_record (typing.Union[V10CredentialExchange, V10PresentationExchange]):
            Data exchange record.
        connection_record (ConnectionRecord): Connection record

    Returns:
        DataAgreementInstanceRecord: Data agreement instance record.
    &#34;&#34;&#34;

    # Check if data agreement context decorator is present
    if &#34;data-agreement-context&#34; not in decorator_set.keys():
        self._logger.info(
            &#34;Data agreement context decorator is not present in the incoming message.&#34;)
        return None

    # Deserialize data agreement context decorator
    da_decorator_dict = decorator_set[&#34;data-agreement-context&#34;]
    da_decorator_model: DataAgreementContextDecorator = \
        DataAgreementContextDecorator.deserialize(da_decorator_dict)

    assert da_decorator_model.message_type == &#34;protocol&#34;, \
        &#34;DA context message type must be &#39;protocol&#39;.&#34;

    message_type = da_decorator_model.message.get(&#34;@type&#34;)
    assert DATA_AGREEMENT_NEGOTIATION_ACCEPT in message_type, \
        f&#34;DA context protocol message type must be &#39;{DATA_AGREEMENT_NEGOTIATION_ACCEPT}&#39;&#34;

    da_accept_message: DataAgreementNegotiationAcceptMessage = \
        DataAgreementNegotiationAcceptMessage.deserialize(da_decorator_model.message)

    # Build and save data agreement instance record.
    if data_ex_record.__class__.__name__ == V10CredentialExchange.__name__:
        # Build and save data agreement instance record.
        instance_record = await DataAgreementInstanceRecord.update_instance_from_da_accept(
            self.context,
            da_accept_message,
            data_ex_record.credential_exchange_id
        )
    else:
        # Build and save data agreement instance record.
        instance_record = await DataAgreementInstanceRecord.update_instance_from_da_accept(
            self.context,
            da_accept_message,
            data_ex_record.presentation_exchange_id
        )

    # Anchor da to blockchain.
    await self.anchor_da_instance_to_blockchain_async_task(instance_record.instance_id)

    return instance_record</code></pre>
</details>
</dd>
<dt id="dexa_sdk.managers.ada_manager.V2ADAManager.process_decorator_with_da_offer_message"><code class="name flex">
<span>async def <span class="ident">process_decorator_with_da_offer_message</span></span>(<span>self, decorator_set: aries_cloudagent.messaging.decorators.default.DecoratorSet, data_ex_record: Union[aries_cloudagent.protocols.issue_credential.v1_0.models.credential_exchange.V10CredentialExchange, aries_cloudagent.protocols.present_proof.v1_0.models.presentation_exchange.V10PresentationExchange], connection_record: aries_cloudagent.connections.models.connection_record.ConnectionRecord) ‑> <a title="dexa_sdk.agreements.da.v1_0.records.da_instance_record.DataAgreementInstanceRecord" href="../agreements/da/v1_0/records/da_instance_record.html#dexa_sdk.agreements.da.v1_0.records.da_instance_record.DataAgreementInstanceRecord">DataAgreementInstanceRecord</a></span>
</code></dt>
<dd>
<div class="desc"><p>Process data agreement context decorator with DA offer message</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>decorator_set</code></strong> :&ensp;<code>DecoratorSet</code></dt>
<dd>Decorator set</dd>
<dt><strong><code>cred_ex_record</code></strong> :&ensp;<code>V10CredentialExchange</code></dt>
<dd>Credential exchange record</dd>
<dt><strong><code>connection_record</code></strong> :&ensp;<code>ConnectionRecord</code></dt>
<dd>Connection record</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>DataAgreementInstanceRecord</code></dt>
<dd>Data agreement instance record.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def process_decorator_with_da_offer_message(
    self,
    decorator_set: DecoratorSet,
    data_ex_record: typing.Union[V10CredentialExchange, V10PresentationExchange],
    connection_record: ConnectionRecord
) -&gt; DataAgreementInstanceRecord:
    &#34;&#34;&#34;Process data agreement context decorator with DA offer message

    Args:
        decorator_set (DecoratorSet): Decorator set
        cred_ex_record (V10CredentialExchange): Credential exchange record
        connection_record (ConnectionRecord): Connection record

    Returns:
        DataAgreementInstanceRecord: Data agreement instance record.
    &#34;&#34;&#34;

    # Check if data agreement context decorator is present
    if &#34;data-agreement-context&#34; not in decorator_set.keys():
        self._logger.info(
            &#34;Data agreement context decorator is not present in the incoming message.&#34;)
        return None

    # Deserialize data agreement context decorator
    da_decorator_dict = decorator_set[&#34;data-agreement-context&#34;]
    da_decorator_model: DataAgreementContextDecorator = \
        DataAgreementContextDecorator.deserialize(da_decorator_dict)

    assert da_decorator_model.message_type == &#34;protocol&#34;, \
        &#34;DA context message type must be &#39;protocol&#39;.&#34;

    message_type = da_decorator_model.message.get(&#34;@type&#34;)
    assert DATA_AGREEMENT_NEGOTIATION_OFFER in message_type, \
        f&#34;DA context protocol message type must be &#39;{DATA_AGREEMENT_NEGOTIATION_OFFER}&#39;&#34;

    da_offer_message: DataAgreementNegotiationOfferMessage = \
        DataAgreementNegotiationOfferMessage.deserialize(da_decorator_model.message)

    # Build and save data agreement instance record.
    if data_ex_record.__class__.__name__ == V10CredentialExchange.__name__:
        return await DataAgreementInstanceRecord.build_instance_from_da_offer(
            self.context,
            da_offer_message,
            connection_record,
            data_ex_record.credential_exchange_id
        )
    else:
        return await DataAgreementInstanceRecord.build_instance_from_da_offer(
            self.context,
            da_offer_message,
            connection_record,
            data_ex_record.presentation_exchange_id
        )</code></pre>
</details>
</dd>
<dt id="dexa_sdk.managers.ada_manager.V2ADAManager.process_existing_connections_message"><code class="name flex">
<span>async def <span class="ident">process_existing_connections_message</span></span>(<span>self, message: mydata_did.v1_0.messages.existing_connections.ExistingConnectionsMessage, message_receipt: aries_cloudagent.transport.inbound.receipt.MessageReceipt)</span>
</code></dt>
<dd>
<div class="desc"><p>Process existing connections message.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>message</code></strong> :&ensp;<code>ExistingConnectionsMessage</code></dt>
<dd>Existing connections message.</dd>
<dt><strong><code>message_receipt</code></strong> :&ensp;<code>MessageReceipt</code></dt>
<dd>Message receipt.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def process_existing_connections_message(
    self,
    message: ExistingConnectionsMessage,
    message_receipt: MessageReceipt
):
    &#34;&#34;&#34;Process existing connections message.

    Args:
        message (ExistingConnectionsMessage): Existing connections message.
        message_receipt (MessageReceipt): Message receipt.
    &#34;&#34;&#34;

    # Invitation key.
    invitation_key = message_receipt.recipient_verkey

    # Fetch current connection record using invitation key
    connection_record = await ConnectionRecord.retrieve_by_invitation_key(
        self.context,
        invitation_key
    )

    # Fetch existing connections record for the current connection.
    tag_filter = {
        &#34;connection_id&#34;: connection_record.connection_id
    }
    existing_connection_records = await ExistingConnectionRecord.query(
        self.context,
        tag_filter
    )

    if existing_connection_records:
        # Existing connection record.
        existing_connection_record: ExistingConnectionRecord = existing_connection_records[0]

        # Delete the record.
        await existing_connection_record.delete_record(self.context)

    # Fetch associated connection record.
    old_connection_record = await ConnectionRecord.retrieve_by_did(
        self.context,
        their_did=None,
        my_did=message.body.theirdid
    )

    # Create a new existing connection record.
    existing_connection_record = ExistingConnectionRecord(
        existing_connection_id=old_connection_record.connection_id,
        my_did=old_connection_record.my_did,
        connection_status=&#34;available&#34;,
        connection_id=connection_record.connection_id
    )

    await existing_connection_record.save(self.context)

    # updating the current connection invitation status to inactive
    connection_record.state = ConnectionRecord.STATE_INACTIVE
    await connection_record.save(context=self.context)</code></pre>
</details>
</dd>
<dt id="dexa_sdk.managers.ada_manager.V2ADAManager.publish_da_template_in_wallet"><code class="name flex">
<span>async def <span class="ident">publish_da_template_in_wallet</span></span>(<span>self, template_id: str) ‑> <a title="dexa_sdk.agreements.da.v1_0.records.da_template_record.DataAgreementTemplateRecord" href="../agreements/da/v1_0/records/da_template_record.html#dexa_sdk.agreements.da.v1_0.records.da_template_record.DataAgreementTemplateRecord">DataAgreementTemplateRecord</a></span>
</code></dt>
<dd>
<div class="desc"><p>Publish data agreement template.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>template_id</code></strong> :&ensp;<code>str</code></dt>
<dd>Template identifier</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>DataAgreementTemplateRecord</code></dt>
<dd>Template record.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def publish_da_template_in_wallet(self,
                                        template_id: str) -&gt; DataAgreementTemplateRecord:
    &#34;&#34;&#34;Publish data agreement template.

    Args:
        template_id (str): Template identifier

    Returns:
        DataAgreementTemplateRecord: Template record.
    &#34;&#34;&#34;

    tag_filter = {
        &#34;delete_flag&#34;: bool_to_str(False),
        &#34;publish_flag&#34;: bool_to_str(False),
        &#34;latest_version_flag&#34;: bool_to_str(True),
        &#34;template_id&#34;: template_id
    }

    records = await DataAgreementTemplateRecord.query(
        context=self.context,
        tag_filter=tag_filter
    )

    assert records, &#34;Data agreement template not found.&#34;

    record: DataAgreementTemplateRecord = records[0]

    await record.publish_template(self.context)

    pd_records = await record.fetch_personal_data_records(self.context)

    # Create ledger payloads
    record = await self.create_and_store_ledger_payloads_for_da_template(
        template_record=record,
        pd_records=pd_records,
        schema_id=record.schema_id
    )

    return record</code></pre>
</details>
</dd>
<dt id="dexa_sdk.managers.ada_manager.V2ADAManager.query_connections_and_categorise_results"><code class="name flex">
<span>async def <span class="ident">query_connections_and_categorise_results</span></span>(<span>self, tag_filter: dict = None, post_filter_positive: dict = None, page: int = 1, page_size: int = 10, org_flag: bool = False, marketplace_flag: bool = False) ‑> <a title="dexa_sdk.utils.utils.PaginationResult" href="../utils/utils.html#dexa_sdk.utils.utils.PaginationResult">PaginationResult</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def query_connections_and_categorise_results(
    self,
    tag_filter: dict = None,
    post_filter_positive: dict = None,
    page: int = 1,
    page_size: int = 10,
    org_flag: bool = False,
    marketplace_flag: bool = False,
) -&gt; PaginationResult:

    # Query the connection records.
    records = await ConnectionRecord.query(
        self.context,
        tag_filter,
        post_filter_positive
    )

    # Sort the connection records.
    records = sorted(
        records,
        key=lambda k: k.created_at,
        reverse=True
    )

    res = []
    for record in records:
        tag_filter = {&#34;connection_id&#34;: record.connection_id}

        # Fetch controller details attached to the connection.
        controller_details: typing.List[ConnectionControllerDetailsRecord] = \
            await ConnectionControllerDetailsRecord.query(
            self.context,
            tag_filter
        )

        # Fetch marketplace connection record.
        marketplace_connections: typing.List[MarketplaceConnectionRecord] = \
            await MarketplaceConnectionRecord.query(
            self.context,
            tag_filter
        )

        connection = record.serialize()

        # Update controller details to the connection dict.
        if controller_details:
            connection.update({
                &#34;org_flag&#34;: True,
                &#34;controller_details&#34;: controller_details[0].controller_details
            })
        else:
            connection.update({
                &#34;controller_details&#34;: {},
                &#34;org_flag&#34;: False
            })

        if marketplace_connections:
            connection.update({
                &#34;marketplace_flag&#34;: True
            })
        else:
            connection.update({&#34;marketplace_flag&#34;: False})

        # Apply category filter on connections.
        categorise_filter = {
            &#34;org_flag&#34;: org_flag,
            &#34;marketplace_flag&#34;: marketplace_flag
        }

        categorise_filter = drop_none_dict(categorise_filter)

        if match_post_filter(connection, categorise_filter, True):
            res.append(connection)

    pagination_result = paginate(res, page if page else 1, page_size if page_size else 10)

    return pagination_result</code></pre>
</details>
</dd>
<dt id="dexa_sdk.managers.ada_manager.V2ADAManager.query_da_templates_in_wallet"><code class="name flex">
<span>async def <span class="ident">query_da_templates_in_wallet</span></span>(<span>self, *, template_id: str = None, delete_flag: str = 'false', method_of_use: str = None, publish_flag: str = 'true', template_version: str = None, latest_version_flag: str = 'true', third_party_data_sharing: str = 'false', page: int = 1, page_size: int = 10) ‑> <a title="dexa_sdk.utils.utils.PaginationResult" href="../utils/utils.html#dexa_sdk.utils.utils.PaginationResult">PaginationResult</a></span>
</code></dt>
<dd>
<div class="desc"><p>Query DA templates in wallet</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>template_id</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Template identifier. Defaults to None.</dd>
<dt><strong><code>delete_flag</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Delete flag. Defaults to false.</dd>
<dt><strong><code>method_of_use</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Method of use. Defaults to None.</dd>
<dt><strong><code>publish_flag</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Publish flag. Defaults to true.</dd>
<dt><strong><code>latest_version_flag</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Latest version flag. Defaults to true.</dd>
<dt><strong><code>template_version</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Template version. Defaults to None.</dd>
<dt><strong><code>third_party_data_sharing</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Third party data sharing.
Defaults to false.</dd>
<dt><strong><code>page</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Page. Defaults to 1.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>PaginationResult</code></dt>
<dd>Pagination results.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def query_da_templates_in_wallet(
        self,
        *,
        template_id: str = None,
        delete_flag: str = &#34;false&#34;,
        method_of_use: str = None,
        publish_flag: str = &#34;true&#34;,
        template_version: str = None,
        latest_version_flag: str = &#34;true&#34;,
        third_party_data_sharing: str = &#34;false&#34;,
        page: int = 1,
        page_size: int = 10,
) -&gt; PaginationResult:
    &#34;&#34;&#34;Query DA templates in wallet

    Args:
        template_id (str, optional): Template identifier. Defaults to None.
        delete_flag (str, optional): Delete flag. Defaults to false.
        method_of_use (str, optional): Method of use. Defaults to None.
        publish_flag (str, optional): Publish flag. Defaults to true.
        latest_version_flag (str, optional): Latest version flag. Defaults to true.
        template_version (str, optional): Template version. Defaults to None.
        third_party_data_sharing (str, optional): Third party data sharing.
            Defaults to false.
        page (int, optional): Page. Defaults to 1.

    Returns:
        PaginationResult: Pagination results.
    &#34;&#34;&#34;

    # Query by version is only possible if the template id is provided
    if template_version:
        assert template_id, &#34;Template identifier is required to query by version&#34;

    # Tag filter
    tag_filter = {
        &#34;delete_flag&#34;: delete_flag,
        &#34;publish_flag&#34;: publish_flag,
        &#34;method_of_use&#34;: method_of_use,
        &#34;template_id&#34;: template_id,
        &#34;template_version&#34;: template_version,
        &#34;latest_version_flag&#34;: latest_version_flag,
        &#34;third_party_data_sharing&#34;: third_party_data_sharing
    }

    tag_filter = drop_none_dict(tag_filter)

    records = await DataAgreementTemplateRecord.query(
        context=self.context,
        tag_filter=tag_filter
    )

    records = sorted(records, key=lambda k: k.created_at, reverse=True)

    paginate_result = paginate_records(records, page, page_size)

    return paginate_result</code></pre>
</details>
</dd>
<dt id="dexa_sdk.managers.ada_manager.V2ADAManager.query_data_agreement_instances"><code class="name flex">
<span>async def <span class="ident">query_data_agreement_instances</span></span>(<span>self, instance_id: str, template_id: str, template_version: str, method_of_use: str, third_party_data_sharing: str, data_ex_id: str, data_subject_did: str, page: int = 1, page_size: int = 10) ‑> <a title="dexa_sdk.utils.utils.PaginationResult" href="../utils/utils.html#dexa_sdk.utils.utils.PaginationResult">PaginationResult</a></span>
</code></dt>
<dd>
<div class="desc"><p>Query data agreement instances</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>instance_id</code></strong> :&ensp;<code>str</code></dt>
<dd>Instance identifier</dd>
<dt><strong><code>template_id</code></strong> :&ensp;<code>str</code></dt>
<dd>Template identifier</dd>
<dt><strong><code>template_version</code></strong> :&ensp;<code>str</code></dt>
<dd>Template version</dd>
<dt><strong><code>method_of_use</code></strong> :&ensp;<code>str</code></dt>
<dd>Method of use</dd>
<dt><strong><code>third_party_data_sharing</code></strong> :&ensp;<code>str</code></dt>
<dd>Third party data sharing</dd>
<dt><strong><code>data_ex_id</code></strong> :&ensp;<code>str</code></dt>
<dd>Data exchange id</dd>
<dt><strong><code>data_subject_did</code></strong> :&ensp;<code>str</code></dt>
<dd>Data subject did</dd>
<dt><strong><code>page</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Page. Defaults to 1.</dd>
<dt><strong><code>page_size</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Page size. Defaults to 10.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>PaginationResult</code></dt>
<dd>Pagination result</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def query_data_agreement_instances(
    self,
    instance_id: str,
    template_id: str,
    template_version: str,
    method_of_use: str,
    third_party_data_sharing: str,
    data_ex_id: str,
    data_subject_did: str,
    page: int = 1,
    page_size: int = 10
) -&gt; PaginationResult:
    &#34;&#34;&#34;Query data agreement instances

    Args:
        instance_id (str): Instance identifier
        template_id (str): Template identifier
        template_version (str): Template version
        method_of_use (str): Method of use
        third_party_data_sharing (str): Third party data sharing
        data_ex_id (str): Data exchange id
        data_subject_did (str): Data subject did
        page (int, optional): Page. Defaults to 1.
        page_size (int, optional): Page size. Defaults to 10.

    Returns:
        PaginationResult: Pagination result
    &#34;&#34;&#34;
    # Query by version is only possible if the template id is provided
    if template_version:
        assert template_id, &#34;Template identifier is required to query by version&#34;

    # Tag filter
    tag_filter = {
        &#34;instance_id&#34;: instance_id,
        &#34;template_id&#34;: template_id,
        &#34;template_version&#34;: template_version,
        &#34;method_of_use&#34;: method_of_use,
        &#34;third_party_data_sharing&#34;: third_party_data_sharing,
        &#34;data_ex_id&#34;: data_ex_id,
        &#34;data_subject_did&#34;: data_subject_did
    }

    tag_filter = drop_none_dict(tag_filter)

    records = await DataAgreementInstanceRecord.query(
        context=self.context,
        tag_filter=tag_filter
    )

    records = sorted(records, key=lambda k: k.created_at, reverse=True)

    paginate_result = paginate_records(records, page, page_size)

    return paginate_result</code></pre>
</details>
</dd>
<dt id="dexa_sdk.managers.ada_manager.V2ADAManager.query_data_agreement_qr_codes"><code class="name flex">
<span>async def <span class="ident">query_data_agreement_qr_codes</span></span>(<span>self, template_id: str) ‑> <a title="dexa_sdk.utils.utils.PaginationResult" href="../utils/utils.html#dexa_sdk.utils.utils.PaginationResult">PaginationResult</a></span>
</code></dt>
<dd>
<div class="desc"><p>Query data agreement qr codes</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>PaginationResult</code></dt>
<dd>List of qr code records.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def query_data_agreement_qr_codes(
    self,
    template_id: str,
) -&gt; PaginationResult:
    &#34;&#34;&#34;Query data agreement qr codes

    Returns:
        PaginationResult: List of qr code records.
    &#34;&#34;&#34;

    records = await DataAgreementQRCodeRecord.query(self.context, {&#34;template_id&#34;: template_id})
    pagination_result = paginate_records(records, page=1, page_size=1000000)
    return pagination_result</code></pre>
</details>
</dd>
<dt id="dexa_sdk.managers.ada_manager.V2ADAManager.query_pd_of_da_template_from_wallet"><code class="name flex">
<span>async def <span class="ident">query_pd_of_da_template_from_wallet</span></span>(<span>self, template_id: str = None, method_of_use: str = None, third_party_data_sharing: str = None, page: int = 1, page_size: int = 10) ‑> <a title="dexa_sdk.utils.utils.PaginationResult" href="../utils/utils.html#dexa_sdk.utils.utils.PaginationResult">PaginationResult</a></span>
</code></dt>
<dd>
<div class="desc"><p>Query personal data for DA template.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>template_id</code></strong> :&ensp;<code>str</code></dt>
<dd>Template identifier</dd>
<dt><strong><code>page</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Page number. Defaults to 1.</dd>
<dt><strong><code>page_size</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Page size. Defaults to 10.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>PaginationResult</code></dt>
<dd>Pagination results</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def query_pd_of_da_template_from_wallet(self,
                                              template_id: str = None,
                                              method_of_use: str = None,
                                              third_party_data_sharing: str = None,
                                              page: int = 1,
                                              page_size: int = 10,
                                              ) -&gt; PaginationResult:
    &#34;&#34;&#34;Query personal data for DA template.

    Args:
        template_id (str): Template identifier
        page (int, optional): Page number. Defaults to 1.
        page_size (int, optional): Page size. Defaults to 10.

    Returns:
        PaginationResult: Pagination results
    &#34;&#34;&#34;

    # Tag filter
    tag_filter = {
        &#34;delete_flag&#34;: bool_to_str(False),
        &#34;method_of_use&#34;: method_of_use,
        &#34;template_id&#34;: template_id,
        &#34;latest_version_flag&#34;: bool_to_str(True),
        &#34;third_party_data_sharing&#34;: third_party_data_sharing
    }

    tag_filter = drop_none_dict(tag_filter)

    records = await DataAgreementTemplateRecord.query(
        context=self.context,
        tag_filter=tag_filter
    )

    records = sorted(records, key=lambda k: k.created_at, reverse=True)

    # Fetch personal data records
    pd_records = []
    for record in records:
        pd_records.extend(await record.fetch_personal_data_records(self.context))

    paginate_result = paginate_records(pd_records, page, page_size)

    return paginate_result</code></pre>
</details>
</dd>
<dt id="dexa_sdk.managers.ada_manager.V2ADAManager.send_data_controller_details_message"><code class="name flex">
<span>async def <span class="ident">send_data_controller_details_message</span></span>(<span>self, connection_id: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Send data controller details message</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>connection_id</code></strong> :&ensp;<code>str</code></dt>
<dd>Connection ID</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def send_data_controller_details_message(
    self,
    connection_id: str
):
    &#34;&#34;&#34;Send data controller details message

    Args:
        connection_id (str): Connection ID
    &#34;&#34;&#34;

    message = DataControllerDetailsMessage()
    await self.send_reply_message(message, connection_id)</code></pre>
</details>
</dd>
<dt id="dexa_sdk.managers.ada_manager.V2ADAManager.send_existing_connections_message"><code class="name flex">
<span>async def <span class="ident">send_existing_connections_message</span></span>(<span>self, theirdid: str, connection_id: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Send existing connections notification message.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>theirdid</code></strong> :&ensp;<code>str</code></dt>
<dd>Their DID of remote agent in old connection.</dd>
<dt><strong><code>connection_id</code></strong> :&ensp;<code>str</code></dt>
<dd>Connection identifier.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def send_existing_connections_message(
    self,
    theirdid: str,
    connection_id: str
):
    &#34;&#34;&#34;Send existing connections notification message.

    Args:
        theirdid (str): Their DID of remote agent in old connection.
        connection_id (str): Connection identifier.
    &#34;&#34;&#34;

    # Construct existing connection message.
    message = ExistingConnectionsMessage(
        body=ExistingConnectionsBody(
            theirdid=theirdid
        )
    )

    # Send the message to remote agent.
    await self.send_message_with_connection_invitation(
        message,
        connection_id
    )</code></pre>
</details>
</dd>
<dt id="dexa_sdk.managers.ada_manager.V2ADAManager.send_message_with_connection_invitation"><code class="name flex">
<span>async def <span class="ident">send_message_with_connection_invitation</span></span>(<span>self, message: aries_cloudagent.messaging.agent_message.AgentMessage, connection_id: str) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Send message with connection invitation.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>message</code></strong> :&ensp;<code>AgentMessage</code></dt>
<dd>Agent message.</dd>
<dt><strong><code>connection_id</code></strong> :&ensp;<code>str</code></dt>
<dd>Connection id.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def send_message_with_connection_invitation(
    self,
    message: AgentMessage,
    connection_id: str,
) -&gt; None:
    &#34;&#34;&#34;Send message with connection invitation.

    Args:
        message (AgentMessage): Agent message.
        connection_id (str): Connection id.
    &#34;&#34;&#34;
    # Fetch connection record.
    connection_record: ConnectionRecord = \
        await ConnectionRecord.retrieve_by_id(self.context, connection_id)

    # Get invitation key.
    invitation_key = connection_record.invitation_key
    # Service enpoint
    invitation = await connection_record.retrieve_invitation(self.context)
    service_endpoint = invitation.endpoint

    # Fetch wallet from context
    wallet: IndyWallet = await self.context.inject(BaseWallet)

    # Create a local did
    did: DIDInfo = await wallet.create_local_did()

    sender_key = did.verkey
    packed_message = await wallet.pack_message(
        message.to_json(),
        [invitation_key],
        sender_key
    )

    headers = {
        &#34;Content-Type&#34;: &#34;application/ssi-agent-wire&#34;
    }

    async with aiohttp.ClientSession(headers=headers) as session:
        async with session.post(service_endpoint, data=packed_message) as response:
            if response.status == 200:
                self._logger.info(&#34;Posted existing connection message...&#34;)</code></pre>
</details>
</dd>
<dt id="dexa_sdk.managers.ada_manager.V2ADAManager.send_message_with_connection_invitation_and_return_route_all"><code class="name flex">
<span>async def <span class="ident">send_message_with_connection_invitation_and_return_route_all</span></span>(<span>self, message: aries_cloudagent.messaging.agent_message.AgentMessage, connection_id: str) ‑> Tuple[str, str, dict]</span>
</code></dt>
<dd>
<div class="desc"><p>Send message with connection invitation and return route all.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>message</code></strong> :&ensp;<code>AgentMessage</code></dt>
<dd>Agent message.</dd>
<dt><strong><code>connection_id</code></strong> :&ensp;<code>str</code></dt>
<dd>Connection id.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>typing.Tuple[str, str, dict]</code></dt>
<dd>sender_verkey, recipient_verkey, message_dict</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def send_message_with_connection_invitation_and_return_route_all(
    self,
    message: AgentMessage,
    connection_id: str,
) -&gt; typing.Tuple[str, str, dict]:
    &#34;&#34;&#34;Send message with connection invitation and return route all.

    Args:
        message (AgentMessage): Agent message.
        connection_id (str): Connection id.

    Returns:
        typing.Tuple[str, str, dict]: sender_verkey, recipient_verkey, message_dict
    &#34;&#34;&#34;
    # Fetch connection record.
    connection_record: ConnectionRecord = \
        await ConnectionRecord.retrieve_by_id(self.context, connection_id)

    # Get invitation key.
    invitation_key = connection_record.invitation_key
    # Service enpoint
    invitation = await connection_record.retrieve_invitation(self.context)
    service_endpoint = invitation.endpoint

    # Fetch wallet from context
    wallet: IndyWallet = await self.context.inject(BaseWallet)

    # Set transport return route all
    message._decorators[&#34;transport&#34;] = TransportDecorator(
        return_route=&#34;all&#34;
    )

    # Create a local did
    did: DIDInfo = await wallet.create_local_did()

    sender_key = did.verkey
    packed_message = await wallet.pack_message(
        message.to_json(),
        [invitation_key],
        sender_key
    )

    headers = {
        &#34;Content-Type&#34;: &#34;application/ssi-agent-wire&#34;
    }

    async with aiohttp.ClientSession(headers=headers) as session:
        async with session.post(service_endpoint, data=packed_message) as response:
            if response.status == 200:
                message_body = await response.read()

                # Unpack message
                unpacked = await wallet.unpack_message(message_body)
                (message_json, sender_verkey, recipient_verkey) = unpacked

                # Convert message to dict.
                message_dict = json.loads(message_json)

                return (sender_verkey, recipient_verkey, message_dict)</code></pre>
</details>
</dd>
<dt id="dexa_sdk.managers.ada_manager.V2ADAManager.send_problem_report_message"><code class="name flex">
<span>async def <span class="ident">send_problem_report_message</span></span>(<span>self, explain: str, connection_id: str) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Send problem report message as reply.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>explain</code></strong> :&ensp;<code>str</code></dt>
<dd>Explaination.</dd>
<dt><strong><code>connection_id</code></strong> :&ensp;<code>str</code></dt>
<dd>Connection id.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def send_problem_report_message(self, explain: str, connection_id: str) -&gt; None:
    &#34;&#34;&#34;Send problem report message as reply.

    Args:
        explain (str): Explaination.
        connection_id (str): Connection id.
    &#34;&#34;&#34;

    # Responder instance
    responder: DispatcherResponder = await self.context.inject(BaseResponder, required=False)

    problem_report = ProblemReport(explain_ltxt=explain)

    if responder:
        await responder.send_reply(problem_report, connection_id=connection_id)</code></pre>
</details>
</dd>
<dt id="dexa_sdk.managers.ada_manager.V2ADAManager.send_qr_code_initiate_message"><code class="name flex">
<span>async def <span class="ident">send_qr_code_initiate_message</span></span>(<span>self, qr_id, connection_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Send data agreement qr code initiate message.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>qr_id</code></strong> :&ensp;<code>_type_</code></dt>
<dd>QR id</dd>
<dt><strong><code>connection_id</code></strong> :&ensp;<code>_type_</code></dt>
<dd>connection id</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def send_qr_code_initiate_message(
    self,
    qr_id,
    connection_id
):
    &#34;&#34;&#34;Send data agreement qr code initiate message.

    Args:
        qr_id (_type_): QR id
        connection_id (_type_): connection id
    &#34;&#34;&#34;

    message = DataAgreementQrCodeInitiateMessage(
        body=DataAgreementQrCodeInitiateBody(
            qr_id=qr_id
        )
    )

    await self.send_reply_message(message, connection_id)</code></pre>
</details>
</dd>
<dt id="dexa_sdk.managers.ada_manager.V2ADAManager.send_reply_message"><code class="name flex">
<span>async def <span class="ident">send_reply_message</span></span>(<span>self, message: aries_cloudagent.messaging.agent_message.AgentMessage, connection_id: str = None) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Send reply message to remote agent.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>message</code></strong> :&ensp;<code>AgentMessage</code></dt>
<dd>Agent message.</dd>
<dt><strong><code>connection_id</code></strong> :&ensp;<code>str</code></dt>
<dd>Connection identifier</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def send_reply_message(self, message: AgentMessage, connection_id: str = None) -&gt; None:
    &#34;&#34;&#34;Send reply message to remote agent.

    Args:
        message (AgentMessage): Agent message.
        connection_id (str): Connection identifier
    &#34;&#34;&#34;
    # Responder instance
    responder: DispatcherResponder = await self.context.inject(BaseResponder, required=False)

    if responder:
        await responder.send_reply(message, connection_id=connection_id)</code></pre>
</details>
</dd>
<dt id="dexa_sdk.managers.ada_manager.V2ADAManager.update_and_store_da_template_in_wallet"><code class="name flex">
<span>async def <span class="ident">update_and_store_da_template_in_wallet</span></span>(<span>self, template_id: str, data_agreement: dict, *, publish_flag: bool = True, schema_id: str = None) ‑> <a title="dexa_sdk.agreements.da.v1_0.records.da_template_record.DataAgreementTemplateRecord" href="../agreements/da/v1_0/records/da_template_record.html#dexa_sdk.agreements.da.v1_0.records.da_template_record.DataAgreementTemplateRecord">DataAgreementTemplateRecord</a></span>
</code></dt>
<dd>
<div class="desc"><p>Update and store data agreement template in wallet.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>template_id</code></strong> :&ensp;<code>str</code></dt>
<dd>Template identifier</dd>
<dt><strong><code>data_agreement</code></strong> :&ensp;<code>dict</code></dt>
<dd>Data agreement</dd>
<dt><strong><code>publish_flag</code></strong> :&ensp;<code>bool</code></dt>
<dd>Publish flag</dd>
<dt><strong><code>schema_id</code></strong> :&ensp;<code>str</code></dt>
<dd>Schema identifier</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>DataAgreementTemplateRecord</code></dt>
<dd>Updated record.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def update_and_store_da_template_in_wallet(
        self,
        template_id: str,
        data_agreement: dict,
        *,
        publish_flag: bool = True,
        schema_id: str = None
) -&gt; DataAgreementTemplateRecord:
    &#34;&#34;&#34;Update and store data agreement template in wallet.

    Args:
        template_id (str): Template identifier
        data_agreement (dict): Data agreement
        publish_flag (bool): Publish flag
        schema_id (str): Schema identifier

    Returns:
        DataAgreementTemplateRecord: Updated record.
    &#34;&#34;&#34;

    # Tag filter
    tag_filter = {
        &#34;delete_flag&#34;: bool_to_str(False),
        &#34;template_id&#34;: template_id,
        &#34;latest_version_flag&#34;: bool_to_str(True)
    }

    # Fetch data agreement record
    record: DataAgreementTemplateRecord = \
        await DataAgreementTemplateRecord.retrieve_by_tag_filter(self.context, tag_filter)

    # Validate the data agreement.
    previous_da: DataAgreementModel = DataAgreementModel.deserialize(record.data_agreement)

    assert previous_da.method_of_use == data_agreement.get(
        &#34;methodOfUse&#34;), &#34;Method of use cannot be updated.&#34;

    assert previous_da.data_policy.third_party_data_sharing \
        == data_agreement.get(&#34;dataPolicy&#34;).get(&#34;thirdPartyDataSharing&#34;), \
        &#34;Third party data sharing cannot be updated.&#34;

    # Copy the id, version from previous da to new da
    template_version = bump_major_for_semver_string(previous_da.version)
    template_id = previous_da.id
    data_agreement.update({&#34;@context&#34;: DA_DEFAULT_CONTEXT})
    data_agreement.update({&#34;@type&#34;: DA_TYPE})
    data_agreement.update({&#34;@id&#34;: template_id})
    data_agreement.update({&#34;version&#34;: template_version})

    updated_da: DataAgreementModel = DataAgreementModel.deserialize(data_agreement)

    # Create personal data records
    pds = updated_da.personal_data
    pd_records = []
    pd_models_with_id = []
    for pd in pds:
        pd_record: PersonalDataRecord = \
            await PersonalDataRecord.build_and_save_record_from_pd_model(
                self.context,
                template_id,
                template_version,
                pd
            )
        pd_records.append(pd_record)
        pd_models_with_id.append(pd_record.convert_record_to_pd_model())

    # Update the personal data with attribute identifiers to the agreement
    updated_da.personal_data = pd_models_with_id

    record.data_agreement = updated_da.serialize()
    record.publish_flag = bool_to_str(publish_flag)
    record.schema_id = schema_id
    record.existing_schema_flag = bool_to_str(True) if schema_id else bool_to_str(False)
    record.template_version = template_version

    await record.upgrade(self.context)

    if publish_flag:
        # Create ledger payloads
        record = await self.create_and_store_ledger_payloads_for_da_template(
            template_record=record,
            pd_records=pd_records,
            schema_id=schema_id
        )

    return record</code></pre>
</details>
</dd>
<dt id="dexa_sdk.managers.ada_manager.V2ADAManager.update_controller_details"><code class="name flex">
<span>async def <span class="ident">update_controller_details</span></span>(<span>self, organisation_name: str = None, cover_image_url: str = None, logo_image_url: str = None, location: str = None, organisation_type: str = None, description: str = None, policy_url: str = None, eula_url: str = None) ‑> <a title="dexa_sdk.data_controller.records.controller_details_record.ControllerDetailsRecord" href="../data_controller/records/controller_details_record.html#dexa_sdk.data_controller.records.controller_details_record.ControllerDetailsRecord">ControllerDetailsRecord</a></span>
</code></dt>
<dd>
<div class="desc"><p>Update controller details</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>organisation_name</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Organisation name. Defaults to None.</dd>
<dt><strong><code>cover_image_url</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Cover image URL. Defaults to None.</dd>
<dt><strong><code>logo_image_url</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Logo image URL. Defaults to None.</dd>
<dt><strong><code>location</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Location. Defaults to None.</dd>
<dt><strong><code>organisation_type</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Organisation type. Defaults to None.</dd>
<dt><strong><code>description</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Description. Defaults to None.</dd>
<dt><strong><code>policy_url</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Policy URL. Defaults to None.</dd>
<dt><strong><code>eula_url</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>EULA URL. Defaults to None.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ControllerDetailsRecord</code></dt>
<dd>Controller details record.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def update_controller_details(
    self,
    organisation_name: str = None,
    cover_image_url: str = None,
    logo_image_url: str = None,
    location: str = None,
    organisation_type: str = None,
    description: str = None,
    policy_url: str = None,
    eula_url: str = None
) -&gt; ControllerDetailsRecord:
    &#34;&#34;&#34;Update controller details

    Args:
        organisation_name (str, optional): Organisation name. Defaults to None.
        cover_image_url (str, optional): Cover image URL. Defaults to None.
        logo_image_url (str, optional): Logo image URL. Defaults to None.
        location (str, optional): Location. Defaults to None.
        organisation_type (str, optional): Organisation type. Defaults to None.
        description (str, optional): Description. Defaults to None.
        policy_url (str, optional): Policy URL. Defaults to None.
        eula_url (str, optional): EULA URL. Defaults to None.

    Returns:
        ControllerDetailsRecord: Controller details record.
    &#34;&#34;&#34;

    # Query controller records.
    records = await ControllerDetailsRecord.query(self.context, {})
    if not records:

        wallet: BaseWallet = await self.context.inject(BaseWallet)

        controller_did = await wallet.get_public_did()

        organisation_did = f&#34;did:sov:{controller_did.did}&#34;

        # If not found, create new record.
        record = ControllerDetailsRecord(
            organisation_did=organisation_did,
            organisation_name=organisation_name,
            cover_image_url=cover_image_url,
            logo_image_url=logo_image_url,
            location=location,
            organisation_type=organisation_type,
            description=description,
            policy_url=policy_url,
            eula_url=eula_url
        )

        await record.save(self.context)
    else:
        # If found update record.
        record: ControllerDetailsRecord = records[0]
        record.organisation_name = organisation_name
        record.cover_image_url = cover_image_url
        record.logo_image_url = logo_image_url
        record.location = location
        record.organisation_type = organisation_type
        record.description = description
        record.policy_url = policy_url
        record.eula_url = eula_url

        await record.save(self.context)

    return record</code></pre>
</details>
</dd>
<dt id="dexa_sdk.managers.ada_manager.V2ADAManager.update_personal_data_description"><code class="name flex">
<span>async def <span class="ident">update_personal_data_description</span></span>(<span>self, attribute_id: str, desc: str) ‑> <a title="dexa_sdk.agreements.da.v1_0.records.personal_data_record.PersonalDataRecord" href="../agreements/da/v1_0/records/personal_data_record.html#dexa_sdk.agreements.da.v1_0.records.personal_data_record.PersonalDataRecord">PersonalDataRecord</a></span>
</code></dt>
<dd>
<div class="desc"><p>Update personal data description</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>attribute_id</code></strong> :&ensp;<code>str</code></dt>
<dd>Attribute id</dd>
<dt><strong><code>desc</code></strong> :&ensp;<code>str</code></dt>
<dd>Description</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>PersonalDataRecord</code></dt>
<dd>Personal data record</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def update_personal_data_description(self,
                                           attribute_id: str,
                                           desc: str) -&gt; PersonalDataRecord:
    &#34;&#34;&#34;Update personal data description

    Args:
        attribute_id (str): Attribute id
        desc (str): Description

    Returns:
        PersonalDataRecord: Personal data record
    &#34;&#34;&#34;

    # Fetch personal data record by id
    pd_record: PersonalDataRecord = await PersonalDataRecord.retrieve_by_id(
        self.context,
        attribute_id
    )

    # Fetch the associated data agreement record
    da_template_record: DataAgreementTemplateRecord = \
        await DataAgreementTemplateRecord.latest_template_by_id(
            self.context,
            pd_record.data_agreement_template_id
        )

    assert da_template_record, &#34;Matching data agreement template not found.&#34;
    assert da_template_record.template_version == \
        pd_record.data_agreement_template_version, \
        &#34;Matching data agreement template with same version not found.&#34;

    # Update the personal data record.
    pd_record.attribute_description = desc
    await pd_record.save(self.context)

    pd_model: DataAgreementPersonalDataModel = pd_record.convert_record_to_pd_model()

    # Update the data agreement record with new personal data.
    da: DataAgreementModel = DataAgreementModel.deserialize(da_template_record.data_agreement)
    # Iterate through the existing personal data in data agreements
    # And update the personal data matching the attribute id
    da_pds = []
    for da_pd in da.personal_data:
        if da_pd.attribute_id != pd_model.attribute_id:
            da_pds.append(da_pd)
    da_pds.append(pd_model)
    da.personal_data = da_pds

    da_template_record.data_agreement = da.serialize()
    await da_template_record.save(self.context)

    return pd_record</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="dexa_sdk.managers.ada_manager.V2ADAManagerError"><code class="flex name class">
<span>class <span class="ident">V2ADAManagerError</span></span>
<span>(</span><span>*args, error_code: str = None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>ADA manager error</p>
<p>Initialize a BaseError instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class V2ADAManagerError(BaseError):
    &#34;&#34;&#34;ADA manager error&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>aries_cloudagent.core.error.BaseError</li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="dexa_sdk.managers" href="index.html">dexa_sdk.managers</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="dexa_sdk.managers.ada_manager.V2ADAManager" href="#dexa_sdk.managers.ada_manager.V2ADAManager">V2ADAManager</a></code></h4>
<ul class="">
<li><code><a title="dexa_sdk.managers.ada_manager.V2ADAManager.add_task" href="#dexa_sdk.managers.ada_manager.V2ADAManager.add_task">add_task</a></code></li>
<li><code><a title="dexa_sdk.managers.ada_manager.V2ADAManager.anchor_da_instance_to_blockchain" href="#dexa_sdk.managers.ada_manager.V2ADAManager.anchor_da_instance_to_blockchain">anchor_da_instance_to_blockchain</a></code></li>
<li><code><a title="dexa_sdk.managers.ada_manager.V2ADAManager.anchor_da_instance_to_blockchain_async_task" href="#dexa_sdk.managers.ada_manager.V2ADAManager.anchor_da_instance_to_blockchain_async_task">anchor_da_instance_to_blockchain_async_task</a></code></li>
<li><code><a title="dexa_sdk.managers.ada_manager.V2ADAManager.anchor_da_instance_to_blockchain_async_task_callback" href="#dexa_sdk.managers.ada_manager.V2ADAManager.anchor_da_instance_to_blockchain_async_task_callback">anchor_da_instance_to_blockchain_async_task_callback</a></code></li>
<li><code><a title="dexa_sdk.managers.ada_manager.V2ADAManager.build_data_agreement_accept_for_data_ex_record" href="#dexa_sdk.managers.ada_manager.V2ADAManager.build_data_agreement_accept_for_data_ex_record">build_data_agreement_accept_for_data_ex_record</a></code></li>
<li><code><a title="dexa_sdk.managers.ada_manager.V2ADAManager.build_data_agreement_negotiation_accept_by_instance_id" href="#dexa_sdk.managers.ada_manager.V2ADAManager.build_data_agreement_negotiation_accept_by_instance_id">build_data_agreement_negotiation_accept_by_instance_id</a></code></li>
<li><code><a title="dexa_sdk.managers.ada_manager.V2ADAManager.build_data_agreement_offer_for_credential_exchange" href="#dexa_sdk.managers.ada_manager.V2ADAManager.build_data_agreement_offer_for_credential_exchange">build_data_agreement_offer_for_credential_exchange</a></code></li>
<li><code><a title="dexa_sdk.managers.ada_manager.V2ADAManager.build_data_agreement_offer_for_presentation_exchange" href="#dexa_sdk.managers.ada_manager.V2ADAManager.build_data_agreement_offer_for_presentation_exchange">build_data_agreement_offer_for_presentation_exchange</a></code></li>
<li><code><a title="dexa_sdk.managers.ada_manager.V2ADAManager.construct_presentation_request" href="#dexa_sdk.managers.ada_manager.V2ADAManager.construct_presentation_request">construct_presentation_request</a></code></li>
<li><code><a title="dexa_sdk.managers.ada_manager.V2ADAManager.context" href="#dexa_sdk.managers.ada_manager.V2ADAManager.context">context</a></code></li>
<li><code><a title="dexa_sdk.managers.ada_manager.V2ADAManager.create_and_store_da_template_in_wallet" href="#dexa_sdk.managers.ada_manager.V2ADAManager.create_and_store_da_template_in_wallet">create_and_store_da_template_in_wallet</a></code></li>
<li><code><a title="dexa_sdk.managers.ada_manager.V2ADAManager.create_and_store_ledger_payloads_for_da_template" href="#dexa_sdk.managers.ada_manager.V2ADAManager.create_and_store_ledger_payloads_for_da_template">create_and_store_ledger_payloads_for_da_template</a></code></li>
<li><code><a title="dexa_sdk.managers.ada_manager.V2ADAManager.create_connection_qr_code" href="#dexa_sdk.managers.ada_manager.V2ADAManager.create_connection_qr_code">create_connection_qr_code</a></code></li>
<li><code><a title="dexa_sdk.managers.ada_manager.V2ADAManager.create_data_agreement_qr_code" href="#dexa_sdk.managers.ada_manager.V2ADAManager.create_data_agreement_qr_code">create_data_agreement_qr_code</a></code></li>
<li><code><a title="dexa_sdk.managers.ada_manager.V2ADAManager.create_invitation" href="#dexa_sdk.managers.ada_manager.V2ADAManager.create_invitation">create_invitation</a></code></li>
<li><code><a title="dexa_sdk.managers.ada_manager.V2ADAManager.delete_da_instance_by_data_ex_id" href="#dexa_sdk.managers.ada_manager.V2ADAManager.delete_da_instance_by_data_ex_id">delete_da_instance_by_data_ex_id</a></code></li>
<li><code><a title="dexa_sdk.managers.ada_manager.V2ADAManager.delete_da_template_in_wallet" href="#dexa_sdk.managers.ada_manager.V2ADAManager.delete_da_template_in_wallet">delete_da_template_in_wallet</a></code></li>
<li><code><a title="dexa_sdk.managers.ada_manager.V2ADAManager.delete_data_agreement_qr_code" href="#dexa_sdk.managers.ada_manager.V2ADAManager.delete_data_agreement_qr_code">delete_data_agreement_qr_code</a></code></li>
<li><code><a title="dexa_sdk.managers.ada_manager.V2ADAManager.delete_personal_data" href="#dexa_sdk.managers.ada_manager.V2ADAManager.delete_personal_data">delete_personal_data</a></code></li>
<li><code><a title="dexa_sdk.managers.ada_manager.V2ADAManager.get_existing_connection_record_for_new_connection_id" href="#dexa_sdk.managers.ada_manager.V2ADAManager.get_existing_connection_record_for_new_connection_id">get_existing_connection_record_for_new_connection_id</a></code></li>
<li><code><a title="dexa_sdk.managers.ada_manager.V2ADAManager.process_da_negotiation_receipt_message" href="#dexa_sdk.managers.ada_manager.V2ADAManager.process_da_negotiation_receipt_message">process_da_negotiation_receipt_message</a></code></li>
<li><code><a title="dexa_sdk.managers.ada_manager.V2ADAManager.process_data_agreement_qr_code_initiate_message" href="#dexa_sdk.managers.ada_manager.V2ADAManager.process_data_agreement_qr_code_initiate_message">process_data_agreement_qr_code_initiate_message</a></code></li>
<li><code><a title="dexa_sdk.managers.ada_manager.V2ADAManager.process_data_controller_details_message" href="#dexa_sdk.managers.ada_manager.V2ADAManager.process_data_controller_details_message">process_data_controller_details_message</a></code></li>
<li><code><a title="dexa_sdk.managers.ada_manager.V2ADAManager.process_decorator_with_da_accept_message" href="#dexa_sdk.managers.ada_manager.V2ADAManager.process_decorator_with_da_accept_message">process_decorator_with_da_accept_message</a></code></li>
<li><code><a title="dexa_sdk.managers.ada_manager.V2ADAManager.process_decorator_with_da_offer_message" href="#dexa_sdk.managers.ada_manager.V2ADAManager.process_decorator_with_da_offer_message">process_decorator_with_da_offer_message</a></code></li>
<li><code><a title="dexa_sdk.managers.ada_manager.V2ADAManager.process_existing_connections_message" href="#dexa_sdk.managers.ada_manager.V2ADAManager.process_existing_connections_message">process_existing_connections_message</a></code></li>
<li><code><a title="dexa_sdk.managers.ada_manager.V2ADAManager.publish_da_template_in_wallet" href="#dexa_sdk.managers.ada_manager.V2ADAManager.publish_da_template_in_wallet">publish_da_template_in_wallet</a></code></li>
<li><code><a title="dexa_sdk.managers.ada_manager.V2ADAManager.query_connections_and_categorise_results" href="#dexa_sdk.managers.ada_manager.V2ADAManager.query_connections_and_categorise_results">query_connections_and_categorise_results</a></code></li>
<li><code><a title="dexa_sdk.managers.ada_manager.V2ADAManager.query_da_templates_in_wallet" href="#dexa_sdk.managers.ada_manager.V2ADAManager.query_da_templates_in_wallet">query_da_templates_in_wallet</a></code></li>
<li><code><a title="dexa_sdk.managers.ada_manager.V2ADAManager.query_data_agreement_instances" href="#dexa_sdk.managers.ada_manager.V2ADAManager.query_data_agreement_instances">query_data_agreement_instances</a></code></li>
<li><code><a title="dexa_sdk.managers.ada_manager.V2ADAManager.query_data_agreement_qr_codes" href="#dexa_sdk.managers.ada_manager.V2ADAManager.query_data_agreement_qr_codes">query_data_agreement_qr_codes</a></code></li>
<li><code><a title="dexa_sdk.managers.ada_manager.V2ADAManager.query_pd_of_da_template_from_wallet" href="#dexa_sdk.managers.ada_manager.V2ADAManager.query_pd_of_da_template_from_wallet">query_pd_of_da_template_from_wallet</a></code></li>
<li><code><a title="dexa_sdk.managers.ada_manager.V2ADAManager.send_data_controller_details_message" href="#dexa_sdk.managers.ada_manager.V2ADAManager.send_data_controller_details_message">send_data_controller_details_message</a></code></li>
<li><code><a title="dexa_sdk.managers.ada_manager.V2ADAManager.send_existing_connections_message" href="#dexa_sdk.managers.ada_manager.V2ADAManager.send_existing_connections_message">send_existing_connections_message</a></code></li>
<li><code><a title="dexa_sdk.managers.ada_manager.V2ADAManager.send_message_with_connection_invitation" href="#dexa_sdk.managers.ada_manager.V2ADAManager.send_message_with_connection_invitation">send_message_with_connection_invitation</a></code></li>
<li><code><a title="dexa_sdk.managers.ada_manager.V2ADAManager.send_message_with_connection_invitation_and_return_route_all" href="#dexa_sdk.managers.ada_manager.V2ADAManager.send_message_with_connection_invitation_and_return_route_all">send_message_with_connection_invitation_and_return_route_all</a></code></li>
<li><code><a title="dexa_sdk.managers.ada_manager.V2ADAManager.send_problem_report_message" href="#dexa_sdk.managers.ada_manager.V2ADAManager.send_problem_report_message">send_problem_report_message</a></code></li>
<li><code><a title="dexa_sdk.managers.ada_manager.V2ADAManager.send_qr_code_initiate_message" href="#dexa_sdk.managers.ada_manager.V2ADAManager.send_qr_code_initiate_message">send_qr_code_initiate_message</a></code></li>
<li><code><a title="dexa_sdk.managers.ada_manager.V2ADAManager.send_reply_message" href="#dexa_sdk.managers.ada_manager.V2ADAManager.send_reply_message">send_reply_message</a></code></li>
<li><code><a title="dexa_sdk.managers.ada_manager.V2ADAManager.update_and_store_da_template_in_wallet" href="#dexa_sdk.managers.ada_manager.V2ADAManager.update_and_store_da_template_in_wallet">update_and_store_da_template_in_wallet</a></code></li>
<li><code><a title="dexa_sdk.managers.ada_manager.V2ADAManager.update_controller_details" href="#dexa_sdk.managers.ada_manager.V2ADAManager.update_controller_details">update_controller_details</a></code></li>
<li><code><a title="dexa_sdk.managers.ada_manager.V2ADAManager.update_personal_data_description" href="#dexa_sdk.managers.ada_manager.V2ADAManager.update_personal_data_description">update_personal_data_description</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="dexa_sdk.managers.ada_manager.V2ADAManagerError" href="#dexa_sdk.managers.ada_manager.V2ADAManagerError">V2ADAManagerError</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>