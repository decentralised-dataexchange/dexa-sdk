<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>dexa_sdk.managers.ada_manager API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>dexa_sdk.managers.ada_manager</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import asyncio
import uuid
import typing
import json
from loguru import logger
from web3._utils.encoding import to_json
from marshmallow.exceptions import ValidationError
from aries_cloudagent.config.injection_context import InjectionContext
from aries_cloudagent.core.error import BaseError
from aries_cloudagent.utils.task_queue import CompletedTask, PendingTask
from aries_cloudagent.transport.pack_format import BaseWireFormat, PackWireFormat
from aries_cloudagent.connections.models.connection_record import ConnectionRecord
from aries_cloudagent.messaging.decorators.default import DecoratorSet
from aries_cloudagent.messaging.responder import BaseResponder
from aries_cloudagent.protocols.basicmessage.v1_0.messages.basicmessage import BasicMessage
from aries_cloudagent.protocols.issue_credential.v1_0.models.credential_exchange import (
    V10CredentialExchange
)
from aries_cloudagent.protocols.present_proof.v1_0.models.presentation_exchange import (
    V10PresentationExchange
)
from mydata_did.v1_0.utils.util import bool_to_str
from mydata_did.v1_0.messages.data_agreement_offer import (
    DataAgreementNegotiationOfferMessage
)
from mydata_did.v1_0.messages.data_agreement_accept import (
    DataAgreementNegotiationAcceptMessage
)
from mydata_did.v1_0.message_types import (
    DATA_AGREEMENT_NEGOTIATION_OFFER,
    DATA_AGREEMENT_NEGOTIATION_ACCEPT,
)
from mydata_did.v1_0.decorators.data_agreement_context_decorator import (
    DataAgreementContextDecorator,
)
from ..agreements.da.v1_0.models.da_models import (
    DataAgreementModel,
    DA_DEFAULT_CONTEXT,
    DA_TYPE
)
from ..agreements.da.v1_0.records.da_instance_record import DataAgreementInstanceRecord
from ..agreements.da.v1_0.records.da_template_record import DataAgreementTemplateRecord
from ..agreements.da.v1_0.records.personal_data_record import PersonalDataRecord
from ..agreements.da.v1_0.models.da_models import DataAgreementPersonalDataModel
from ..agreements.da.v1_0.models.da_instance_models import DataAgreementInstanceModel
from ..ledgers.indy.core import (
    create_cred_def_and_anchor_to_ledger,
    create_schema_def_and_anchor_to_ledger
)
from ..utils import paginate_records, PaginationResult, drop_none_dict, bump_major_for_semver_string
from ..did_mydata.core import DIDMyDataBuilder
from ..ledgers.ethereum.core import EthereumClient


class V2ADAManagerError(BaseError):
    &#34;&#34;&#34;ADA manager error&#34;&#34;&#34;


class V2ADAManager:
    &#34;&#34;&#34;Manages ADA related functions (v2)
    &#34;&#34;&#34;

    def __init__(self, context: InjectionContext) -&gt; None:
        &#34;&#34;&#34;Initialise ADA manager

        Args:
            context (InjectionContext): _description_
        &#34;&#34;&#34;

        # Injection context
        self._context = context

        # Logger
        self._logger = logger

    @ property
    def context(self) -&gt; InjectionContext:
        &#34;&#34;&#34;Accessor for injection context

        Returns:
            InjectionContext: Injection context
        &#34;&#34;&#34;
        return self._context

    async def create_and_store_ledger_payloads_for_da_template(
            self,
            *,
            template_record: DataAgreementTemplateRecord,
            pd_records: typing.List[PersonalDataRecord] = None,
            schema_id: str = None
    ) -&gt; DataAgreementTemplateRecord:
        &#34;&#34;&#34;Create and store ledger payloads for a da template

        Args:
            template_record (DataAgreementTemplateRecord): Data agreement template record
            pd_records (typing.List[PersonalDataRecord]): Personal data records
            schema_id (str): Schema identifier if available

        Returns:
            DataAgreementTemplateRecord: Record with ledger payloads
        &#34;&#34;&#34;
        if template_record.method_of_use == DataAgreementTemplateRecord.METHOD_OF_USE_DATA_SOURCE:

            # Create schema if not existing
            if not schema_id:
                data_agreement = template_record.data_agreement
                # Schema name
                schema_name = data_agreement.get(&#34;purpose&#34;)
                # Schema version
                schema_version = data_agreement.get(&#34;version&#34;)
                # Schema attributes
                attributes = [
                    personal_data.attribute_name
                    for personal_data in pd_records
                ]
                # Creata schema and anchor to ledger
                (schema_id, schema_def) = await create_schema_def_and_anchor_to_ledger(
                    context=self.context,
                    schema_name=schema_name,
                    schema_version=schema_version,
                    attributes=attributes
                )

            # Create credential definition and anchor to ledger

            (cred_def_id, cred_def, novel) = await create_cred_def_and_anchor_to_ledger(
                context=self.context,
                schema_id=schema_id
            )

            template_record.cred_def_id = cred_def_id
            template_record.schema_id = schema_id
            await template_record.save(self.context)

        else:
            data_agreement = template_record.data_agreement

            # Usage purpose
            usage_purpose = data_agreement.get(&#34;purpose&#34;)

            # Usage purpose description
            usage_purpose_description = data_agreement.get(&#34;purposeDescription&#34;)

            # Data agreement template version
            da_template_version = data_agreement.get(&#34;version&#34;)

            # Create presentation request
            presentation_request = self.construct_presentation_request(
                usage_purpose=usage_purpose,
                usage_purpose_description=usage_purpose_description,
                da_template_version=da_template_version,
                personal_data=pd_records
            )

            template_record.presentation_request = presentation_request
            await template_record.save(self.context)

        return template_record

    def construct_presentation_request(
            self,
            *,
            usage_purpose: str,
            usage_purpose_description: str,
            da_template_version: str,
            personal_data: typing.List[PersonalDataRecord]
    ) -&gt; dict:
        &#34;&#34;&#34;
        Construct presentation request

        Args:
            usage_purpose: Usage purpose.
            usage_purpose_description: Usage purpose description.
            da_template_version: Data agreement template version.
            personal_data: List of personal data.

        Returns:
            :rtype: dict: Proof request

        &#34;&#34;&#34;

        presentation_request_dict: dict = {
            &#34;name&#34;: usage_purpose,
            &#34;comment&#34;: usage_purpose_description,
            &#34;version&#34;: da_template_version,
            &#34;requested_attributes&#34;: {},
            &#34;requested_predicates&#34;: {}
        }

        index = 1
        requested_attributes = {}

        for pd in personal_data:

            requested_attributes[&#34;additionalProp&#34; + str(index)] = {
                &#34;name&#34;: pd.attribute_name,
                &#34;restrictions&#34;: pd.restrictions if pd.restrictions else []
            }
            if pd.restrictions:
                restrictions = [
                    {
                        &#34;schema_id&#34;: restriction.get(&#34;schemaId&#34;),
                        &#34;cred_def_id&#34;: restriction.get(&#34;credDefId&#34;)
                    }
                    for restriction in pd.restrictions
                ]
                requested_attributes[&#34;additionalProp&#34; +
                                     str(index)].update({&#34;restrictions&#34;: restrictions})
            else:
                requested_attributes[&#34;additionalProp&#34; + str(index)].update({})
            index += 1

        presentation_request_dict[&#34;requested_attributes&#34;] = requested_attributes

        return presentation_request_dict

    async def create_and_store_da_template_in_wallet(
            self,
            data_agreement: dict,
            *,
            publish_flag: bool = True,
            schema_id: str = None
    ) -&gt; DataAgreementTemplateRecord:
        &#34;&#34;&#34;Create and store data agreement template in wallet

        Args:
            data_agreement (dict): Data agreement
            publish_flag (bool): Publish flag
            schema_id (str): Schema identifier
        &#34;&#34;&#34;

        # Temp hack
        template_version = &#34;1.0.0&#34;
        template_id = str(uuid.uuid4())
        data_agreement.update({&#34;@context&#34;: DA_DEFAULT_CONTEXT})
        data_agreement.update({&#34;@id&#34;: template_id})
        data_agreement.update({&#34;@type&#34;: DA_TYPE})
        data_agreement.update({&#34;version&#34;: template_version})

        try:
            # Validate the data agreement.
            data_agreement: DataAgreementModel = DataAgreementModel.deserialize(data_agreement)
        except ValidationError as err:
            raise V2ADAManagerError(
                f&#34;Failed to create data agreement; Reason: {err}&#34;
            )

        # Create personal data records
        pds = data_agreement.personal_data
        pd_records = []
        pd_models_with_id = []
        for pd in pds:
            pd_record: PersonalDataRecord = \
                await PersonalDataRecord.build_and_save_record_from_pd_model(
                    self.context,
                    template_id,
                    template_version,
                    pd
                )
            pd_records.append(pd_record)
            pd_models_with_id.append(pd_record.convert_record_to_pd_model())

        # Update the personal data with attribute identifiers to the agreement
        data_agreement.personal_data = pd_models_with_id

        # Create template record
        record = DataAgreementTemplateRecord(
            template_id=template_id,
            template_version=template_version,
            state=DataAgreementTemplateRecord.STATE_DEFINITION,
            method_of_use=data_agreement.method_of_use,
            data_agreement=data_agreement.serialize(),
            publish_flag=bool_to_str(publish_flag),
            schema_id=schema_id,
            existing_schema_flag=bool_to_str(True) if schema_id else bool_to_str(False),
            third_party_data_sharing=bool_to_str(
                data_agreement.data_policy.third_party_data_sharing)
        )

        await record.save(self.context)

        if publish_flag:
            # Create ledger payloads
            record = await self.create_and_store_ledger_payloads_for_da_template(
                template_record=record,
                pd_records=pd_records,
                schema_id=schema_id
            )

        return record

    async def query_da_templates_in_wallet(
            self,
            *,
            template_id: str = None,
            delete_flag: str = &#34;false&#34;,
            method_of_use: str = None,
            publish_flag: str = &#34;true&#34;,
            template_version: str = None,
            latest_version_flag: str = &#34;true&#34;,
            third_party_data_sharing: str = &#34;false&#34;,
            page: int = 1,
            page_size: int = 10,
    ) -&gt; PaginationResult:
        &#34;&#34;&#34;Query DA templates in wallet

        Args:
            template_id (str, optional): Template identifier. Defaults to None.
            delete_flag (str, optional): Delete flag. Defaults to false.
            method_of_use (str, optional): Method of use. Defaults to None.
            publish_flag (str, optional): Publish flag. Defaults to true.
            latest_version_flag (str, optional): Latest version flag. Defaults to true.
            template_version (str, optional): Template version. Defaults to None.
            third_party_data_sharing (str, optional): Third party data sharing.
                Defaults to false.
            page (int, optional): Page. Defaults to 1.

        Returns:
            PaginationResult: Pagination results.
        &#34;&#34;&#34;

        # Sample queue snippet
        await self.sample_queue_snippet()

        # Query by version is only possible if the template id is provided
        if template_version:
            assert template_id, &#34;Template identifier is required to query by version&#34;

        # Tag filter
        tag_filter = {
            &#34;delete_flag&#34;: delete_flag,
            &#34;publish_flag&#34;: publish_flag,
            &#34;method_of_use&#34;: method_of_use,
            &#34;template_id&#34;: template_id,
            &#34;template_version&#34;: template_version,
            &#34;latest_version_flag&#34;: latest_version_flag,
            &#34;third_party_data_sharing&#34;: third_party_data_sharing
        }

        tag_filter = drop_none_dict(tag_filter)

        records = await DataAgreementTemplateRecord.query(
            context=self.context,
            tag_filter=tag_filter
        )

        records = sorted(records, key=lambda k: k.created_at, reverse=True)

        paginate_result = paginate_records(records, page, page_size)

        return paginate_result

    async def publish_da_template_in_wallet(self,
                                            template_id: str) -&gt; DataAgreementTemplateRecord:
        &#34;&#34;&#34;Publish data agreement template.

        Args:
            template_id (str): Template identifier

        Returns:
            DataAgreementTemplateRecord: Template record.
        &#34;&#34;&#34;

        tag_filter = {
            &#34;delete_flag&#34;: bool_to_str(False),
            &#34;publish_flag&#34;: bool_to_str(False),
            &#34;latest_version_flag&#34;: bool_to_str(True),
            &#34;template_id&#34;: template_id
        }

        records = await DataAgreementTemplateRecord.query(
            context=self.context,
            tag_filter=tag_filter
        )

        assert records, &#34;Data agreement template not found.&#34;

        record: DataAgreementTemplateRecord = records[0]

        await record.publish_template(self.context)

        pd_records = await record.fetch_personal_data_records(self.context)

        # Create ledger payloads
        record = await self.create_and_store_ledger_payloads_for_da_template(
            template_record=record,
            pd_records=pd_records,
            schema_id=record.schema_id
        )

        return record

    async def update_and_store_da_template_in_wallet(
            self,
            template_id: str,
            data_agreement: dict,
            *,
            publish_flag: bool = True,
            schema_id: str = None
    ) -&gt; DataAgreementTemplateRecord:
        &#34;&#34;&#34;Update and store data agreement template in wallet.

        Args:
            template_id (str): Template identifier
            data_agreement (dict): Data agreement
            publish_flag (bool): Publish flag
            schema_id (str): Schema identifier

        Returns:
            DataAgreementTemplateRecord: Updated record.
        &#34;&#34;&#34;

        # Tag filter
        tag_filter = {
            &#34;delete_flag&#34;: bool_to_str(False),
            &#34;template_id&#34;: template_id,
            &#34;latest_version_flag&#34;: bool_to_str(True)
        }

        # Fetch data agreement record
        record: DataAgreementTemplateRecord = \
            await DataAgreementTemplateRecord.retrieve_by_tag_filter(self.context, tag_filter)

        # Validate the data agreement.
        previous_da: DataAgreementModel = DataAgreementModel.deserialize(record.data_agreement)

        assert previous_da.method_of_use == data_agreement.get(
            &#34;methodOfUse&#34;), &#34;Method of use cannot be updated.&#34;

        assert previous_da.data_policy.third_party_data_sharing \
            == data_agreement.get(&#34;dataPolicy&#34;).get(&#34;thirdPartyDataSharing&#34;), \
            &#34;Third party data sharing cannot be updated.&#34;

        # Copy the id, version from previous da to new da
        template_version = bump_major_for_semver_string(previous_da.version)
        template_id = previous_da.id
        data_agreement.update({&#34;@context&#34;: DA_DEFAULT_CONTEXT})
        data_agreement.update({&#34;@type&#34;: DA_TYPE})
        data_agreement.update({&#34;@id&#34;: template_id})
        data_agreement.update({&#34;version&#34;: template_version})

        updated_da: DataAgreementModel = DataAgreementModel.deserialize(data_agreement)

        # Create personal data records
        pds = updated_da.personal_data
        pd_records = []
        pd_models_with_id = []
        for pd in pds:
            pd_record: PersonalDataRecord = \
                await PersonalDataRecord.build_and_save_record_from_pd_model(
                    self.context,
                    template_id,
                    template_version,
                    pd
                )
            pd_records.append(pd_record)
            pd_models_with_id.append(pd_record.convert_record_to_pd_model())

        # Update the personal data with attribute identifiers to the agreement
        updated_da.personal_data = pd_models_with_id

        record.data_agreement = updated_da.serialize()
        record.publish_flag = bool_to_str(publish_flag)
        record.schema_id = schema_id
        record.existing_schema_flag = bool_to_str(True) if schema_id else bool_to_str(False)
        record.template_version = template_version

        await record.upgrade(self.context)

        if publish_flag:
            # Create ledger payloads
            record = await self.create_and_store_ledger_payloads_for_da_template(
                template_record=record,
                pd_records=pd_records,
                schema_id=schema_id
            )

        return record

    async def delete_da_template_in_wallet(self, template_id: str) -&gt; str:
        &#34;&#34;&#34;Deactivate DA template in wallet.

        This is not a normal delete operation of a specific version of template. Instead it
        marks the template with latest version flag as deleted i.e. Any version under this
        template is no longer active.

        Args:
            template_id (str): Template identifier
            template_version (str): Template version

        Returns:
            record_id: Record identifier for the deleted template.
        &#34;&#34;&#34;
        # Query for the data agreement by id
        data_agreement_records: DataAgreementTemplateRecord = \
            await DataAgreementTemplateRecord.non_deleted_template_by_id(
                self.context,
                template_id
            )

        assert data_agreement_records, &#34;Data agreement template not found.&#34;
        data_agreement_record = data_agreement_records[0]

        # Mark the data agreement as deleted and save.
        return await data_agreement_record.delete_template(self.context)

    async def query_pd_of_da_template_from_wallet(self,
                                                  template_id: str = None,
                                                  method_of_use: str = None,
                                                  third_party_data_sharing: str = None,
                                                  page: int = 1,
                                                  page_size: int = 10,
                                                  ) -&gt; PaginationResult:
        &#34;&#34;&#34;Query personal data for DA template.

        Args:
            template_id (str): Template identifier
            page (int, optional): Page number. Defaults to 1.
            page_size (int, optional): Page size. Defaults to 10.

        Returns:
            PaginationResult: Pagination results
        &#34;&#34;&#34;

        # Tag filter
        tag_filter = {
            &#34;delete_flag&#34;: bool_to_str(False),
            &#34;method_of_use&#34;: method_of_use,
            &#34;template_id&#34;: template_id,
            &#34;latest_version_flag&#34;: bool_to_str(True),
            &#34;third_party_data_sharing&#34;: third_party_data_sharing
        }

        tag_filter = drop_none_dict(tag_filter)

        records = await DataAgreementTemplateRecord.query(
            context=self.context,
            tag_filter=tag_filter
        )

        records = sorted(records, key=lambda k: k.created_at, reverse=True)

        # Fetch personal data records
        pd_records = []
        for record in records:
            pd_records.extend(await record.fetch_personal_data_records(self.context))

        paginate_result = paginate_records(pd_records, page, page_size)

        return paginate_result

    async def update_personal_data_description(self,
                                               attribute_id: str,
                                               desc: str) -&gt; PersonalDataRecord:
        &#34;&#34;&#34;Update personal data description

        Args:
            attribute_id (str): Attribute id
            desc (str): Description

        Returns:
            PersonalDataRecord: Personal data record
        &#34;&#34;&#34;

        # Fetch personal data record by id
        pd_record: PersonalDataRecord = await PersonalDataRecord.retrieve_by_id(
            self.context,
            attribute_id
        )

        # Fetch the associated data agreement record
        da_template_record: DataAgreementTemplateRecord = \
            await DataAgreementTemplateRecord.latest_template_by_id(
                self.context,
                pd_record.data_agreement_template_id
            )

        assert da_template_record, &#34;Matching data agreement template not found.&#34;
        assert da_template_record.template_version == \
            pd_record.data_agreement_template_version, \
            &#34;Matching data agreement template with same version not found.&#34;

        # Update the personal data record.
        pd_record.attribute_description = desc
        await pd_record.save(self.context)

        pd_model: DataAgreementPersonalDataModel = pd_record.convert_record_to_pd_model()

        # Update the data agreement record with new personal data.
        da: DataAgreementModel = DataAgreementModel.deserialize(da_template_record.data_agreement)
        # Iterate through the existing personal data in data agreements
        # And update the personal data matching the attribute id
        da_pds = []
        for da_pd in da.personal_data:
            if da_pd.attribute_id != pd_model.attribute_id:
                da_pds.append(da_pd)
        da_pds.append(pd_model)
        da.personal_data = da_pds

        da_template_record.data_agreement = da.serialize()
        await da_template_record.save(self.context)

        return pd_record

    async def delete_personal_data(self, attribute_id: str) -&gt; None:
        &#34;&#34;&#34;Delete personal data record.

        On deleting personal data record, the associated data agreement template is
        updated. If the personal data record deleted, is the last one in the template,
        proceed to delete the template record.

        Args:
            attribute_id (str): _description_
        &#34;&#34;&#34;

        # Fetch personal data record by id
        pd_record: PersonalDataRecord = await PersonalDataRecord.retrieve_by_id(
            self.context,
            attribute_id
        )

        # Fetch the associated data agreement record
        da_template_record: DataAgreementTemplateRecord = \
            await DataAgreementTemplateRecord.latest_template_by_id(
                self.context,
                pd_record.data_agreement_template_id
            )

        assert da_template_record, &#34;Matching data agreement template not found.&#34;
        assert da_template_record.template_version == \
            pd_record.data_agreement_template_version, \
            &#34;Matching data agreement template with same version not found.&#34;

        # Delete personal data record
        await pd_record.delete_record(self.context)

        da: DataAgreementModel = DataAgreementModel.deserialize(da_template_record.data_agreement)

        # Iterate through the existing personal data in data agreements
        # And remove the deleted personal data.
        da_pds = []
        for da_pd in da.personal_data:
            if da_pd.attribute_id != pd_record.attribute_id:
                da_pds.append(da_pd)

        da.personal_data = da_pds

        da_template_record.data_agreement = da.serialize()
        await da_template_record.upgrade(self.context)

        # Mark data agreement template as deleted if number of personal data is zero
        if len(da_pds) == 0:
            await da_template_record.delete_template(self.context)
        else:

            pd_records = await da_template_record.fetch_personal_data_records(self.context)

            if da_template_record._publish_flag:
                # Create ledger payloads
                await self.create_and_store_ledger_payloads_for_da_template(
                    template_record=da_template_record,
                    pd_records=pd_records,
                    schema_id=None
                )

    async def build_data_agreement_offer_for_credential_exchange(
        self,
        template_id: str,
        connection_record: ConnectionRecord,
        cred_ex_record: V10CredentialExchange,
    ) -&gt; DataAgreementNegotiationOfferMessage:
        &#34;&#34;&#34;Build data agreement offer for credential exchange.

        Args:
            context (InjectionContext): Injection context to be used.
            template_id (str): Data agreement template identifier.
            connection_record (ConnectionRecord): Connection record.
            cred_ex_record (V10CredentialExchange): Credential exchange record.

        Returns:
            DataAgreementNegotiationOfferMessage: Offer message.
        &#34;&#34;&#34;

        # Build instance record
        (da_instance_record, da_instance_model) = \
            await DataAgreementInstanceRecord.build_instance_from_template(
            self.context,
            template_id,
            connection_record,
            cred_ex_record.credential_exchange_id
        )

        # Build negotiation offer agent message
        agent_message = DataAgreementNegotiationOfferMessage(body=da_instance_model)

        return agent_message

    async def build_data_agreement_offer_for_presentation_exchange(
        self,
        template_id: str,
        connection_record: ConnectionRecord,
        pres_ex_record: V10PresentationExchange,
    ) -&gt; DataAgreementNegotiationOfferMessage:
        &#34;&#34;&#34;Build data agreement offer for presentaton exchange.

        Args:
            context (InjectionContext): Injection context to be used.
            template_id (str): Data agreement template identifier.
            connection_record (ConnectionRecord): Connection record.
            pres_ex_record (V10PresentationExchange): Presentation exchange record.

        Returns:
            DataAgreementNegotiationOfferMessage: Offer message.
        &#34;&#34;&#34;

        # Build instance record
        (da_instance_record, da_instance_model) = \
            await DataAgreementInstanceRecord.build_instance_from_template(
            self.context,
            template_id,
            connection_record,
            pres_ex_record.presentation_exchange_id
        )

        # Build negotiation offer agent message
        agent_message = DataAgreementNegotiationOfferMessage(body=da_instance_model)

        return agent_message

    async def process_decorator_with_da_offer_message(
        self,
        decorator_set: DecoratorSet,
        data_ex_record: typing.Union[V10CredentialExchange, V10PresentationExchange],
        connection_record: ConnectionRecord
    ) -&gt; DataAgreementInstanceRecord:
        &#34;&#34;&#34;Process data agreement context decorator with DA offer message

        Args:
            decorator_set (DecoratorSet): Decorator set
            cred_ex_record (V10CredentialExchange): Credential exchange record
            connection_record (ConnectionRecord): Connection record

        Returns:
            DataAgreementInstanceRecord: Data agreement instance record.
        &#34;&#34;&#34;

        # Check if data agreement context decorator is present
        if &#34;data-agreement-context&#34; not in decorator_set.keys():
            self._logger.info(
                &#34;Data agreement context decorator is not present in the incoming message.&#34;)
            return None

        # Deserialize data agreement context decorator
        da_decorator_dict = decorator_set[&#34;data-agreement-context&#34;]
        da_decorator_model: DataAgreementContextDecorator = \
            DataAgreementContextDecorator.deserialize(da_decorator_dict)

        assert da_decorator_model.message_type == &#34;protocol&#34;, \
            &#34;DA context message type must be &#39;protocol&#39;.&#34;

        message_type = da_decorator_model.message.get(&#34;@type&#34;)
        assert DATA_AGREEMENT_NEGOTIATION_OFFER in message_type, \
            f&#34;DA context protocol message type must be &#39;{DATA_AGREEMENT_NEGOTIATION_OFFER}&#39;&#34;

        da_offer_message: DataAgreementNegotiationOfferMessage = \
            DataAgreementNegotiationOfferMessage.deserialize(da_decorator_model.message)

        # Build and save data agreement instance record.
        if data_ex_record.__class__.__name__ == V10CredentialExchange.__name__:
            return await DataAgreementInstanceRecord.build_instance_from_da_offer(
                self.context,
                da_offer_message,
                connection_record,
                data_ex_record.credential_exchange_id
            )
        else:
            return await DataAgreementInstanceRecord.build_instance_from_da_offer(
                self.context,
                da_offer_message,
                connection_record,
                data_ex_record.presentation_exchange_id
            )

    async def process_decorator_with_da_accept_message(
        self,
        decorator_set: DecoratorSet,
        data_ex_record: typing.Union[V10CredentialExchange, V10PresentationExchange],
        connection_record: ConnectionRecord
    ) -&gt; DataAgreementInstanceRecord:
        &#34;&#34;&#34;Process data agreement context decorator with DA accept message

        Args:
            decorator_set (DecoratorSet): Decorator set
            data_ex_record (typing.Union[V10CredentialExchange, V10PresentationExchange]):
                Data exchange record.
            connection_record (ConnectionRecord): Connection record

        Returns:
            DataAgreementInstanceRecord: Data agreement instance record.
        &#34;&#34;&#34;

        # Check if data agreement context decorator is present
        if &#34;data-agreement-context&#34; not in decorator_set.keys():
            self._logger.info(
                &#34;Data agreement context decorator is not present in the incoming message.&#34;)
            return None

        # Deserialize data agreement context decorator
        da_decorator_dict = decorator_set[&#34;data-agreement-context&#34;]
        da_decorator_model: DataAgreementContextDecorator = \
            DataAgreementContextDecorator.deserialize(da_decorator_dict)

        assert da_decorator_model.message_type == &#34;protocol&#34;, \
            &#34;DA context message type must be &#39;protocol&#39;.&#34;

        message_type = da_decorator_model.message.get(&#34;@type&#34;)
        assert DATA_AGREEMENT_NEGOTIATION_ACCEPT in message_type, \
            f&#34;DA context protocol message type must be &#39;{DATA_AGREEMENT_NEGOTIATION_ACCEPT}&#39;&#34;

        da_accept_message: DataAgreementNegotiationAcceptMessage = \
            DataAgreementNegotiationAcceptMessage.deserialize(da_decorator_model.message)

        # Build and save data agreement instance record.
        if data_ex_record.__class__.__name__ == V10CredentialExchange.__name__:
            # Build and save data agreement instance record.
            instance_record = await DataAgreementInstanceRecord.update_instance_from_da_accept(
                self.context,
                da_accept_message,
                data_ex_record.credential_exchange_id
            )
        else:
            # Build and save data agreement instance record.
            instance_record = await DataAgreementInstanceRecord.update_instance_from_da_accept(
                self.context,
                da_accept_message,
                data_ex_record.presentation_exchange_id
            )

        # Anchor da to blockchain.
        await self.anchor_da_instance_to_blockchain_async_task(instance_record.instance_id)

        return instance_record

    async def build_data_agreement_negotiation_accept_by_instance_id(
        self,
        instance_id: str,
        connection_record: ConnectionRecord
    ) -&gt; DataAgreementNegotiationAcceptMessage:
        # Counter sign da
        (da_instance_record, da_instance_model) = \
            await DataAgreementInstanceRecord.counter_sign_instance(
                self.context,
                instance_id,
                connection_record,
        )

        # Build negotiation accept agent message
        agent_message = DataAgreementNegotiationAcceptMessage(body=da_instance_model)

        return agent_message

    async def build_data_agreement_accept_for_data_ex_record(
        self,
        connection_record: ConnectionRecord,
        data_ex_record: typing.Union[V10CredentialExchange, V10PresentationExchange],
    ) -&gt; DataAgreementNegotiationAcceptMessage:
        &#34;&#34;&#34;Build data agreement accept message for credential exchange.

        Args:
            context (InjectionContext): Injection context to be used.
            template_id (str): Data agreement template identifier.
            connection_record (ConnectionRecord): Connection record.
            data_ex_record (typing.Union[V10CredentialExchange, V10PresentationExchange]):
                Data exchange record.

        Returns:
            DataAgreementNegotiationAcceptMessage: Accept message.
        &#34;&#34;&#34;
        if data_ex_record.__class__.__name__ == V10CredentialExchange.__name__:
            # Fetch data agreement instance matching credential exchange record.
            instance_record = await DataAgreementInstanceRecord.fetch_by_data_ex_id(
                self.context,
                data_ex_record.credential_exchange_id
            )
        else:
            # Fetch data agreement instance matching credential exchange record.
            instance_record = await DataAgreementInstanceRecord.fetch_by_data_ex_id(
                self.context,
                data_ex_record.presentation_exchange_id
            )

        # Build instance record
        (da_instance_record, da_instance_model) = \
            await DataAgreementInstanceRecord.counter_sign_instance(
            self.context,
            instance_record.instance_id,
            connection_record
        )

        # Build negotiation accept agent message
        agent_message = DataAgreementNegotiationAcceptMessage(body=da_instance_model)

        return agent_message

    async def query_data_agreement_instances(
        self,
        instance_id: str,
        template_id: str,
        template_version: str,
        method_of_use: str,
        third_party_data_sharing: str,
        data_ex_id: str,
        data_subject_did: str,
        page: int = 1,
        page_size: int = 10
    ) -&gt; PaginationResult:
        &#34;&#34;&#34;Query data agreement instances

        Args:
            instance_id (str): Instance identifier
            template_id (str): Template identifier
            template_version (str): Template version
            method_of_use (str): Method of use
            third_party_data_sharing (str): Third party data sharing
            data_ex_id (str): Data exchange id
            data_subject_did (str): Data subject did
            page (int, optional): Page. Defaults to 1.
            page_size (int, optional): Page size. Defaults to 10.

        Returns:
            PaginationResult: Pagination result
        &#34;&#34;&#34;
        # Query by version is only possible if the template id is provided
        if template_version:
            assert template_id, &#34;Template identifier is required to query by version&#34;

        # Tag filter
        tag_filter = {
            &#34;instance_id&#34;: instance_id,
            &#34;template_id&#34;: template_id,
            &#34;template_version&#34;: template_version,
            &#34;method_of_use&#34;: method_of_use,
            &#34;third_party_data_sharing&#34;: third_party_data_sharing,
            &#34;data_ex_id&#34;: data_ex_id,
            &#34;data_subject_did&#34;: data_subject_did
        }

        tag_filter = drop_none_dict(tag_filter)

        records = await DataAgreementInstanceRecord.query(
            context=self.context,
            tag_filter=tag_filter
        )

        records = sorted(records, key=lambda k: k.created_at, reverse=True)

        paginate_result = paginate_records(records, page, page_size)

        return paginate_result

    async def delete_da_instance_by_data_ex_id(
        self,
        cred_ex_id: str
    ) -&gt; None:
        &#34;&#34;&#34;Delete da instance by cred ex id.

        Args:
            cred_ex_id (str): Credential exchange identifier.
        &#34;&#34;&#34;

        # Data agreement instance
        instance = await DataAgreementInstanceRecord.fetch_by_data_ex_id(
            self.context,
            cred_ex_id
        )

        await instance.delete_record(self.context)

    async def anchor_da_instance_to_blockchain_async_task_callback(
        self, *args, **kwargs
    ):
        &#34;&#34;&#34;Anchor DA instance to blockchain async task callback function
        &#34;&#34;&#34;

        # Obtain the completed task.
        completed_task: CompletedTask = args[0]

        # Obtain the results from the task.
        (instance_id, mydata_did, tx_hash, tx_receipt) = completed_task.task.result()

        tag_filter = {
            &#34;instance_id&#34;: instance_id
        }

        # Fetch data agreement instance record.
        da_instance_records = await DataAgreementInstanceRecord.query(
            self.context,
            tag_filter,
        )

        assert da_instance_records, &#34;Data agreement instance not found.&#34;

        da_instance_record: DataAgreementInstanceRecord = da_instance_records[0]

        transaction_receipt = json.loads(to_json(tx_receipt))
        transaction_hash = transaction_receipt.get(&#34;transactionHash&#34;)

        # Update the data agreement with blockchain metadata.
        da_instance_record.blink = f&#34;blink:ethereum:rinkeby:{transaction_hash}&#34;
        da_instance_record.mydata_did = mydata_did
        da_instance_record.blockchain_receipt = transaction_receipt

        await da_instance_record.save(self.context)

    async def anchor_da_instance_to_blockchain_async_task(
        self,
        instance_id: str
    ):
        &#34;&#34;&#34;Async task to anchor da instance to blockchain.

        Args:
            instance_id (str): Instance id
        &#34;&#34;&#34;
        pending_task = await self.add_task(
            self.context,
            self.anchor_da_instance_to_blockchain(instance_id),
            self.anchor_da_instance_to_blockchain_async_task_callback
        )
        self._logger.info(pending_task)

    async def anchor_da_instance_to_blockchain(
        self,
        instance_id: str
    ) -&gt; None:
        &#34;&#34;&#34;Anchor da instance to blockchain.

        Args:
            instance_id (str): Instance id
        &#34;&#34;&#34;

        eth_client: EthereumClient = await self.context.inject(EthereumClient)

        tag_filter = {
            &#34;instance_id&#34;: instance_id
        }

        # Fetch data agreement instance record.
        da_instance_records = await DataAgreementInstanceRecord.query(
            self.context,
            tag_filter,
        )

        assert da_instance_records, &#34;Data agreement instance not found.&#34;

        da_instance_record: DataAgreementInstanceRecord = da_instance_records[0]
        da_model: DataAgreementInstanceModel = \
            DataAgreementInstanceModel.deserialize(da_instance_record.data_agreement)

        did_mydata_builder = DIDMyDataBuilder(
            artefact=da_model
        )

        (tx_hash, tx_receipt) = await eth_client.emit_da_did(did_mydata_builder.mydata_did)

        return (da_instance_record.instance_id, did_mydata_builder.mydata_did, tx_hash, tx_receipt)

    async def add_task(self,
                       context: InjectionContext,
                       coro: typing.Coroutine,
                       task_complete: typing.Callable = None,
                       ident: str = None) -&gt; PendingTask:
        &#34;&#34;&#34;
        Add a new task to the queue, delaying execution if busy.

        Args:
            context: Injection context to be used.
            coro: The coroutine to run
            task_complete: A callback to run on completion
            ident: A string identifier for the task

        Returns: a future resolving to the asyncio task instance once queued
        &#34;&#34;&#34;
        loop = asyncio.get_event_loop()
        pack_format: PackWireFormat = await context.inject(BaseWireFormat, required=False)
        return pack_format.task_queue.put(coro, lambda x: loop.create_task(task_complete(x)), ident)

    async def sample_queue_snippet(self):
        &#34;&#34;&#34;Sample queue snippet&#34;&#34;&#34;
        pending_task = await self.add_task(self.context,
                                           self.long_running_task(),
                                           self.queue_callback)
        print(pending_task)

    async def long_running_task(self):
        &#34;&#34;&#34;Sample long running task&#34;&#34;&#34;
        print(&#34;Long running task commenced...&#34;)
        await asyncio.sleep(10)
        return &#34;msg: Hi from long running task!&#34;

    async def queue_callback(self, *args, **kwargs):
        &#34;&#34;&#34;Sample queue callback function&#34;&#34;&#34;
        print(&#34;Recieved call back...&#34;)
        completed_task: CompletedTask = args[0]
        result: str = completed_task.task.result()

        print(result)
        print(self.context)

        # Send a basic message to available active connection
        tag_filter = {}
        post_filter = {&#34;state&#34;: &#34;active&#34;}
        records: typing.List[ConnectionRecord] = await ConnectionRecord.query(
            self.context,
            tag_filter,
            post_filter
        )

        responder: BaseResponder = await self.context.inject(BaseResponder, required=False)
        basic_message = BasicMessage(content=&#34;Triggered by task queue callback...&#34;)
        if responder:
            for record in records:
                await responder.send(basic_message, connection_id=record.connection_id)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="dexa_sdk.managers.ada_manager.V2ADAManager"><code class="flex name class">
<span>class <span class="ident">V2ADAManager</span></span>
<span>(</span><span>context:Â aries_cloudagent.config.injection_context.InjectionContext)</span>
</code></dt>
<dd>
<div class="desc"><p>Manages ADA related functions (v2)</p>
<p>Initialise ADA manager</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>context</code></strong> :&ensp;<code>InjectionContext</code></dt>
<dd><em>description</em></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class V2ADAManager:
    &#34;&#34;&#34;Manages ADA related functions (v2)
    &#34;&#34;&#34;

    def __init__(self, context: InjectionContext) -&gt; None:
        &#34;&#34;&#34;Initialise ADA manager

        Args:
            context (InjectionContext): _description_
        &#34;&#34;&#34;

        # Injection context
        self._context = context

        # Logger
        self._logger = logger

    @ property
    def context(self) -&gt; InjectionContext:
        &#34;&#34;&#34;Accessor for injection context

        Returns:
            InjectionContext: Injection context
        &#34;&#34;&#34;
        return self._context

    async def create_and_store_ledger_payloads_for_da_template(
            self,
            *,
            template_record: DataAgreementTemplateRecord,
            pd_records: typing.List[PersonalDataRecord] = None,
            schema_id: str = None
    ) -&gt; DataAgreementTemplateRecord:
        &#34;&#34;&#34;Create and store ledger payloads for a da template

        Args:
            template_record (DataAgreementTemplateRecord): Data agreement template record
            pd_records (typing.List[PersonalDataRecord]): Personal data records
            schema_id (str): Schema identifier if available

        Returns:
            DataAgreementTemplateRecord: Record with ledger payloads
        &#34;&#34;&#34;
        if template_record.method_of_use == DataAgreementTemplateRecord.METHOD_OF_USE_DATA_SOURCE:

            # Create schema if not existing
            if not schema_id:
                data_agreement = template_record.data_agreement
                # Schema name
                schema_name = data_agreement.get(&#34;purpose&#34;)
                # Schema version
                schema_version = data_agreement.get(&#34;version&#34;)
                # Schema attributes
                attributes = [
                    personal_data.attribute_name
                    for personal_data in pd_records
                ]
                # Creata schema and anchor to ledger
                (schema_id, schema_def) = await create_schema_def_and_anchor_to_ledger(
                    context=self.context,
                    schema_name=schema_name,
                    schema_version=schema_version,
                    attributes=attributes
                )

            # Create credential definition and anchor to ledger

            (cred_def_id, cred_def, novel) = await create_cred_def_and_anchor_to_ledger(
                context=self.context,
                schema_id=schema_id
            )

            template_record.cred_def_id = cred_def_id
            template_record.schema_id = schema_id
            await template_record.save(self.context)

        else:
            data_agreement = template_record.data_agreement

            # Usage purpose
            usage_purpose = data_agreement.get(&#34;purpose&#34;)

            # Usage purpose description
            usage_purpose_description = data_agreement.get(&#34;purposeDescription&#34;)

            # Data agreement template version
            da_template_version = data_agreement.get(&#34;version&#34;)

            # Create presentation request
            presentation_request = self.construct_presentation_request(
                usage_purpose=usage_purpose,
                usage_purpose_description=usage_purpose_description,
                da_template_version=da_template_version,
                personal_data=pd_records
            )

            template_record.presentation_request = presentation_request
            await template_record.save(self.context)

        return template_record

    def construct_presentation_request(
            self,
            *,
            usage_purpose: str,
            usage_purpose_description: str,
            da_template_version: str,
            personal_data: typing.List[PersonalDataRecord]
    ) -&gt; dict:
        &#34;&#34;&#34;
        Construct presentation request

        Args:
            usage_purpose: Usage purpose.
            usage_purpose_description: Usage purpose description.
            da_template_version: Data agreement template version.
            personal_data: List of personal data.

        Returns:
            :rtype: dict: Proof request

        &#34;&#34;&#34;

        presentation_request_dict: dict = {
            &#34;name&#34;: usage_purpose,
            &#34;comment&#34;: usage_purpose_description,
            &#34;version&#34;: da_template_version,
            &#34;requested_attributes&#34;: {},
            &#34;requested_predicates&#34;: {}
        }

        index = 1
        requested_attributes = {}

        for pd in personal_data:

            requested_attributes[&#34;additionalProp&#34; + str(index)] = {
                &#34;name&#34;: pd.attribute_name,
                &#34;restrictions&#34;: pd.restrictions if pd.restrictions else []
            }
            if pd.restrictions:
                restrictions = [
                    {
                        &#34;schema_id&#34;: restriction.get(&#34;schemaId&#34;),
                        &#34;cred_def_id&#34;: restriction.get(&#34;credDefId&#34;)
                    }
                    for restriction in pd.restrictions
                ]
                requested_attributes[&#34;additionalProp&#34; +
                                     str(index)].update({&#34;restrictions&#34;: restrictions})
            else:
                requested_attributes[&#34;additionalProp&#34; + str(index)].update({})
            index += 1

        presentation_request_dict[&#34;requested_attributes&#34;] = requested_attributes

        return presentation_request_dict

    async def create_and_store_da_template_in_wallet(
            self,
            data_agreement: dict,
            *,
            publish_flag: bool = True,
            schema_id: str = None
    ) -&gt; DataAgreementTemplateRecord:
        &#34;&#34;&#34;Create and store data agreement template in wallet

        Args:
            data_agreement (dict): Data agreement
            publish_flag (bool): Publish flag
            schema_id (str): Schema identifier
        &#34;&#34;&#34;

        # Temp hack
        template_version = &#34;1.0.0&#34;
        template_id = str(uuid.uuid4())
        data_agreement.update({&#34;@context&#34;: DA_DEFAULT_CONTEXT})
        data_agreement.update({&#34;@id&#34;: template_id})
        data_agreement.update({&#34;@type&#34;: DA_TYPE})
        data_agreement.update({&#34;version&#34;: template_version})

        try:
            # Validate the data agreement.
            data_agreement: DataAgreementModel = DataAgreementModel.deserialize(data_agreement)
        except ValidationError as err:
            raise V2ADAManagerError(
                f&#34;Failed to create data agreement; Reason: {err}&#34;
            )

        # Create personal data records
        pds = data_agreement.personal_data
        pd_records = []
        pd_models_with_id = []
        for pd in pds:
            pd_record: PersonalDataRecord = \
                await PersonalDataRecord.build_and_save_record_from_pd_model(
                    self.context,
                    template_id,
                    template_version,
                    pd
                )
            pd_records.append(pd_record)
            pd_models_with_id.append(pd_record.convert_record_to_pd_model())

        # Update the personal data with attribute identifiers to the agreement
        data_agreement.personal_data = pd_models_with_id

        # Create template record
        record = DataAgreementTemplateRecord(
            template_id=template_id,
            template_version=template_version,
            state=DataAgreementTemplateRecord.STATE_DEFINITION,
            method_of_use=data_agreement.method_of_use,
            data_agreement=data_agreement.serialize(),
            publish_flag=bool_to_str(publish_flag),
            schema_id=schema_id,
            existing_schema_flag=bool_to_str(True) if schema_id else bool_to_str(False),
            third_party_data_sharing=bool_to_str(
                data_agreement.data_policy.third_party_data_sharing)
        )

        await record.save(self.context)

        if publish_flag:
            # Create ledger payloads
            record = await self.create_and_store_ledger_payloads_for_da_template(
                template_record=record,
                pd_records=pd_records,
                schema_id=schema_id
            )

        return record

    async def query_da_templates_in_wallet(
            self,
            *,
            template_id: str = None,
            delete_flag: str = &#34;false&#34;,
            method_of_use: str = None,
            publish_flag: str = &#34;true&#34;,
            template_version: str = None,
            latest_version_flag: str = &#34;true&#34;,
            third_party_data_sharing: str = &#34;false&#34;,
            page: int = 1,
            page_size: int = 10,
    ) -&gt; PaginationResult:
        &#34;&#34;&#34;Query DA templates in wallet

        Args:
            template_id (str, optional): Template identifier. Defaults to None.
            delete_flag (str, optional): Delete flag. Defaults to false.
            method_of_use (str, optional): Method of use. Defaults to None.
            publish_flag (str, optional): Publish flag. Defaults to true.
            latest_version_flag (str, optional): Latest version flag. Defaults to true.
            template_version (str, optional): Template version. Defaults to None.
            third_party_data_sharing (str, optional): Third party data sharing.
                Defaults to false.
            page (int, optional): Page. Defaults to 1.

        Returns:
            PaginationResult: Pagination results.
        &#34;&#34;&#34;

        # Sample queue snippet
        await self.sample_queue_snippet()

        # Query by version is only possible if the template id is provided
        if template_version:
            assert template_id, &#34;Template identifier is required to query by version&#34;

        # Tag filter
        tag_filter = {
            &#34;delete_flag&#34;: delete_flag,
            &#34;publish_flag&#34;: publish_flag,
            &#34;method_of_use&#34;: method_of_use,
            &#34;template_id&#34;: template_id,
            &#34;template_version&#34;: template_version,
            &#34;latest_version_flag&#34;: latest_version_flag,
            &#34;third_party_data_sharing&#34;: third_party_data_sharing
        }

        tag_filter = drop_none_dict(tag_filter)

        records = await DataAgreementTemplateRecord.query(
            context=self.context,
            tag_filter=tag_filter
        )

        records = sorted(records, key=lambda k: k.created_at, reverse=True)

        paginate_result = paginate_records(records, page, page_size)

        return paginate_result

    async def publish_da_template_in_wallet(self,
                                            template_id: str) -&gt; DataAgreementTemplateRecord:
        &#34;&#34;&#34;Publish data agreement template.

        Args:
            template_id (str): Template identifier

        Returns:
            DataAgreementTemplateRecord: Template record.
        &#34;&#34;&#34;

        tag_filter = {
            &#34;delete_flag&#34;: bool_to_str(False),
            &#34;publish_flag&#34;: bool_to_str(False),
            &#34;latest_version_flag&#34;: bool_to_str(True),
            &#34;template_id&#34;: template_id
        }

        records = await DataAgreementTemplateRecord.query(
            context=self.context,
            tag_filter=tag_filter
        )

        assert records, &#34;Data agreement template not found.&#34;

        record: DataAgreementTemplateRecord = records[0]

        await record.publish_template(self.context)

        pd_records = await record.fetch_personal_data_records(self.context)

        # Create ledger payloads
        record = await self.create_and_store_ledger_payloads_for_da_template(
            template_record=record,
            pd_records=pd_records,
            schema_id=record.schema_id
        )

        return record

    async def update_and_store_da_template_in_wallet(
            self,
            template_id: str,
            data_agreement: dict,
            *,
            publish_flag: bool = True,
            schema_id: str = None
    ) -&gt; DataAgreementTemplateRecord:
        &#34;&#34;&#34;Update and store data agreement template in wallet.

        Args:
            template_id (str): Template identifier
            data_agreement (dict): Data agreement
            publish_flag (bool): Publish flag
            schema_id (str): Schema identifier

        Returns:
            DataAgreementTemplateRecord: Updated record.
        &#34;&#34;&#34;

        # Tag filter
        tag_filter = {
            &#34;delete_flag&#34;: bool_to_str(False),
            &#34;template_id&#34;: template_id,
            &#34;latest_version_flag&#34;: bool_to_str(True)
        }

        # Fetch data agreement record
        record: DataAgreementTemplateRecord = \
            await DataAgreementTemplateRecord.retrieve_by_tag_filter(self.context, tag_filter)

        # Validate the data agreement.
        previous_da: DataAgreementModel = DataAgreementModel.deserialize(record.data_agreement)

        assert previous_da.method_of_use == data_agreement.get(
            &#34;methodOfUse&#34;), &#34;Method of use cannot be updated.&#34;

        assert previous_da.data_policy.third_party_data_sharing \
            == data_agreement.get(&#34;dataPolicy&#34;).get(&#34;thirdPartyDataSharing&#34;), \
            &#34;Third party data sharing cannot be updated.&#34;

        # Copy the id, version from previous da to new da
        template_version = bump_major_for_semver_string(previous_da.version)
        template_id = previous_da.id
        data_agreement.update({&#34;@context&#34;: DA_DEFAULT_CONTEXT})
        data_agreement.update({&#34;@type&#34;: DA_TYPE})
        data_agreement.update({&#34;@id&#34;: template_id})
        data_agreement.update({&#34;version&#34;: template_version})

        updated_da: DataAgreementModel = DataAgreementModel.deserialize(data_agreement)

        # Create personal data records
        pds = updated_da.personal_data
        pd_records = []
        pd_models_with_id = []
        for pd in pds:
            pd_record: PersonalDataRecord = \
                await PersonalDataRecord.build_and_save_record_from_pd_model(
                    self.context,
                    template_id,
                    template_version,
                    pd
                )
            pd_records.append(pd_record)
            pd_models_with_id.append(pd_record.convert_record_to_pd_model())

        # Update the personal data with attribute identifiers to the agreement
        updated_da.personal_data = pd_models_with_id

        record.data_agreement = updated_da.serialize()
        record.publish_flag = bool_to_str(publish_flag)
        record.schema_id = schema_id
        record.existing_schema_flag = bool_to_str(True) if schema_id else bool_to_str(False)
        record.template_version = template_version

        await record.upgrade(self.context)

        if publish_flag:
            # Create ledger payloads
            record = await self.create_and_store_ledger_payloads_for_da_template(
                template_record=record,
                pd_records=pd_records,
                schema_id=schema_id
            )

        return record

    async def delete_da_template_in_wallet(self, template_id: str) -&gt; str:
        &#34;&#34;&#34;Deactivate DA template in wallet.

        This is not a normal delete operation of a specific version of template. Instead it
        marks the template with latest version flag as deleted i.e. Any version under this
        template is no longer active.

        Args:
            template_id (str): Template identifier
            template_version (str): Template version

        Returns:
            record_id: Record identifier for the deleted template.
        &#34;&#34;&#34;
        # Query for the data agreement by id
        data_agreement_records: DataAgreementTemplateRecord = \
            await DataAgreementTemplateRecord.non_deleted_template_by_id(
                self.context,
                template_id
            )

        assert data_agreement_records, &#34;Data agreement template not found.&#34;
        data_agreement_record = data_agreement_records[0]

        # Mark the data agreement as deleted and save.
        return await data_agreement_record.delete_template(self.context)

    async def query_pd_of_da_template_from_wallet(self,
                                                  template_id: str = None,
                                                  method_of_use: str = None,
                                                  third_party_data_sharing: str = None,
                                                  page: int = 1,
                                                  page_size: int = 10,
                                                  ) -&gt; PaginationResult:
        &#34;&#34;&#34;Query personal data for DA template.

        Args:
            template_id (str): Template identifier
            page (int, optional): Page number. Defaults to 1.
            page_size (int, optional): Page size. Defaults to 10.

        Returns:
            PaginationResult: Pagination results
        &#34;&#34;&#34;

        # Tag filter
        tag_filter = {
            &#34;delete_flag&#34;: bool_to_str(False),
            &#34;method_of_use&#34;: method_of_use,
            &#34;template_id&#34;: template_id,
            &#34;latest_version_flag&#34;: bool_to_str(True),
            &#34;third_party_data_sharing&#34;: third_party_data_sharing
        }

        tag_filter = drop_none_dict(tag_filter)

        records = await DataAgreementTemplateRecord.query(
            context=self.context,
            tag_filter=tag_filter
        )

        records = sorted(records, key=lambda k: k.created_at, reverse=True)

        # Fetch personal data records
        pd_records = []
        for record in records:
            pd_records.extend(await record.fetch_personal_data_records(self.context))

        paginate_result = paginate_records(pd_records, page, page_size)

        return paginate_result

    async def update_personal_data_description(self,
                                               attribute_id: str,
                                               desc: str) -&gt; PersonalDataRecord:
        &#34;&#34;&#34;Update personal data description

        Args:
            attribute_id (str): Attribute id
            desc (str): Description

        Returns:
            PersonalDataRecord: Personal data record
        &#34;&#34;&#34;

        # Fetch personal data record by id
        pd_record: PersonalDataRecord = await PersonalDataRecord.retrieve_by_id(
            self.context,
            attribute_id
        )

        # Fetch the associated data agreement record
        da_template_record: DataAgreementTemplateRecord = \
            await DataAgreementTemplateRecord.latest_template_by_id(
                self.context,
                pd_record.data_agreement_template_id
            )

        assert da_template_record, &#34;Matching data agreement template not found.&#34;
        assert da_template_record.template_version == \
            pd_record.data_agreement_template_version, \
            &#34;Matching data agreement template with same version not found.&#34;

        # Update the personal data record.
        pd_record.attribute_description = desc
        await pd_record.save(self.context)

        pd_model: DataAgreementPersonalDataModel = pd_record.convert_record_to_pd_model()

        # Update the data agreement record with new personal data.
        da: DataAgreementModel = DataAgreementModel.deserialize(da_template_record.data_agreement)
        # Iterate through the existing personal data in data agreements
        # And update the personal data matching the attribute id
        da_pds = []
        for da_pd in da.personal_data:
            if da_pd.attribute_id != pd_model.attribute_id:
                da_pds.append(da_pd)
        da_pds.append(pd_model)
        da.personal_data = da_pds

        da_template_record.data_agreement = da.serialize()
        await da_template_record.save(self.context)

        return pd_record

    async def delete_personal_data(self, attribute_id: str) -&gt; None:
        &#34;&#34;&#34;Delete personal data record.

        On deleting personal data record, the associated data agreement template is
        updated. If the personal data record deleted, is the last one in the template,
        proceed to delete the template record.

        Args:
            attribute_id (str): _description_
        &#34;&#34;&#34;

        # Fetch personal data record by id
        pd_record: PersonalDataRecord = await PersonalDataRecord.retrieve_by_id(
            self.context,
            attribute_id
        )

        # Fetch the associated data agreement record
        da_template_record: DataAgreementTemplateRecord = \
            await DataAgreementTemplateRecord.latest_template_by_id(
                self.context,
                pd_record.data_agreement_template_id
            )

        assert da_template_record, &#34;Matching data agreement template not found.&#34;
        assert da_template_record.template_version == \
            pd_record.data_agreement_template_version, \
            &#34;Matching data agreement template with same version not found.&#34;

        # Delete personal data record
        await pd_record.delete_record(self.context)

        da: DataAgreementModel = DataAgreementModel.deserialize(da_template_record.data_agreement)

        # Iterate through the existing personal data in data agreements
        # And remove the deleted personal data.
        da_pds = []
        for da_pd in da.personal_data:
            if da_pd.attribute_id != pd_record.attribute_id:
                da_pds.append(da_pd)

        da.personal_data = da_pds

        da_template_record.data_agreement = da.serialize()
        await da_template_record.upgrade(self.context)

        # Mark data agreement template as deleted if number of personal data is zero
        if len(da_pds) == 0:
            await da_template_record.delete_template(self.context)
        else:

            pd_records = await da_template_record.fetch_personal_data_records(self.context)

            if da_template_record._publish_flag:
                # Create ledger payloads
                await self.create_and_store_ledger_payloads_for_da_template(
                    template_record=da_template_record,
                    pd_records=pd_records,
                    schema_id=None
                )

    async def build_data_agreement_offer_for_credential_exchange(
        self,
        template_id: str,
        connection_record: ConnectionRecord,
        cred_ex_record: V10CredentialExchange,
    ) -&gt; DataAgreementNegotiationOfferMessage:
        &#34;&#34;&#34;Build data agreement offer for credential exchange.

        Args:
            context (InjectionContext): Injection context to be used.
            template_id (str): Data agreement template identifier.
            connection_record (ConnectionRecord): Connection record.
            cred_ex_record (V10CredentialExchange): Credential exchange record.

        Returns:
            DataAgreementNegotiationOfferMessage: Offer message.
        &#34;&#34;&#34;

        # Build instance record
        (da_instance_record, da_instance_model) = \
            await DataAgreementInstanceRecord.build_instance_from_template(
            self.context,
            template_id,
            connection_record,
            cred_ex_record.credential_exchange_id
        )

        # Build negotiation offer agent message
        agent_message = DataAgreementNegotiationOfferMessage(body=da_instance_model)

        return agent_message

    async def build_data_agreement_offer_for_presentation_exchange(
        self,
        template_id: str,
        connection_record: ConnectionRecord,
        pres_ex_record: V10PresentationExchange,
    ) -&gt; DataAgreementNegotiationOfferMessage:
        &#34;&#34;&#34;Build data agreement offer for presentaton exchange.

        Args:
            context (InjectionContext): Injection context to be used.
            template_id (str): Data agreement template identifier.
            connection_record (ConnectionRecord): Connection record.
            pres_ex_record (V10PresentationExchange): Presentation exchange record.

        Returns:
            DataAgreementNegotiationOfferMessage: Offer message.
        &#34;&#34;&#34;

        # Build instance record
        (da_instance_record, da_instance_model) = \
            await DataAgreementInstanceRecord.build_instance_from_template(
            self.context,
            template_id,
            connection_record,
            pres_ex_record.presentation_exchange_id
        )

        # Build negotiation offer agent message
        agent_message = DataAgreementNegotiationOfferMessage(body=da_instance_model)

        return agent_message

    async def process_decorator_with_da_offer_message(
        self,
        decorator_set: DecoratorSet,
        data_ex_record: typing.Union[V10CredentialExchange, V10PresentationExchange],
        connection_record: ConnectionRecord
    ) -&gt; DataAgreementInstanceRecord:
        &#34;&#34;&#34;Process data agreement context decorator with DA offer message

        Args:
            decorator_set (DecoratorSet): Decorator set
            cred_ex_record (V10CredentialExchange): Credential exchange record
            connection_record (ConnectionRecord): Connection record

        Returns:
            DataAgreementInstanceRecord: Data agreement instance record.
        &#34;&#34;&#34;

        # Check if data agreement context decorator is present
        if &#34;data-agreement-context&#34; not in decorator_set.keys():
            self._logger.info(
                &#34;Data agreement context decorator is not present in the incoming message.&#34;)
            return None

        # Deserialize data agreement context decorator
        da_decorator_dict = decorator_set[&#34;data-agreement-context&#34;]
        da_decorator_model: DataAgreementContextDecorator = \
            DataAgreementContextDecorator.deserialize(da_decorator_dict)

        assert da_decorator_model.message_type == &#34;protocol&#34;, \
            &#34;DA context message type must be &#39;protocol&#39;.&#34;

        message_type = da_decorator_model.message.get(&#34;@type&#34;)
        assert DATA_AGREEMENT_NEGOTIATION_OFFER in message_type, \
            f&#34;DA context protocol message type must be &#39;{DATA_AGREEMENT_NEGOTIATION_OFFER}&#39;&#34;

        da_offer_message: DataAgreementNegotiationOfferMessage = \
            DataAgreementNegotiationOfferMessage.deserialize(da_decorator_model.message)

        # Build and save data agreement instance record.
        if data_ex_record.__class__.__name__ == V10CredentialExchange.__name__:
            return await DataAgreementInstanceRecord.build_instance_from_da_offer(
                self.context,
                da_offer_message,
                connection_record,
                data_ex_record.credential_exchange_id
            )
        else:
            return await DataAgreementInstanceRecord.build_instance_from_da_offer(
                self.context,
                da_offer_message,
                connection_record,
                data_ex_record.presentation_exchange_id
            )

    async def process_decorator_with_da_accept_message(
        self,
        decorator_set: DecoratorSet,
        data_ex_record: typing.Union[V10CredentialExchange, V10PresentationExchange],
        connection_record: ConnectionRecord
    ) -&gt; DataAgreementInstanceRecord:
        &#34;&#34;&#34;Process data agreement context decorator with DA accept message

        Args:
            decorator_set (DecoratorSet): Decorator set
            data_ex_record (typing.Union[V10CredentialExchange, V10PresentationExchange]):
                Data exchange record.
            connection_record (ConnectionRecord): Connection record

        Returns:
            DataAgreementInstanceRecord: Data agreement instance record.
        &#34;&#34;&#34;

        # Check if data agreement context decorator is present
        if &#34;data-agreement-context&#34; not in decorator_set.keys():
            self._logger.info(
                &#34;Data agreement context decorator is not present in the incoming message.&#34;)
            return None

        # Deserialize data agreement context decorator
        da_decorator_dict = decorator_set[&#34;data-agreement-context&#34;]
        da_decorator_model: DataAgreementContextDecorator = \
            DataAgreementContextDecorator.deserialize(da_decorator_dict)

        assert da_decorator_model.message_type == &#34;protocol&#34;, \
            &#34;DA context message type must be &#39;protocol&#39;.&#34;

        message_type = da_decorator_model.message.get(&#34;@type&#34;)
        assert DATA_AGREEMENT_NEGOTIATION_ACCEPT in message_type, \
            f&#34;DA context protocol message type must be &#39;{DATA_AGREEMENT_NEGOTIATION_ACCEPT}&#39;&#34;

        da_accept_message: DataAgreementNegotiationAcceptMessage = \
            DataAgreementNegotiationAcceptMessage.deserialize(da_decorator_model.message)

        # Build and save data agreement instance record.
        if data_ex_record.__class__.__name__ == V10CredentialExchange.__name__:
            # Build and save data agreement instance record.
            instance_record = await DataAgreementInstanceRecord.update_instance_from_da_accept(
                self.context,
                da_accept_message,
                data_ex_record.credential_exchange_id
            )
        else:
            # Build and save data agreement instance record.
            instance_record = await DataAgreementInstanceRecord.update_instance_from_da_accept(
                self.context,
                da_accept_message,
                data_ex_record.presentation_exchange_id
            )

        # Anchor da to blockchain.
        await self.anchor_da_instance_to_blockchain_async_task(instance_record.instance_id)

        return instance_record

    async def build_data_agreement_negotiation_accept_by_instance_id(
        self,
        instance_id: str,
        connection_record: ConnectionRecord
    ) -&gt; DataAgreementNegotiationAcceptMessage:
        # Counter sign da
        (da_instance_record, da_instance_model) = \
            await DataAgreementInstanceRecord.counter_sign_instance(
                self.context,
                instance_id,
                connection_record,
        )

        # Build negotiation accept agent message
        agent_message = DataAgreementNegotiationAcceptMessage(body=da_instance_model)

        return agent_message

    async def build_data_agreement_accept_for_data_ex_record(
        self,
        connection_record: ConnectionRecord,
        data_ex_record: typing.Union[V10CredentialExchange, V10PresentationExchange],
    ) -&gt; DataAgreementNegotiationAcceptMessage:
        &#34;&#34;&#34;Build data agreement accept message for credential exchange.

        Args:
            context (InjectionContext): Injection context to be used.
            template_id (str): Data agreement template identifier.
            connection_record (ConnectionRecord): Connection record.
            data_ex_record (typing.Union[V10CredentialExchange, V10PresentationExchange]):
                Data exchange record.

        Returns:
            DataAgreementNegotiationAcceptMessage: Accept message.
        &#34;&#34;&#34;
        if data_ex_record.__class__.__name__ == V10CredentialExchange.__name__:
            # Fetch data agreement instance matching credential exchange record.
            instance_record = await DataAgreementInstanceRecord.fetch_by_data_ex_id(
                self.context,
                data_ex_record.credential_exchange_id
            )
        else:
            # Fetch data agreement instance matching credential exchange record.
            instance_record = await DataAgreementInstanceRecord.fetch_by_data_ex_id(
                self.context,
                data_ex_record.presentation_exchange_id
            )

        # Build instance record
        (da_instance_record, da_instance_model) = \
            await DataAgreementInstanceRecord.counter_sign_instance(
            self.context,
            instance_record.instance_id,
            connection_record
        )

        # Build negotiation accept agent message
        agent_message = DataAgreementNegotiationAcceptMessage(body=da_instance_model)

        return agent_message

    async def query_data_agreement_instances(
        self,
        instance_id: str,
        template_id: str,
        template_version: str,
        method_of_use: str,
        third_party_data_sharing: str,
        data_ex_id: str,
        data_subject_did: str,
        page: int = 1,
        page_size: int = 10
    ) -&gt; PaginationResult:
        &#34;&#34;&#34;Query data agreement instances

        Args:
            instance_id (str): Instance identifier
            template_id (str): Template identifier
            template_version (str): Template version
            method_of_use (str): Method of use
            third_party_data_sharing (str): Third party data sharing
            data_ex_id (str): Data exchange id
            data_subject_did (str): Data subject did
            page (int, optional): Page. Defaults to 1.
            page_size (int, optional): Page size. Defaults to 10.

        Returns:
            PaginationResult: Pagination result
        &#34;&#34;&#34;
        # Query by version is only possible if the template id is provided
        if template_version:
            assert template_id, &#34;Template identifier is required to query by version&#34;

        # Tag filter
        tag_filter = {
            &#34;instance_id&#34;: instance_id,
            &#34;template_id&#34;: template_id,
            &#34;template_version&#34;: template_version,
            &#34;method_of_use&#34;: method_of_use,
            &#34;third_party_data_sharing&#34;: third_party_data_sharing,
            &#34;data_ex_id&#34;: data_ex_id,
            &#34;data_subject_did&#34;: data_subject_did
        }

        tag_filter = drop_none_dict(tag_filter)

        records = await DataAgreementInstanceRecord.query(
            context=self.context,
            tag_filter=tag_filter
        )

        records = sorted(records, key=lambda k: k.created_at, reverse=True)

        paginate_result = paginate_records(records, page, page_size)

        return paginate_result

    async def delete_da_instance_by_data_ex_id(
        self,
        cred_ex_id: str
    ) -&gt; None:
        &#34;&#34;&#34;Delete da instance by cred ex id.

        Args:
            cred_ex_id (str): Credential exchange identifier.
        &#34;&#34;&#34;

        # Data agreement instance
        instance = await DataAgreementInstanceRecord.fetch_by_data_ex_id(
            self.context,
            cred_ex_id
        )

        await instance.delete_record(self.context)

    async def anchor_da_instance_to_blockchain_async_task_callback(
        self, *args, **kwargs
    ):
        &#34;&#34;&#34;Anchor DA instance to blockchain async task callback function
        &#34;&#34;&#34;

        # Obtain the completed task.
        completed_task: CompletedTask = args[0]

        # Obtain the results from the task.
        (instance_id, mydata_did, tx_hash, tx_receipt) = completed_task.task.result()

        tag_filter = {
            &#34;instance_id&#34;: instance_id
        }

        # Fetch data agreement instance record.
        da_instance_records = await DataAgreementInstanceRecord.query(
            self.context,
            tag_filter,
        )

        assert da_instance_records, &#34;Data agreement instance not found.&#34;

        da_instance_record: DataAgreementInstanceRecord = da_instance_records[0]

        transaction_receipt = json.loads(to_json(tx_receipt))
        transaction_hash = transaction_receipt.get(&#34;transactionHash&#34;)

        # Update the data agreement with blockchain metadata.
        da_instance_record.blink = f&#34;blink:ethereum:rinkeby:{transaction_hash}&#34;
        da_instance_record.mydata_did = mydata_did
        da_instance_record.blockchain_receipt = transaction_receipt

        await da_instance_record.save(self.context)

    async def anchor_da_instance_to_blockchain_async_task(
        self,
        instance_id: str
    ):
        &#34;&#34;&#34;Async task to anchor da instance to blockchain.

        Args:
            instance_id (str): Instance id
        &#34;&#34;&#34;
        pending_task = await self.add_task(
            self.context,
            self.anchor_da_instance_to_blockchain(instance_id),
            self.anchor_da_instance_to_blockchain_async_task_callback
        )
        self._logger.info(pending_task)

    async def anchor_da_instance_to_blockchain(
        self,
        instance_id: str
    ) -&gt; None:
        &#34;&#34;&#34;Anchor da instance to blockchain.

        Args:
            instance_id (str): Instance id
        &#34;&#34;&#34;

        eth_client: EthereumClient = await self.context.inject(EthereumClient)

        tag_filter = {
            &#34;instance_id&#34;: instance_id
        }

        # Fetch data agreement instance record.
        da_instance_records = await DataAgreementInstanceRecord.query(
            self.context,
            tag_filter,
        )

        assert da_instance_records, &#34;Data agreement instance not found.&#34;

        da_instance_record: DataAgreementInstanceRecord = da_instance_records[0]
        da_model: DataAgreementInstanceModel = \
            DataAgreementInstanceModel.deserialize(da_instance_record.data_agreement)

        did_mydata_builder = DIDMyDataBuilder(
            artefact=da_model
        )

        (tx_hash, tx_receipt) = await eth_client.emit_da_did(did_mydata_builder.mydata_did)

        return (da_instance_record.instance_id, did_mydata_builder.mydata_did, tx_hash, tx_receipt)

    async def add_task(self,
                       context: InjectionContext,
                       coro: typing.Coroutine,
                       task_complete: typing.Callable = None,
                       ident: str = None) -&gt; PendingTask:
        &#34;&#34;&#34;
        Add a new task to the queue, delaying execution if busy.

        Args:
            context: Injection context to be used.
            coro: The coroutine to run
            task_complete: A callback to run on completion
            ident: A string identifier for the task

        Returns: a future resolving to the asyncio task instance once queued
        &#34;&#34;&#34;
        loop = asyncio.get_event_loop()
        pack_format: PackWireFormat = await context.inject(BaseWireFormat, required=False)
        return pack_format.task_queue.put(coro, lambda x: loop.create_task(task_complete(x)), ident)

    async def sample_queue_snippet(self):
        &#34;&#34;&#34;Sample queue snippet&#34;&#34;&#34;
        pending_task = await self.add_task(self.context,
                                           self.long_running_task(),
                                           self.queue_callback)
        print(pending_task)

    async def long_running_task(self):
        &#34;&#34;&#34;Sample long running task&#34;&#34;&#34;
        print(&#34;Long running task commenced...&#34;)
        await asyncio.sleep(10)
        return &#34;msg: Hi from long running task!&#34;

    async def queue_callback(self, *args, **kwargs):
        &#34;&#34;&#34;Sample queue callback function&#34;&#34;&#34;
        print(&#34;Recieved call back...&#34;)
        completed_task: CompletedTask = args[0]
        result: str = completed_task.task.result()

        print(result)
        print(self.context)

        # Send a basic message to available active connection
        tag_filter = {}
        post_filter = {&#34;state&#34;: &#34;active&#34;}
        records: typing.List[ConnectionRecord] = await ConnectionRecord.query(
            self.context,
            tag_filter,
            post_filter
        )

        responder: BaseResponder = await self.context.inject(BaseResponder, required=False)
        basic_message = BasicMessage(content=&#34;Triggered by task queue callback...&#34;)
        if responder:
            for record in records:
                await responder.send(basic_message, connection_id=record.connection_id)</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="dexa_sdk.managers.ada_manager.V2ADAManager.context"><code class="name">var <span class="ident">context</span> :Â aries_cloudagent.config.injection_context.InjectionContext</code></dt>
<dd>
<div class="desc"><p>Accessor for injection context</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>InjectionContext</code></dt>
<dd>Injection context</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@ property
def context(self) -&gt; InjectionContext:
    &#34;&#34;&#34;Accessor for injection context

    Returns:
        InjectionContext: Injection context
    &#34;&#34;&#34;
    return self._context</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="dexa_sdk.managers.ada_manager.V2ADAManager.add_task"><code class="name flex">
<span>async def <span class="ident">add_task</span></span>(<span>self, context:Â aries_cloudagent.config.injection_context.InjectionContext, coro:Â Coroutine[+T_co,Â -T_contra,Â +V_co], task_complete:Â CallableÂ =Â None, ident:Â strÂ =Â None) â>Â aries_cloudagent.utils.task_queue.PendingTask</span>
</code></dt>
<dd>
<div class="desc"><p>Add a new task to the queue, delaying execution if busy.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>context</code></strong></dt>
<dd>Injection context to be used.</dd>
<dt><strong><code>coro</code></strong></dt>
<dd>The coroutine to run</dd>
<dt><strong><code>task_complete</code></strong></dt>
<dd>A callback to run on completion</dd>
<dt><strong><code>ident</code></strong></dt>
<dd>A string identifier for the task</dd>
</dl>
<p>Returns: a future resolving to the asyncio task instance once queued</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def add_task(self,
                   context: InjectionContext,
                   coro: typing.Coroutine,
                   task_complete: typing.Callable = None,
                   ident: str = None) -&gt; PendingTask:
    &#34;&#34;&#34;
    Add a new task to the queue, delaying execution if busy.

    Args:
        context: Injection context to be used.
        coro: The coroutine to run
        task_complete: A callback to run on completion
        ident: A string identifier for the task

    Returns: a future resolving to the asyncio task instance once queued
    &#34;&#34;&#34;
    loop = asyncio.get_event_loop()
    pack_format: PackWireFormat = await context.inject(BaseWireFormat, required=False)
    return pack_format.task_queue.put(coro, lambda x: loop.create_task(task_complete(x)), ident)</code></pre>
</details>
</dd>
<dt id="dexa_sdk.managers.ada_manager.V2ADAManager.anchor_da_instance_to_blockchain"><code class="name flex">
<span>async def <span class="ident">anchor_da_instance_to_blockchain</span></span>(<span>self, instance_id:Â str) â>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Anchor da instance to blockchain.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>instance_id</code></strong> :&ensp;<code>str</code></dt>
<dd>Instance id</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def anchor_da_instance_to_blockchain(
    self,
    instance_id: str
) -&gt; None:
    &#34;&#34;&#34;Anchor da instance to blockchain.

    Args:
        instance_id (str): Instance id
    &#34;&#34;&#34;

    eth_client: EthereumClient = await self.context.inject(EthereumClient)

    tag_filter = {
        &#34;instance_id&#34;: instance_id
    }

    # Fetch data agreement instance record.
    da_instance_records = await DataAgreementInstanceRecord.query(
        self.context,
        tag_filter,
    )

    assert da_instance_records, &#34;Data agreement instance not found.&#34;

    da_instance_record: DataAgreementInstanceRecord = da_instance_records[0]
    da_model: DataAgreementInstanceModel = \
        DataAgreementInstanceModel.deserialize(da_instance_record.data_agreement)

    did_mydata_builder = DIDMyDataBuilder(
        artefact=da_model
    )

    (tx_hash, tx_receipt) = await eth_client.emit_da_did(did_mydata_builder.mydata_did)

    return (da_instance_record.instance_id, did_mydata_builder.mydata_did, tx_hash, tx_receipt)</code></pre>
</details>
</dd>
<dt id="dexa_sdk.managers.ada_manager.V2ADAManager.anchor_da_instance_to_blockchain_async_task"><code class="name flex">
<span>async def <span class="ident">anchor_da_instance_to_blockchain_async_task</span></span>(<span>self, instance_id:Â str)</span>
</code></dt>
<dd>
<div class="desc"><p>Async task to anchor da instance to blockchain.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>instance_id</code></strong> :&ensp;<code>str</code></dt>
<dd>Instance id</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def anchor_da_instance_to_blockchain_async_task(
    self,
    instance_id: str
):
    &#34;&#34;&#34;Async task to anchor da instance to blockchain.

    Args:
        instance_id (str): Instance id
    &#34;&#34;&#34;
    pending_task = await self.add_task(
        self.context,
        self.anchor_da_instance_to_blockchain(instance_id),
        self.anchor_da_instance_to_blockchain_async_task_callback
    )
    self._logger.info(pending_task)</code></pre>
</details>
</dd>
<dt id="dexa_sdk.managers.ada_manager.V2ADAManager.anchor_da_instance_to_blockchain_async_task_callback"><code class="name flex">
<span>async def <span class="ident">anchor_da_instance_to_blockchain_async_task_callback</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Anchor DA instance to blockchain async task callback function</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def anchor_da_instance_to_blockchain_async_task_callback(
    self, *args, **kwargs
):
    &#34;&#34;&#34;Anchor DA instance to blockchain async task callback function
    &#34;&#34;&#34;

    # Obtain the completed task.
    completed_task: CompletedTask = args[0]

    # Obtain the results from the task.
    (instance_id, mydata_did, tx_hash, tx_receipt) = completed_task.task.result()

    tag_filter = {
        &#34;instance_id&#34;: instance_id
    }

    # Fetch data agreement instance record.
    da_instance_records = await DataAgreementInstanceRecord.query(
        self.context,
        tag_filter,
    )

    assert da_instance_records, &#34;Data agreement instance not found.&#34;

    da_instance_record: DataAgreementInstanceRecord = da_instance_records[0]

    transaction_receipt = json.loads(to_json(tx_receipt))
    transaction_hash = transaction_receipt.get(&#34;transactionHash&#34;)

    # Update the data agreement with blockchain metadata.
    da_instance_record.blink = f&#34;blink:ethereum:rinkeby:{transaction_hash}&#34;
    da_instance_record.mydata_did = mydata_did
    da_instance_record.blockchain_receipt = transaction_receipt

    await da_instance_record.save(self.context)</code></pre>
</details>
</dd>
<dt id="dexa_sdk.managers.ada_manager.V2ADAManager.build_data_agreement_accept_for_data_ex_record"><code class="name flex">
<span>async def <span class="ident">build_data_agreement_accept_for_data_ex_record</span></span>(<span>self, connection_record:Â aries_cloudagent.connections.models.connection_record.ConnectionRecord, data_ex_record:Â Union[aries_cloudagent.protocols.issue_credential.v1_0.models.credential_exchange.V10CredentialExchange,Â aries_cloudagent.protocols.present_proof.v1_0.models.presentation_exchange.V10PresentationExchange]) â>Â mydata_did.v1_0.messages.data_agreement_accept.DataAgreementNegotiationAcceptMessage</span>
</code></dt>
<dd>
<div class="desc"><p>Build data agreement accept message for credential exchange.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>context</code></strong> :&ensp;<code>InjectionContext</code></dt>
<dd>Injection context to be used.</dd>
<dt><strong><code>template_id</code></strong> :&ensp;<code>str</code></dt>
<dd>Data agreement template identifier.</dd>
<dt><strong><code>connection_record</code></strong> :&ensp;<code>ConnectionRecord</code></dt>
<dd>Connection record.</dd>
</dl>
<p>data_ex_record (typing.Union[V10CredentialExchange, V10PresentationExchange]):
Data exchange record.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>DataAgreementNegotiationAcceptMessage</code></dt>
<dd>Accept message.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def build_data_agreement_accept_for_data_ex_record(
    self,
    connection_record: ConnectionRecord,
    data_ex_record: typing.Union[V10CredentialExchange, V10PresentationExchange],
) -&gt; DataAgreementNegotiationAcceptMessage:
    &#34;&#34;&#34;Build data agreement accept message for credential exchange.

    Args:
        context (InjectionContext): Injection context to be used.
        template_id (str): Data agreement template identifier.
        connection_record (ConnectionRecord): Connection record.
        data_ex_record (typing.Union[V10CredentialExchange, V10PresentationExchange]):
            Data exchange record.

    Returns:
        DataAgreementNegotiationAcceptMessage: Accept message.
    &#34;&#34;&#34;
    if data_ex_record.__class__.__name__ == V10CredentialExchange.__name__:
        # Fetch data agreement instance matching credential exchange record.
        instance_record = await DataAgreementInstanceRecord.fetch_by_data_ex_id(
            self.context,
            data_ex_record.credential_exchange_id
        )
    else:
        # Fetch data agreement instance matching credential exchange record.
        instance_record = await DataAgreementInstanceRecord.fetch_by_data_ex_id(
            self.context,
            data_ex_record.presentation_exchange_id
        )

    # Build instance record
    (da_instance_record, da_instance_model) = \
        await DataAgreementInstanceRecord.counter_sign_instance(
        self.context,
        instance_record.instance_id,
        connection_record
    )

    # Build negotiation accept agent message
    agent_message = DataAgreementNegotiationAcceptMessage(body=da_instance_model)

    return agent_message</code></pre>
</details>
</dd>
<dt id="dexa_sdk.managers.ada_manager.V2ADAManager.build_data_agreement_negotiation_accept_by_instance_id"><code class="name flex">
<span>async def <span class="ident">build_data_agreement_negotiation_accept_by_instance_id</span></span>(<span>self, instance_id:Â str, connection_record:Â aries_cloudagent.connections.models.connection_record.ConnectionRecord) â>Â mydata_did.v1_0.messages.data_agreement_accept.DataAgreementNegotiationAcceptMessage</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def build_data_agreement_negotiation_accept_by_instance_id(
    self,
    instance_id: str,
    connection_record: ConnectionRecord
) -&gt; DataAgreementNegotiationAcceptMessage:
    # Counter sign da
    (da_instance_record, da_instance_model) = \
        await DataAgreementInstanceRecord.counter_sign_instance(
            self.context,
            instance_id,
            connection_record,
    )

    # Build negotiation accept agent message
    agent_message = DataAgreementNegotiationAcceptMessage(body=da_instance_model)

    return agent_message</code></pre>
</details>
</dd>
<dt id="dexa_sdk.managers.ada_manager.V2ADAManager.build_data_agreement_offer_for_credential_exchange"><code class="name flex">
<span>async def <span class="ident">build_data_agreement_offer_for_credential_exchange</span></span>(<span>self, template_id:Â str, connection_record:Â aries_cloudagent.connections.models.connection_record.ConnectionRecord, cred_ex_record:Â aries_cloudagent.protocols.issue_credential.v1_0.models.credential_exchange.V10CredentialExchange) â>Â mydata_did.v1_0.messages.data_agreement_offer.DataAgreementNegotiationOfferMessage</span>
</code></dt>
<dd>
<div class="desc"><p>Build data agreement offer for credential exchange.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>context</code></strong> :&ensp;<code>InjectionContext</code></dt>
<dd>Injection context to be used.</dd>
<dt><strong><code>template_id</code></strong> :&ensp;<code>str</code></dt>
<dd>Data agreement template identifier.</dd>
<dt><strong><code>connection_record</code></strong> :&ensp;<code>ConnectionRecord</code></dt>
<dd>Connection record.</dd>
<dt><strong><code>cred_ex_record</code></strong> :&ensp;<code>V10CredentialExchange</code></dt>
<dd>Credential exchange record.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>DataAgreementNegotiationOfferMessage</code></dt>
<dd>Offer message.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def build_data_agreement_offer_for_credential_exchange(
    self,
    template_id: str,
    connection_record: ConnectionRecord,
    cred_ex_record: V10CredentialExchange,
) -&gt; DataAgreementNegotiationOfferMessage:
    &#34;&#34;&#34;Build data agreement offer for credential exchange.

    Args:
        context (InjectionContext): Injection context to be used.
        template_id (str): Data agreement template identifier.
        connection_record (ConnectionRecord): Connection record.
        cred_ex_record (V10CredentialExchange): Credential exchange record.

    Returns:
        DataAgreementNegotiationOfferMessage: Offer message.
    &#34;&#34;&#34;

    # Build instance record
    (da_instance_record, da_instance_model) = \
        await DataAgreementInstanceRecord.build_instance_from_template(
        self.context,
        template_id,
        connection_record,
        cred_ex_record.credential_exchange_id
    )

    # Build negotiation offer agent message
    agent_message = DataAgreementNegotiationOfferMessage(body=da_instance_model)

    return agent_message</code></pre>
</details>
</dd>
<dt id="dexa_sdk.managers.ada_manager.V2ADAManager.build_data_agreement_offer_for_presentation_exchange"><code class="name flex">
<span>async def <span class="ident">build_data_agreement_offer_for_presentation_exchange</span></span>(<span>self, template_id:Â str, connection_record:Â aries_cloudagent.connections.models.connection_record.ConnectionRecord, pres_ex_record:Â aries_cloudagent.protocols.present_proof.v1_0.models.presentation_exchange.V10PresentationExchange) â>Â mydata_did.v1_0.messages.data_agreement_offer.DataAgreementNegotiationOfferMessage</span>
</code></dt>
<dd>
<div class="desc"><p>Build data agreement offer for presentaton exchange.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>context</code></strong> :&ensp;<code>InjectionContext</code></dt>
<dd>Injection context to be used.</dd>
<dt><strong><code>template_id</code></strong> :&ensp;<code>str</code></dt>
<dd>Data agreement template identifier.</dd>
<dt><strong><code>connection_record</code></strong> :&ensp;<code>ConnectionRecord</code></dt>
<dd>Connection record.</dd>
<dt><strong><code>pres_ex_record</code></strong> :&ensp;<code>V10PresentationExchange</code></dt>
<dd>Presentation exchange record.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>DataAgreementNegotiationOfferMessage</code></dt>
<dd>Offer message.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def build_data_agreement_offer_for_presentation_exchange(
    self,
    template_id: str,
    connection_record: ConnectionRecord,
    pres_ex_record: V10PresentationExchange,
) -&gt; DataAgreementNegotiationOfferMessage:
    &#34;&#34;&#34;Build data agreement offer for presentaton exchange.

    Args:
        context (InjectionContext): Injection context to be used.
        template_id (str): Data agreement template identifier.
        connection_record (ConnectionRecord): Connection record.
        pres_ex_record (V10PresentationExchange): Presentation exchange record.

    Returns:
        DataAgreementNegotiationOfferMessage: Offer message.
    &#34;&#34;&#34;

    # Build instance record
    (da_instance_record, da_instance_model) = \
        await DataAgreementInstanceRecord.build_instance_from_template(
        self.context,
        template_id,
        connection_record,
        pres_ex_record.presentation_exchange_id
    )

    # Build negotiation offer agent message
    agent_message = DataAgreementNegotiationOfferMessage(body=da_instance_model)

    return agent_message</code></pre>
</details>
</dd>
<dt id="dexa_sdk.managers.ada_manager.V2ADAManager.construct_presentation_request"><code class="name flex">
<span>def <span class="ident">construct_presentation_request</span></span>(<span>self, *, usage_purpose:Â str, usage_purpose_description:Â str, da_template_version:Â str, personal_data:Â List[<a title="dexa_sdk.agreements.da.v1_0.records.personal_data_record.PersonalDataRecord" href="../agreements/da/v1_0/records/personal_data_record.html#dexa_sdk.agreements.da.v1_0.records.personal_data_record.PersonalDataRecord">PersonalDataRecord</a>]) â>Â dict</span>
</code></dt>
<dd>
<div class="desc"><p>Construct presentation request</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>usage_purpose</code></strong></dt>
<dd>Usage purpose.</dd>
<dt><strong><code>usage_purpose_description</code></strong></dt>
<dd>Usage purpose description.</dd>
<dt><strong><code>da_template_version</code></strong></dt>
<dd>Data agreement template version.</dd>
<dt><strong><code>personal_data</code></strong></dt>
<dd>List of personal data.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>:rtype: dict: Proof request</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def construct_presentation_request(
        self,
        *,
        usage_purpose: str,
        usage_purpose_description: str,
        da_template_version: str,
        personal_data: typing.List[PersonalDataRecord]
) -&gt; dict:
    &#34;&#34;&#34;
    Construct presentation request

    Args:
        usage_purpose: Usage purpose.
        usage_purpose_description: Usage purpose description.
        da_template_version: Data agreement template version.
        personal_data: List of personal data.

    Returns:
        :rtype: dict: Proof request

    &#34;&#34;&#34;

    presentation_request_dict: dict = {
        &#34;name&#34;: usage_purpose,
        &#34;comment&#34;: usage_purpose_description,
        &#34;version&#34;: da_template_version,
        &#34;requested_attributes&#34;: {},
        &#34;requested_predicates&#34;: {}
    }

    index = 1
    requested_attributes = {}

    for pd in personal_data:

        requested_attributes[&#34;additionalProp&#34; + str(index)] = {
            &#34;name&#34;: pd.attribute_name,
            &#34;restrictions&#34;: pd.restrictions if pd.restrictions else []
        }
        if pd.restrictions:
            restrictions = [
                {
                    &#34;schema_id&#34;: restriction.get(&#34;schemaId&#34;),
                    &#34;cred_def_id&#34;: restriction.get(&#34;credDefId&#34;)
                }
                for restriction in pd.restrictions
            ]
            requested_attributes[&#34;additionalProp&#34; +
                                 str(index)].update({&#34;restrictions&#34;: restrictions})
        else:
            requested_attributes[&#34;additionalProp&#34; + str(index)].update({})
        index += 1

    presentation_request_dict[&#34;requested_attributes&#34;] = requested_attributes

    return presentation_request_dict</code></pre>
</details>
</dd>
<dt id="dexa_sdk.managers.ada_manager.V2ADAManager.create_and_store_da_template_in_wallet"><code class="name flex">
<span>async def <span class="ident">create_and_store_da_template_in_wallet</span></span>(<span>self, data_agreement:Â dict, *, publish_flag:Â boolÂ =Â True, schema_id:Â strÂ =Â None) â>Â <a title="dexa_sdk.agreements.da.v1_0.records.da_template_record.DataAgreementTemplateRecord" href="../agreements/da/v1_0/records/da_template_record.html#dexa_sdk.agreements.da.v1_0.records.da_template_record.DataAgreementTemplateRecord">DataAgreementTemplateRecord</a></span>
</code></dt>
<dd>
<div class="desc"><p>Create and store data agreement template in wallet</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data_agreement</code></strong> :&ensp;<code>dict</code></dt>
<dd>Data agreement</dd>
<dt><strong><code>publish_flag</code></strong> :&ensp;<code>bool</code></dt>
<dd>Publish flag</dd>
<dt><strong><code>schema_id</code></strong> :&ensp;<code>str</code></dt>
<dd>Schema identifier</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def create_and_store_da_template_in_wallet(
        self,
        data_agreement: dict,
        *,
        publish_flag: bool = True,
        schema_id: str = None
) -&gt; DataAgreementTemplateRecord:
    &#34;&#34;&#34;Create and store data agreement template in wallet

    Args:
        data_agreement (dict): Data agreement
        publish_flag (bool): Publish flag
        schema_id (str): Schema identifier
    &#34;&#34;&#34;

    # Temp hack
    template_version = &#34;1.0.0&#34;
    template_id = str(uuid.uuid4())
    data_agreement.update({&#34;@context&#34;: DA_DEFAULT_CONTEXT})
    data_agreement.update({&#34;@id&#34;: template_id})
    data_agreement.update({&#34;@type&#34;: DA_TYPE})
    data_agreement.update({&#34;version&#34;: template_version})

    try:
        # Validate the data agreement.
        data_agreement: DataAgreementModel = DataAgreementModel.deserialize(data_agreement)
    except ValidationError as err:
        raise V2ADAManagerError(
            f&#34;Failed to create data agreement; Reason: {err}&#34;
        )

    # Create personal data records
    pds = data_agreement.personal_data
    pd_records = []
    pd_models_with_id = []
    for pd in pds:
        pd_record: PersonalDataRecord = \
            await PersonalDataRecord.build_and_save_record_from_pd_model(
                self.context,
                template_id,
                template_version,
                pd
            )
        pd_records.append(pd_record)
        pd_models_with_id.append(pd_record.convert_record_to_pd_model())

    # Update the personal data with attribute identifiers to the agreement
    data_agreement.personal_data = pd_models_with_id

    # Create template record
    record = DataAgreementTemplateRecord(
        template_id=template_id,
        template_version=template_version,
        state=DataAgreementTemplateRecord.STATE_DEFINITION,
        method_of_use=data_agreement.method_of_use,
        data_agreement=data_agreement.serialize(),
        publish_flag=bool_to_str(publish_flag),
        schema_id=schema_id,
        existing_schema_flag=bool_to_str(True) if schema_id else bool_to_str(False),
        third_party_data_sharing=bool_to_str(
            data_agreement.data_policy.third_party_data_sharing)
    )

    await record.save(self.context)

    if publish_flag:
        # Create ledger payloads
        record = await self.create_and_store_ledger_payloads_for_da_template(
            template_record=record,
            pd_records=pd_records,
            schema_id=schema_id
        )

    return record</code></pre>
</details>
</dd>
<dt id="dexa_sdk.managers.ada_manager.V2ADAManager.create_and_store_ledger_payloads_for_da_template"><code class="name flex">
<span>async def <span class="ident">create_and_store_ledger_payloads_for_da_template</span></span>(<span>self, *, template_record:Â <a title="dexa_sdk.agreements.da.v1_0.records.da_template_record.DataAgreementTemplateRecord" href="../agreements/da/v1_0/records/da_template_record.html#dexa_sdk.agreements.da.v1_0.records.da_template_record.DataAgreementTemplateRecord">DataAgreementTemplateRecord</a>, pd_records:Â List[<a title="dexa_sdk.agreements.da.v1_0.records.personal_data_record.PersonalDataRecord" href="../agreements/da/v1_0/records/personal_data_record.html#dexa_sdk.agreements.da.v1_0.records.personal_data_record.PersonalDataRecord">PersonalDataRecord</a>]Â =Â None, schema_id:Â strÂ =Â None) â>Â <a title="dexa_sdk.agreements.da.v1_0.records.da_template_record.DataAgreementTemplateRecord" href="../agreements/da/v1_0/records/da_template_record.html#dexa_sdk.agreements.da.v1_0.records.da_template_record.DataAgreementTemplateRecord">DataAgreementTemplateRecord</a></span>
</code></dt>
<dd>
<div class="desc"><p>Create and store ledger payloads for a da template</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>template_record</code></strong> :&ensp;<code>DataAgreementTemplateRecord</code></dt>
<dd>Data agreement template record</dd>
<dt><strong><code>pd_records</code></strong> :&ensp;<code>typing.List[PersonalDataRecord]</code></dt>
<dd>Personal data records</dd>
<dt><strong><code>schema_id</code></strong> :&ensp;<code>str</code></dt>
<dd>Schema identifier if available</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>DataAgreementTemplateRecord</code></dt>
<dd>Record with ledger payloads</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def create_and_store_ledger_payloads_for_da_template(
        self,
        *,
        template_record: DataAgreementTemplateRecord,
        pd_records: typing.List[PersonalDataRecord] = None,
        schema_id: str = None
) -&gt; DataAgreementTemplateRecord:
    &#34;&#34;&#34;Create and store ledger payloads for a da template

    Args:
        template_record (DataAgreementTemplateRecord): Data agreement template record
        pd_records (typing.List[PersonalDataRecord]): Personal data records
        schema_id (str): Schema identifier if available

    Returns:
        DataAgreementTemplateRecord: Record with ledger payloads
    &#34;&#34;&#34;
    if template_record.method_of_use == DataAgreementTemplateRecord.METHOD_OF_USE_DATA_SOURCE:

        # Create schema if not existing
        if not schema_id:
            data_agreement = template_record.data_agreement
            # Schema name
            schema_name = data_agreement.get(&#34;purpose&#34;)
            # Schema version
            schema_version = data_agreement.get(&#34;version&#34;)
            # Schema attributes
            attributes = [
                personal_data.attribute_name
                for personal_data in pd_records
            ]
            # Creata schema and anchor to ledger
            (schema_id, schema_def) = await create_schema_def_and_anchor_to_ledger(
                context=self.context,
                schema_name=schema_name,
                schema_version=schema_version,
                attributes=attributes
            )

        # Create credential definition and anchor to ledger

        (cred_def_id, cred_def, novel) = await create_cred_def_and_anchor_to_ledger(
            context=self.context,
            schema_id=schema_id
        )

        template_record.cred_def_id = cred_def_id
        template_record.schema_id = schema_id
        await template_record.save(self.context)

    else:
        data_agreement = template_record.data_agreement

        # Usage purpose
        usage_purpose = data_agreement.get(&#34;purpose&#34;)

        # Usage purpose description
        usage_purpose_description = data_agreement.get(&#34;purposeDescription&#34;)

        # Data agreement template version
        da_template_version = data_agreement.get(&#34;version&#34;)

        # Create presentation request
        presentation_request = self.construct_presentation_request(
            usage_purpose=usage_purpose,
            usage_purpose_description=usage_purpose_description,
            da_template_version=da_template_version,
            personal_data=pd_records
        )

        template_record.presentation_request = presentation_request
        await template_record.save(self.context)

    return template_record</code></pre>
</details>
</dd>
<dt id="dexa_sdk.managers.ada_manager.V2ADAManager.delete_da_instance_by_data_ex_id"><code class="name flex">
<span>async def <span class="ident">delete_da_instance_by_data_ex_id</span></span>(<span>self, cred_ex_id:Â str) â>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Delete da instance by cred ex id.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>cred_ex_id</code></strong> :&ensp;<code>str</code></dt>
<dd>Credential exchange identifier.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def delete_da_instance_by_data_ex_id(
    self,
    cred_ex_id: str
) -&gt; None:
    &#34;&#34;&#34;Delete da instance by cred ex id.

    Args:
        cred_ex_id (str): Credential exchange identifier.
    &#34;&#34;&#34;

    # Data agreement instance
    instance = await DataAgreementInstanceRecord.fetch_by_data_ex_id(
        self.context,
        cred_ex_id
    )

    await instance.delete_record(self.context)</code></pre>
</details>
</dd>
<dt id="dexa_sdk.managers.ada_manager.V2ADAManager.delete_da_template_in_wallet"><code class="name flex">
<span>async def <span class="ident">delete_da_template_in_wallet</span></span>(<span>self, template_id:Â str) â>Â str</span>
</code></dt>
<dd>
<div class="desc"><p>Deactivate DA template in wallet.</p>
<p>This is not a normal delete operation of a specific version of template. Instead it
marks the template with latest version flag as deleted i.e. Any version under this
template is no longer active.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>template_id</code></strong> :&ensp;<code>str</code></dt>
<dd>Template identifier</dd>
<dt><strong><code>template_version</code></strong> :&ensp;<code>str</code></dt>
<dd>Template version</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>record_id</code></dt>
<dd>Record identifier for the deleted template.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def delete_da_template_in_wallet(self, template_id: str) -&gt; str:
    &#34;&#34;&#34;Deactivate DA template in wallet.

    This is not a normal delete operation of a specific version of template. Instead it
    marks the template with latest version flag as deleted i.e. Any version under this
    template is no longer active.

    Args:
        template_id (str): Template identifier
        template_version (str): Template version

    Returns:
        record_id: Record identifier for the deleted template.
    &#34;&#34;&#34;
    # Query for the data agreement by id
    data_agreement_records: DataAgreementTemplateRecord = \
        await DataAgreementTemplateRecord.non_deleted_template_by_id(
            self.context,
            template_id
        )

    assert data_agreement_records, &#34;Data agreement template not found.&#34;
    data_agreement_record = data_agreement_records[0]

    # Mark the data agreement as deleted and save.
    return await data_agreement_record.delete_template(self.context)</code></pre>
</details>
</dd>
<dt id="dexa_sdk.managers.ada_manager.V2ADAManager.delete_personal_data"><code class="name flex">
<span>async def <span class="ident">delete_personal_data</span></span>(<span>self, attribute_id:Â str) â>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Delete personal data record.</p>
<p>On deleting personal data record, the associated data agreement template is
updated. If the personal data record deleted, is the last one in the template,
proceed to delete the template record.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>attribute_id</code></strong> :&ensp;<code>str</code></dt>
<dd><em>description</em></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def delete_personal_data(self, attribute_id: str) -&gt; None:
    &#34;&#34;&#34;Delete personal data record.

    On deleting personal data record, the associated data agreement template is
    updated. If the personal data record deleted, is the last one in the template,
    proceed to delete the template record.

    Args:
        attribute_id (str): _description_
    &#34;&#34;&#34;

    # Fetch personal data record by id
    pd_record: PersonalDataRecord = await PersonalDataRecord.retrieve_by_id(
        self.context,
        attribute_id
    )

    # Fetch the associated data agreement record
    da_template_record: DataAgreementTemplateRecord = \
        await DataAgreementTemplateRecord.latest_template_by_id(
            self.context,
            pd_record.data_agreement_template_id
        )

    assert da_template_record, &#34;Matching data agreement template not found.&#34;
    assert da_template_record.template_version == \
        pd_record.data_agreement_template_version, \
        &#34;Matching data agreement template with same version not found.&#34;

    # Delete personal data record
    await pd_record.delete_record(self.context)

    da: DataAgreementModel = DataAgreementModel.deserialize(da_template_record.data_agreement)

    # Iterate through the existing personal data in data agreements
    # And remove the deleted personal data.
    da_pds = []
    for da_pd in da.personal_data:
        if da_pd.attribute_id != pd_record.attribute_id:
            da_pds.append(da_pd)

    da.personal_data = da_pds

    da_template_record.data_agreement = da.serialize()
    await da_template_record.upgrade(self.context)

    # Mark data agreement template as deleted if number of personal data is zero
    if len(da_pds) == 0:
        await da_template_record.delete_template(self.context)
    else:

        pd_records = await da_template_record.fetch_personal_data_records(self.context)

        if da_template_record._publish_flag:
            # Create ledger payloads
            await self.create_and_store_ledger_payloads_for_da_template(
                template_record=da_template_record,
                pd_records=pd_records,
                schema_id=None
            )</code></pre>
</details>
</dd>
<dt id="dexa_sdk.managers.ada_manager.V2ADAManager.long_running_task"><code class="name flex">
<span>async def <span class="ident">long_running_task</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Sample long running task</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def long_running_task(self):
    &#34;&#34;&#34;Sample long running task&#34;&#34;&#34;
    print(&#34;Long running task commenced...&#34;)
    await asyncio.sleep(10)
    return &#34;msg: Hi from long running task!&#34;</code></pre>
</details>
</dd>
<dt id="dexa_sdk.managers.ada_manager.V2ADAManager.process_decorator_with_da_accept_message"><code class="name flex">
<span>async def <span class="ident">process_decorator_with_da_accept_message</span></span>(<span>self, decorator_set:Â aries_cloudagent.messaging.decorators.default.DecoratorSet, data_ex_record:Â Union[aries_cloudagent.protocols.issue_credential.v1_0.models.credential_exchange.V10CredentialExchange,Â aries_cloudagent.protocols.present_proof.v1_0.models.presentation_exchange.V10PresentationExchange], connection_record:Â aries_cloudagent.connections.models.connection_record.ConnectionRecord) â>Â <a title="dexa_sdk.agreements.da.v1_0.records.da_instance_record.DataAgreementInstanceRecord" href="../agreements/da/v1_0/records/da_instance_record.html#dexa_sdk.agreements.da.v1_0.records.da_instance_record.DataAgreementInstanceRecord">DataAgreementInstanceRecord</a></span>
</code></dt>
<dd>
<div class="desc"><p>Process data agreement context decorator with DA accept message</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>decorator_set</code></strong> :&ensp;<code>DecoratorSet</code></dt>
<dd>Decorator set</dd>
<dt>data_ex_record (typing.Union[V10CredentialExchange, V10PresentationExchange]):</dt>
<dt>Data exchange record.</dt>
<dt><strong><code>connection_record</code></strong> :&ensp;<code>ConnectionRecord</code></dt>
<dd>Connection record</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>DataAgreementInstanceRecord</code></dt>
<dd>Data agreement instance record.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def process_decorator_with_da_accept_message(
    self,
    decorator_set: DecoratorSet,
    data_ex_record: typing.Union[V10CredentialExchange, V10PresentationExchange],
    connection_record: ConnectionRecord
) -&gt; DataAgreementInstanceRecord:
    &#34;&#34;&#34;Process data agreement context decorator with DA accept message

    Args:
        decorator_set (DecoratorSet): Decorator set
        data_ex_record (typing.Union[V10CredentialExchange, V10PresentationExchange]):
            Data exchange record.
        connection_record (ConnectionRecord): Connection record

    Returns:
        DataAgreementInstanceRecord: Data agreement instance record.
    &#34;&#34;&#34;

    # Check if data agreement context decorator is present
    if &#34;data-agreement-context&#34; not in decorator_set.keys():
        self._logger.info(
            &#34;Data agreement context decorator is not present in the incoming message.&#34;)
        return None

    # Deserialize data agreement context decorator
    da_decorator_dict = decorator_set[&#34;data-agreement-context&#34;]
    da_decorator_model: DataAgreementContextDecorator = \
        DataAgreementContextDecorator.deserialize(da_decorator_dict)

    assert da_decorator_model.message_type == &#34;protocol&#34;, \
        &#34;DA context message type must be &#39;protocol&#39;.&#34;

    message_type = da_decorator_model.message.get(&#34;@type&#34;)
    assert DATA_AGREEMENT_NEGOTIATION_ACCEPT in message_type, \
        f&#34;DA context protocol message type must be &#39;{DATA_AGREEMENT_NEGOTIATION_ACCEPT}&#39;&#34;

    da_accept_message: DataAgreementNegotiationAcceptMessage = \
        DataAgreementNegotiationAcceptMessage.deserialize(da_decorator_model.message)

    # Build and save data agreement instance record.
    if data_ex_record.__class__.__name__ == V10CredentialExchange.__name__:
        # Build and save data agreement instance record.
        instance_record = await DataAgreementInstanceRecord.update_instance_from_da_accept(
            self.context,
            da_accept_message,
            data_ex_record.credential_exchange_id
        )
    else:
        # Build and save data agreement instance record.
        instance_record = await DataAgreementInstanceRecord.update_instance_from_da_accept(
            self.context,
            da_accept_message,
            data_ex_record.presentation_exchange_id
        )

    # Anchor da to blockchain.
    await self.anchor_da_instance_to_blockchain_async_task(instance_record.instance_id)

    return instance_record</code></pre>
</details>
</dd>
<dt id="dexa_sdk.managers.ada_manager.V2ADAManager.process_decorator_with_da_offer_message"><code class="name flex">
<span>async def <span class="ident">process_decorator_with_da_offer_message</span></span>(<span>self, decorator_set:Â aries_cloudagent.messaging.decorators.default.DecoratorSet, data_ex_record:Â Union[aries_cloudagent.protocols.issue_credential.v1_0.models.credential_exchange.V10CredentialExchange,Â aries_cloudagent.protocols.present_proof.v1_0.models.presentation_exchange.V10PresentationExchange], connection_record:Â aries_cloudagent.connections.models.connection_record.ConnectionRecord) â>Â <a title="dexa_sdk.agreements.da.v1_0.records.da_instance_record.DataAgreementInstanceRecord" href="../agreements/da/v1_0/records/da_instance_record.html#dexa_sdk.agreements.da.v1_0.records.da_instance_record.DataAgreementInstanceRecord">DataAgreementInstanceRecord</a></span>
</code></dt>
<dd>
<div class="desc"><p>Process data agreement context decorator with DA offer message</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>decorator_set</code></strong> :&ensp;<code>DecoratorSet</code></dt>
<dd>Decorator set</dd>
<dt><strong><code>cred_ex_record</code></strong> :&ensp;<code>V10CredentialExchange</code></dt>
<dd>Credential exchange record</dd>
<dt><strong><code>connection_record</code></strong> :&ensp;<code>ConnectionRecord</code></dt>
<dd>Connection record</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>DataAgreementInstanceRecord</code></dt>
<dd>Data agreement instance record.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def process_decorator_with_da_offer_message(
    self,
    decorator_set: DecoratorSet,
    data_ex_record: typing.Union[V10CredentialExchange, V10PresentationExchange],
    connection_record: ConnectionRecord
) -&gt; DataAgreementInstanceRecord:
    &#34;&#34;&#34;Process data agreement context decorator with DA offer message

    Args:
        decorator_set (DecoratorSet): Decorator set
        cred_ex_record (V10CredentialExchange): Credential exchange record
        connection_record (ConnectionRecord): Connection record

    Returns:
        DataAgreementInstanceRecord: Data agreement instance record.
    &#34;&#34;&#34;

    # Check if data agreement context decorator is present
    if &#34;data-agreement-context&#34; not in decorator_set.keys():
        self._logger.info(
            &#34;Data agreement context decorator is not present in the incoming message.&#34;)
        return None

    # Deserialize data agreement context decorator
    da_decorator_dict = decorator_set[&#34;data-agreement-context&#34;]
    da_decorator_model: DataAgreementContextDecorator = \
        DataAgreementContextDecorator.deserialize(da_decorator_dict)

    assert da_decorator_model.message_type == &#34;protocol&#34;, \
        &#34;DA context message type must be &#39;protocol&#39;.&#34;

    message_type = da_decorator_model.message.get(&#34;@type&#34;)
    assert DATA_AGREEMENT_NEGOTIATION_OFFER in message_type, \
        f&#34;DA context protocol message type must be &#39;{DATA_AGREEMENT_NEGOTIATION_OFFER}&#39;&#34;

    da_offer_message: DataAgreementNegotiationOfferMessage = \
        DataAgreementNegotiationOfferMessage.deserialize(da_decorator_model.message)

    # Build and save data agreement instance record.
    if data_ex_record.__class__.__name__ == V10CredentialExchange.__name__:
        return await DataAgreementInstanceRecord.build_instance_from_da_offer(
            self.context,
            da_offer_message,
            connection_record,
            data_ex_record.credential_exchange_id
        )
    else:
        return await DataAgreementInstanceRecord.build_instance_from_da_offer(
            self.context,
            da_offer_message,
            connection_record,
            data_ex_record.presentation_exchange_id
        )</code></pre>
</details>
</dd>
<dt id="dexa_sdk.managers.ada_manager.V2ADAManager.publish_da_template_in_wallet"><code class="name flex">
<span>async def <span class="ident">publish_da_template_in_wallet</span></span>(<span>self, template_id:Â str) â>Â <a title="dexa_sdk.agreements.da.v1_0.records.da_template_record.DataAgreementTemplateRecord" href="../agreements/da/v1_0/records/da_template_record.html#dexa_sdk.agreements.da.v1_0.records.da_template_record.DataAgreementTemplateRecord">DataAgreementTemplateRecord</a></span>
</code></dt>
<dd>
<div class="desc"><p>Publish data agreement template.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>template_id</code></strong> :&ensp;<code>str</code></dt>
<dd>Template identifier</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>DataAgreementTemplateRecord</code></dt>
<dd>Template record.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def publish_da_template_in_wallet(self,
                                        template_id: str) -&gt; DataAgreementTemplateRecord:
    &#34;&#34;&#34;Publish data agreement template.

    Args:
        template_id (str): Template identifier

    Returns:
        DataAgreementTemplateRecord: Template record.
    &#34;&#34;&#34;

    tag_filter = {
        &#34;delete_flag&#34;: bool_to_str(False),
        &#34;publish_flag&#34;: bool_to_str(False),
        &#34;latest_version_flag&#34;: bool_to_str(True),
        &#34;template_id&#34;: template_id
    }

    records = await DataAgreementTemplateRecord.query(
        context=self.context,
        tag_filter=tag_filter
    )

    assert records, &#34;Data agreement template not found.&#34;

    record: DataAgreementTemplateRecord = records[0]

    await record.publish_template(self.context)

    pd_records = await record.fetch_personal_data_records(self.context)

    # Create ledger payloads
    record = await self.create_and_store_ledger_payloads_for_da_template(
        template_record=record,
        pd_records=pd_records,
        schema_id=record.schema_id
    )

    return record</code></pre>
</details>
</dd>
<dt id="dexa_sdk.managers.ada_manager.V2ADAManager.query_da_templates_in_wallet"><code class="name flex">
<span>async def <span class="ident">query_da_templates_in_wallet</span></span>(<span>self, *, template_id:Â strÂ =Â None, delete_flag:Â strÂ =Â 'false', method_of_use:Â strÂ =Â None, publish_flag:Â strÂ =Â 'true', template_version:Â strÂ =Â None, latest_version_flag:Â strÂ =Â 'true', third_party_data_sharing:Â strÂ =Â 'false', page:Â intÂ =Â 1, page_size:Â intÂ =Â 10) â>Â <a title="dexa_sdk.utils.utils.PaginationResult" href="../utils/utils.html#dexa_sdk.utils.utils.PaginationResult">PaginationResult</a></span>
</code></dt>
<dd>
<div class="desc"><p>Query DA templates in wallet</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>template_id</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Template identifier. Defaults to None.</dd>
<dt><strong><code>delete_flag</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Delete flag. Defaults to false.</dd>
<dt><strong><code>method_of_use</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Method of use. Defaults to None.</dd>
<dt><strong><code>publish_flag</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Publish flag. Defaults to true.</dd>
<dt><strong><code>latest_version_flag</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Latest version flag. Defaults to true.</dd>
<dt><strong><code>template_version</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Template version. Defaults to None.</dd>
<dt><strong><code>third_party_data_sharing</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Third party data sharing.
Defaults to false.</dd>
<dt><strong><code>page</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Page. Defaults to 1.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>PaginationResult</code></dt>
<dd>Pagination results.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def query_da_templates_in_wallet(
        self,
        *,
        template_id: str = None,
        delete_flag: str = &#34;false&#34;,
        method_of_use: str = None,
        publish_flag: str = &#34;true&#34;,
        template_version: str = None,
        latest_version_flag: str = &#34;true&#34;,
        third_party_data_sharing: str = &#34;false&#34;,
        page: int = 1,
        page_size: int = 10,
) -&gt; PaginationResult:
    &#34;&#34;&#34;Query DA templates in wallet

    Args:
        template_id (str, optional): Template identifier. Defaults to None.
        delete_flag (str, optional): Delete flag. Defaults to false.
        method_of_use (str, optional): Method of use. Defaults to None.
        publish_flag (str, optional): Publish flag. Defaults to true.
        latest_version_flag (str, optional): Latest version flag. Defaults to true.
        template_version (str, optional): Template version. Defaults to None.
        third_party_data_sharing (str, optional): Third party data sharing.
            Defaults to false.
        page (int, optional): Page. Defaults to 1.

    Returns:
        PaginationResult: Pagination results.
    &#34;&#34;&#34;

    # Sample queue snippet
    await self.sample_queue_snippet()

    # Query by version is only possible if the template id is provided
    if template_version:
        assert template_id, &#34;Template identifier is required to query by version&#34;

    # Tag filter
    tag_filter = {
        &#34;delete_flag&#34;: delete_flag,
        &#34;publish_flag&#34;: publish_flag,
        &#34;method_of_use&#34;: method_of_use,
        &#34;template_id&#34;: template_id,
        &#34;template_version&#34;: template_version,
        &#34;latest_version_flag&#34;: latest_version_flag,
        &#34;third_party_data_sharing&#34;: third_party_data_sharing
    }

    tag_filter = drop_none_dict(tag_filter)

    records = await DataAgreementTemplateRecord.query(
        context=self.context,
        tag_filter=tag_filter
    )

    records = sorted(records, key=lambda k: k.created_at, reverse=True)

    paginate_result = paginate_records(records, page, page_size)

    return paginate_result</code></pre>
</details>
</dd>
<dt id="dexa_sdk.managers.ada_manager.V2ADAManager.query_data_agreement_instances"><code class="name flex">
<span>async def <span class="ident">query_data_agreement_instances</span></span>(<span>self, instance_id:Â str, template_id:Â str, template_version:Â str, method_of_use:Â str, third_party_data_sharing:Â str, data_ex_id:Â str, data_subject_did:Â str, page:Â intÂ =Â 1, page_size:Â intÂ =Â 10) â>Â <a title="dexa_sdk.utils.utils.PaginationResult" href="../utils/utils.html#dexa_sdk.utils.utils.PaginationResult">PaginationResult</a></span>
</code></dt>
<dd>
<div class="desc"><p>Query data agreement instances</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>instance_id</code></strong> :&ensp;<code>str</code></dt>
<dd>Instance identifier</dd>
<dt><strong><code>template_id</code></strong> :&ensp;<code>str</code></dt>
<dd>Template identifier</dd>
<dt><strong><code>template_version</code></strong> :&ensp;<code>str</code></dt>
<dd>Template version</dd>
<dt><strong><code>method_of_use</code></strong> :&ensp;<code>str</code></dt>
<dd>Method of use</dd>
<dt><strong><code>third_party_data_sharing</code></strong> :&ensp;<code>str</code></dt>
<dd>Third party data sharing</dd>
<dt><strong><code>data_ex_id</code></strong> :&ensp;<code>str</code></dt>
<dd>Data exchange id</dd>
<dt><strong><code>data_subject_did</code></strong> :&ensp;<code>str</code></dt>
<dd>Data subject did</dd>
<dt><strong><code>page</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Page. Defaults to 1.</dd>
<dt><strong><code>page_size</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Page size. Defaults to 10.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>PaginationResult</code></dt>
<dd>Pagination result</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def query_data_agreement_instances(
    self,
    instance_id: str,
    template_id: str,
    template_version: str,
    method_of_use: str,
    third_party_data_sharing: str,
    data_ex_id: str,
    data_subject_did: str,
    page: int = 1,
    page_size: int = 10
) -&gt; PaginationResult:
    &#34;&#34;&#34;Query data agreement instances

    Args:
        instance_id (str): Instance identifier
        template_id (str): Template identifier
        template_version (str): Template version
        method_of_use (str): Method of use
        third_party_data_sharing (str): Third party data sharing
        data_ex_id (str): Data exchange id
        data_subject_did (str): Data subject did
        page (int, optional): Page. Defaults to 1.
        page_size (int, optional): Page size. Defaults to 10.

    Returns:
        PaginationResult: Pagination result
    &#34;&#34;&#34;
    # Query by version is only possible if the template id is provided
    if template_version:
        assert template_id, &#34;Template identifier is required to query by version&#34;

    # Tag filter
    tag_filter = {
        &#34;instance_id&#34;: instance_id,
        &#34;template_id&#34;: template_id,
        &#34;template_version&#34;: template_version,
        &#34;method_of_use&#34;: method_of_use,
        &#34;third_party_data_sharing&#34;: third_party_data_sharing,
        &#34;data_ex_id&#34;: data_ex_id,
        &#34;data_subject_did&#34;: data_subject_did
    }

    tag_filter = drop_none_dict(tag_filter)

    records = await DataAgreementInstanceRecord.query(
        context=self.context,
        tag_filter=tag_filter
    )

    records = sorted(records, key=lambda k: k.created_at, reverse=True)

    paginate_result = paginate_records(records, page, page_size)

    return paginate_result</code></pre>
</details>
</dd>
<dt id="dexa_sdk.managers.ada_manager.V2ADAManager.query_pd_of_da_template_from_wallet"><code class="name flex">
<span>async def <span class="ident">query_pd_of_da_template_from_wallet</span></span>(<span>self, template_id:Â strÂ =Â None, method_of_use:Â strÂ =Â None, third_party_data_sharing:Â strÂ =Â None, page:Â intÂ =Â 1, page_size:Â intÂ =Â 10) â>Â <a title="dexa_sdk.utils.utils.PaginationResult" href="../utils/utils.html#dexa_sdk.utils.utils.PaginationResult">PaginationResult</a></span>
</code></dt>
<dd>
<div class="desc"><p>Query personal data for DA template.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>template_id</code></strong> :&ensp;<code>str</code></dt>
<dd>Template identifier</dd>
<dt><strong><code>page</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Page number. Defaults to 1.</dd>
<dt><strong><code>page_size</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Page size. Defaults to 10.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>PaginationResult</code></dt>
<dd>Pagination results</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def query_pd_of_da_template_from_wallet(self,
                                              template_id: str = None,
                                              method_of_use: str = None,
                                              third_party_data_sharing: str = None,
                                              page: int = 1,
                                              page_size: int = 10,
                                              ) -&gt; PaginationResult:
    &#34;&#34;&#34;Query personal data for DA template.

    Args:
        template_id (str): Template identifier
        page (int, optional): Page number. Defaults to 1.
        page_size (int, optional): Page size. Defaults to 10.

    Returns:
        PaginationResult: Pagination results
    &#34;&#34;&#34;

    # Tag filter
    tag_filter = {
        &#34;delete_flag&#34;: bool_to_str(False),
        &#34;method_of_use&#34;: method_of_use,
        &#34;template_id&#34;: template_id,
        &#34;latest_version_flag&#34;: bool_to_str(True),
        &#34;third_party_data_sharing&#34;: third_party_data_sharing
    }

    tag_filter = drop_none_dict(tag_filter)

    records = await DataAgreementTemplateRecord.query(
        context=self.context,
        tag_filter=tag_filter
    )

    records = sorted(records, key=lambda k: k.created_at, reverse=True)

    # Fetch personal data records
    pd_records = []
    for record in records:
        pd_records.extend(await record.fetch_personal_data_records(self.context))

    paginate_result = paginate_records(pd_records, page, page_size)

    return paginate_result</code></pre>
</details>
</dd>
<dt id="dexa_sdk.managers.ada_manager.V2ADAManager.queue_callback"><code class="name flex">
<span>async def <span class="ident">queue_callback</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Sample queue callback function</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def queue_callback(self, *args, **kwargs):
    &#34;&#34;&#34;Sample queue callback function&#34;&#34;&#34;
    print(&#34;Recieved call back...&#34;)
    completed_task: CompletedTask = args[0]
    result: str = completed_task.task.result()

    print(result)
    print(self.context)

    # Send a basic message to available active connection
    tag_filter = {}
    post_filter = {&#34;state&#34;: &#34;active&#34;}
    records: typing.List[ConnectionRecord] = await ConnectionRecord.query(
        self.context,
        tag_filter,
        post_filter
    )

    responder: BaseResponder = await self.context.inject(BaseResponder, required=False)
    basic_message = BasicMessage(content=&#34;Triggered by task queue callback...&#34;)
    if responder:
        for record in records:
            await responder.send(basic_message, connection_id=record.connection_id)</code></pre>
</details>
</dd>
<dt id="dexa_sdk.managers.ada_manager.V2ADAManager.sample_queue_snippet"><code class="name flex">
<span>async def <span class="ident">sample_queue_snippet</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Sample queue snippet</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def sample_queue_snippet(self):
    &#34;&#34;&#34;Sample queue snippet&#34;&#34;&#34;
    pending_task = await self.add_task(self.context,
                                       self.long_running_task(),
                                       self.queue_callback)
    print(pending_task)</code></pre>
</details>
</dd>
<dt id="dexa_sdk.managers.ada_manager.V2ADAManager.update_and_store_da_template_in_wallet"><code class="name flex">
<span>async def <span class="ident">update_and_store_da_template_in_wallet</span></span>(<span>self, template_id:Â str, data_agreement:Â dict, *, publish_flag:Â boolÂ =Â True, schema_id:Â strÂ =Â None) â>Â <a title="dexa_sdk.agreements.da.v1_0.records.da_template_record.DataAgreementTemplateRecord" href="../agreements/da/v1_0/records/da_template_record.html#dexa_sdk.agreements.da.v1_0.records.da_template_record.DataAgreementTemplateRecord">DataAgreementTemplateRecord</a></span>
</code></dt>
<dd>
<div class="desc"><p>Update and store data agreement template in wallet.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>template_id</code></strong> :&ensp;<code>str</code></dt>
<dd>Template identifier</dd>
<dt><strong><code>data_agreement</code></strong> :&ensp;<code>dict</code></dt>
<dd>Data agreement</dd>
<dt><strong><code>publish_flag</code></strong> :&ensp;<code>bool</code></dt>
<dd>Publish flag</dd>
<dt><strong><code>schema_id</code></strong> :&ensp;<code>str</code></dt>
<dd>Schema identifier</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>DataAgreementTemplateRecord</code></dt>
<dd>Updated record.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def update_and_store_da_template_in_wallet(
        self,
        template_id: str,
        data_agreement: dict,
        *,
        publish_flag: bool = True,
        schema_id: str = None
) -&gt; DataAgreementTemplateRecord:
    &#34;&#34;&#34;Update and store data agreement template in wallet.

    Args:
        template_id (str): Template identifier
        data_agreement (dict): Data agreement
        publish_flag (bool): Publish flag
        schema_id (str): Schema identifier

    Returns:
        DataAgreementTemplateRecord: Updated record.
    &#34;&#34;&#34;

    # Tag filter
    tag_filter = {
        &#34;delete_flag&#34;: bool_to_str(False),
        &#34;template_id&#34;: template_id,
        &#34;latest_version_flag&#34;: bool_to_str(True)
    }

    # Fetch data agreement record
    record: DataAgreementTemplateRecord = \
        await DataAgreementTemplateRecord.retrieve_by_tag_filter(self.context, tag_filter)

    # Validate the data agreement.
    previous_da: DataAgreementModel = DataAgreementModel.deserialize(record.data_agreement)

    assert previous_da.method_of_use == data_agreement.get(
        &#34;methodOfUse&#34;), &#34;Method of use cannot be updated.&#34;

    assert previous_da.data_policy.third_party_data_sharing \
        == data_agreement.get(&#34;dataPolicy&#34;).get(&#34;thirdPartyDataSharing&#34;), \
        &#34;Third party data sharing cannot be updated.&#34;

    # Copy the id, version from previous da to new da
    template_version = bump_major_for_semver_string(previous_da.version)
    template_id = previous_da.id
    data_agreement.update({&#34;@context&#34;: DA_DEFAULT_CONTEXT})
    data_agreement.update({&#34;@type&#34;: DA_TYPE})
    data_agreement.update({&#34;@id&#34;: template_id})
    data_agreement.update({&#34;version&#34;: template_version})

    updated_da: DataAgreementModel = DataAgreementModel.deserialize(data_agreement)

    # Create personal data records
    pds = updated_da.personal_data
    pd_records = []
    pd_models_with_id = []
    for pd in pds:
        pd_record: PersonalDataRecord = \
            await PersonalDataRecord.build_and_save_record_from_pd_model(
                self.context,
                template_id,
                template_version,
                pd
            )
        pd_records.append(pd_record)
        pd_models_with_id.append(pd_record.convert_record_to_pd_model())

    # Update the personal data with attribute identifiers to the agreement
    updated_da.personal_data = pd_models_with_id

    record.data_agreement = updated_da.serialize()
    record.publish_flag = bool_to_str(publish_flag)
    record.schema_id = schema_id
    record.existing_schema_flag = bool_to_str(True) if schema_id else bool_to_str(False)
    record.template_version = template_version

    await record.upgrade(self.context)

    if publish_flag:
        # Create ledger payloads
        record = await self.create_and_store_ledger_payloads_for_da_template(
            template_record=record,
            pd_records=pd_records,
            schema_id=schema_id
        )

    return record</code></pre>
</details>
</dd>
<dt id="dexa_sdk.managers.ada_manager.V2ADAManager.update_personal_data_description"><code class="name flex">
<span>async def <span class="ident">update_personal_data_description</span></span>(<span>self, attribute_id:Â str, desc:Â str) â>Â <a title="dexa_sdk.agreements.da.v1_0.records.personal_data_record.PersonalDataRecord" href="../agreements/da/v1_0/records/personal_data_record.html#dexa_sdk.agreements.da.v1_0.records.personal_data_record.PersonalDataRecord">PersonalDataRecord</a></span>
</code></dt>
<dd>
<div class="desc"><p>Update personal data description</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>attribute_id</code></strong> :&ensp;<code>str</code></dt>
<dd>Attribute id</dd>
<dt><strong><code>desc</code></strong> :&ensp;<code>str</code></dt>
<dd>Description</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>PersonalDataRecord</code></dt>
<dd>Personal data record</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def update_personal_data_description(self,
                                           attribute_id: str,
                                           desc: str) -&gt; PersonalDataRecord:
    &#34;&#34;&#34;Update personal data description

    Args:
        attribute_id (str): Attribute id
        desc (str): Description

    Returns:
        PersonalDataRecord: Personal data record
    &#34;&#34;&#34;

    # Fetch personal data record by id
    pd_record: PersonalDataRecord = await PersonalDataRecord.retrieve_by_id(
        self.context,
        attribute_id
    )

    # Fetch the associated data agreement record
    da_template_record: DataAgreementTemplateRecord = \
        await DataAgreementTemplateRecord.latest_template_by_id(
            self.context,
            pd_record.data_agreement_template_id
        )

    assert da_template_record, &#34;Matching data agreement template not found.&#34;
    assert da_template_record.template_version == \
        pd_record.data_agreement_template_version, \
        &#34;Matching data agreement template with same version not found.&#34;

    # Update the personal data record.
    pd_record.attribute_description = desc
    await pd_record.save(self.context)

    pd_model: DataAgreementPersonalDataModel = pd_record.convert_record_to_pd_model()

    # Update the data agreement record with new personal data.
    da: DataAgreementModel = DataAgreementModel.deserialize(da_template_record.data_agreement)
    # Iterate through the existing personal data in data agreements
    # And update the personal data matching the attribute id
    da_pds = []
    for da_pd in da.personal_data:
        if da_pd.attribute_id != pd_model.attribute_id:
            da_pds.append(da_pd)
    da_pds.append(pd_model)
    da.personal_data = da_pds

    da_template_record.data_agreement = da.serialize()
    await da_template_record.save(self.context)

    return pd_record</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="dexa_sdk.managers.ada_manager.V2ADAManagerError"><code class="flex name class">
<span>class <span class="ident">V2ADAManagerError</span></span>
<span>(</span><span>*args, error_code:Â strÂ =Â None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>ADA manager error</p>
<p>Initialize a BaseError instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class V2ADAManagerError(BaseError):
    &#34;&#34;&#34;ADA manager error&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>aries_cloudagent.core.error.BaseError</li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="dexa_sdk.managers" href="index.html">dexa_sdk.managers</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="dexa_sdk.managers.ada_manager.V2ADAManager" href="#dexa_sdk.managers.ada_manager.V2ADAManager">V2ADAManager</a></code></h4>
<ul class="">
<li><code><a title="dexa_sdk.managers.ada_manager.V2ADAManager.add_task" href="#dexa_sdk.managers.ada_manager.V2ADAManager.add_task">add_task</a></code></li>
<li><code><a title="dexa_sdk.managers.ada_manager.V2ADAManager.anchor_da_instance_to_blockchain" href="#dexa_sdk.managers.ada_manager.V2ADAManager.anchor_da_instance_to_blockchain">anchor_da_instance_to_blockchain</a></code></li>
<li><code><a title="dexa_sdk.managers.ada_manager.V2ADAManager.anchor_da_instance_to_blockchain_async_task" href="#dexa_sdk.managers.ada_manager.V2ADAManager.anchor_da_instance_to_blockchain_async_task">anchor_da_instance_to_blockchain_async_task</a></code></li>
<li><code><a title="dexa_sdk.managers.ada_manager.V2ADAManager.anchor_da_instance_to_blockchain_async_task_callback" href="#dexa_sdk.managers.ada_manager.V2ADAManager.anchor_da_instance_to_blockchain_async_task_callback">anchor_da_instance_to_blockchain_async_task_callback</a></code></li>
<li><code><a title="dexa_sdk.managers.ada_manager.V2ADAManager.build_data_agreement_accept_for_data_ex_record" href="#dexa_sdk.managers.ada_manager.V2ADAManager.build_data_agreement_accept_for_data_ex_record">build_data_agreement_accept_for_data_ex_record</a></code></li>
<li><code><a title="dexa_sdk.managers.ada_manager.V2ADAManager.build_data_agreement_negotiation_accept_by_instance_id" href="#dexa_sdk.managers.ada_manager.V2ADAManager.build_data_agreement_negotiation_accept_by_instance_id">build_data_agreement_negotiation_accept_by_instance_id</a></code></li>
<li><code><a title="dexa_sdk.managers.ada_manager.V2ADAManager.build_data_agreement_offer_for_credential_exchange" href="#dexa_sdk.managers.ada_manager.V2ADAManager.build_data_agreement_offer_for_credential_exchange">build_data_agreement_offer_for_credential_exchange</a></code></li>
<li><code><a title="dexa_sdk.managers.ada_manager.V2ADAManager.build_data_agreement_offer_for_presentation_exchange" href="#dexa_sdk.managers.ada_manager.V2ADAManager.build_data_agreement_offer_for_presentation_exchange">build_data_agreement_offer_for_presentation_exchange</a></code></li>
<li><code><a title="dexa_sdk.managers.ada_manager.V2ADAManager.construct_presentation_request" href="#dexa_sdk.managers.ada_manager.V2ADAManager.construct_presentation_request">construct_presentation_request</a></code></li>
<li><code><a title="dexa_sdk.managers.ada_manager.V2ADAManager.context" href="#dexa_sdk.managers.ada_manager.V2ADAManager.context">context</a></code></li>
<li><code><a title="dexa_sdk.managers.ada_manager.V2ADAManager.create_and_store_da_template_in_wallet" href="#dexa_sdk.managers.ada_manager.V2ADAManager.create_and_store_da_template_in_wallet">create_and_store_da_template_in_wallet</a></code></li>
<li><code><a title="dexa_sdk.managers.ada_manager.V2ADAManager.create_and_store_ledger_payloads_for_da_template" href="#dexa_sdk.managers.ada_manager.V2ADAManager.create_and_store_ledger_payloads_for_da_template">create_and_store_ledger_payloads_for_da_template</a></code></li>
<li><code><a title="dexa_sdk.managers.ada_manager.V2ADAManager.delete_da_instance_by_data_ex_id" href="#dexa_sdk.managers.ada_manager.V2ADAManager.delete_da_instance_by_data_ex_id">delete_da_instance_by_data_ex_id</a></code></li>
<li><code><a title="dexa_sdk.managers.ada_manager.V2ADAManager.delete_da_template_in_wallet" href="#dexa_sdk.managers.ada_manager.V2ADAManager.delete_da_template_in_wallet">delete_da_template_in_wallet</a></code></li>
<li><code><a title="dexa_sdk.managers.ada_manager.V2ADAManager.delete_personal_data" href="#dexa_sdk.managers.ada_manager.V2ADAManager.delete_personal_data">delete_personal_data</a></code></li>
<li><code><a title="dexa_sdk.managers.ada_manager.V2ADAManager.long_running_task" href="#dexa_sdk.managers.ada_manager.V2ADAManager.long_running_task">long_running_task</a></code></li>
<li><code><a title="dexa_sdk.managers.ada_manager.V2ADAManager.process_decorator_with_da_accept_message" href="#dexa_sdk.managers.ada_manager.V2ADAManager.process_decorator_with_da_accept_message">process_decorator_with_da_accept_message</a></code></li>
<li><code><a title="dexa_sdk.managers.ada_manager.V2ADAManager.process_decorator_with_da_offer_message" href="#dexa_sdk.managers.ada_manager.V2ADAManager.process_decorator_with_da_offer_message">process_decorator_with_da_offer_message</a></code></li>
<li><code><a title="dexa_sdk.managers.ada_manager.V2ADAManager.publish_da_template_in_wallet" href="#dexa_sdk.managers.ada_manager.V2ADAManager.publish_da_template_in_wallet">publish_da_template_in_wallet</a></code></li>
<li><code><a title="dexa_sdk.managers.ada_manager.V2ADAManager.query_da_templates_in_wallet" href="#dexa_sdk.managers.ada_manager.V2ADAManager.query_da_templates_in_wallet">query_da_templates_in_wallet</a></code></li>
<li><code><a title="dexa_sdk.managers.ada_manager.V2ADAManager.query_data_agreement_instances" href="#dexa_sdk.managers.ada_manager.V2ADAManager.query_data_agreement_instances">query_data_agreement_instances</a></code></li>
<li><code><a title="dexa_sdk.managers.ada_manager.V2ADAManager.query_pd_of_da_template_from_wallet" href="#dexa_sdk.managers.ada_manager.V2ADAManager.query_pd_of_da_template_from_wallet">query_pd_of_da_template_from_wallet</a></code></li>
<li><code><a title="dexa_sdk.managers.ada_manager.V2ADAManager.queue_callback" href="#dexa_sdk.managers.ada_manager.V2ADAManager.queue_callback">queue_callback</a></code></li>
<li><code><a title="dexa_sdk.managers.ada_manager.V2ADAManager.sample_queue_snippet" href="#dexa_sdk.managers.ada_manager.V2ADAManager.sample_queue_snippet">sample_queue_snippet</a></code></li>
<li><code><a title="dexa_sdk.managers.ada_manager.V2ADAManager.update_and_store_da_template_in_wallet" href="#dexa_sdk.managers.ada_manager.V2ADAManager.update_and_store_da_template_in_wallet">update_and_store_da_template_in_wallet</a></code></li>
<li><code><a title="dexa_sdk.managers.ada_manager.V2ADAManager.update_personal_data_description" href="#dexa_sdk.managers.ada_manager.V2ADAManager.update_personal_data_description">update_personal_data_description</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="dexa_sdk.managers.ada_manager.V2ADAManagerError" href="#dexa_sdk.managers.ada_manager.V2ADAManagerError">V2ADAManagerError</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>